// Code generated from ./src/parser/ElasticSQL.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // ElasticSQL
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type ElasticSQLParser struct {
	*antlr.BaseParser
}

var ElasticSQLParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func elasticsqlParserInit() {
	staticData := &ElasticSQLParserStaticData
	staticData.LiteralNames = []string{
		"", "'|'", "'/*+'", "'*/'", "','", "'('", "')'", "'['", "']'", "';'",
		"'precision_threshold'", "'percents'", "'$'", "'REMOVE'", "'SELECT'",
		"'SCROLL'", "'HIGHLIGHT'", "'SCROLL_ID'", "'INNER_HIT'", "'WHERE'",
		"'CUSTOM_SCORE'", "'RESCORE'", "'WINDOWS'", "'COLLAPSE'", "'SCORE'",
		"'MEM-SORT'", "'KEEP'", "'WEIGHT'", "'EXPLAIN'", "'WHERES'", "'LIMIT'",
		"'TRACK_HIT'", "'OFFSET'", "'SQL'", "'STRUCT'", "'HQL'", "'CK'", "'PQL'",
		"'MQL'", "'URL'", "'PASSWORD'", "'USER'", "'WITH'", "'AS'", "'MAP'",
		"'USING'", "'GROUP'", "'BY'", "'ORDER'", "'ASC'", "'DESC'", "'DESCRIBE'",
		"'TEMPLATE'", "'BETWEEN'", "'OR'", "'ALL'", "'AND'", "'NOT'", "'INTO'",
		"'TO'", "'FROM'", "'HAVING'", "'EXCLUDE'", "'INCLUDE'", "'DOC_COUNT'",
		"'TOP'", "'INSERT'", "'VALUES'", "'ID'", "'SLICE'", "'EXPORT'", "'HEADER'",
		"'JSON'", "'CSV'", "'EXCEL'", "'SEP'", "", "'LANG'", "'RETURN'", "'ON'",
		"'PK'", "'UUID'", "'MEM'", "'RIGHT'", "'LEFT'", "'JOIN'", "'AGG'", "'ALIAS'",
		"'ALTER'", "'RLIKE'", "'LIKE'", "'NOT_LIKE'", "'STARTS_WITH'", "'IN'",
		"'OUT'", "'HAS_ANY'", "'HAS_ALL'", "'EXIST'", "'MISS'", "'QUERY_STRING'",
		"'MATCH'", "'MULTI_MATCH'", "'MATCH_PHRASE_PREFIX'", "'MATCH_PHRASE'",
		"'KNN'", "'LOCAL_FILE'", "'HAS_CHILD'", "'HAS_PARENT'", "'COUNT'", "'MAX'",
		"'MIN'", "'AVG'", "'AVG_DATE'", "'SUM'", "'DISTINCT'", "'VALUE_COUNT'",
		"'PERCENTILE_RANKS'", "'PERCENTILES'", "'PERCENT'", "'DISTINCT_PERCENT'",
		"'TOP_HITS'", "'POST_EXPR'", "'MATH'", "'RANGE'", "'DATE_RANGE'", "'HISTOGRAM'",
		"'DATE_HISTOGRAM'", "'INTERVAL'", "'FORMAT'", "'KEYED'", "'SIZE'", "'MISSING'",
		"'NULL'", "'WHEN'", "'END'", "'THEN'", "'SAMPLE'", "'SIGNIFICANT'",
		"'IDS'", "'IDS_FILE'", "'SET'", "'UPDATE'", "'UPSERT'", "'PUT'", "'ADD'",
		"'BATCH_UPDATE'", "'BATCH_UPSERT'", "'DELETE'", "'ARRAY'", "'FALSE'",
		"'TRUE'", "'NUMBER'", "'STRING'", "'BOOLEAN'", "'LONG'", "'DOUBLE'",
		"", "'DATETIME'", "'TIMESTAMP'", "'DATE'", "'TIME'", "'FLOAT'", "'LOCAL'",
		"'DATA'", "'LOAD'", "'LIST'", "'SEPARATED'", "'ANALYZE'", "'NLP'", "'ENABLE'",
		"", "'NAME'", "", "", "'+'", "'-'", "'*'", "'/'", "'%'", "'^'", "'.'",
		"", "'!='", "'<'", "'<='", "'>'", "'>='",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "REMOVE", "SELECT",
		"SCROLL", "HIGHLIGHT", "SCROLL_ID", "INNER_HIT", "WHERE", "CUSTOM_SCORE",
		"RESCORE", "WINDOWS", "COLLAPSE", "SCORE", "MEM_SORT", "KEEP", "WEIGHT",
		"EXPLAIN", "WHERES", "LIMIT", "TRACK_HIT", "OFFSET", "SQL", "STRUCT",
		"HQL", "CK", "PQL", "MQL", "URL", "PASSWORD", "USER", "WITH", "AS",
		"MAP", "USING", "GROUP", "BY", "ORDER", "ASC", "DESC", "DESCRIBE", "TEMPLATE",
		"BETWEEN", "OR", "ALL", "AND", "NOT", "INTO", "TO", "FROM", "HAVING",
		"EXCLUDE", "INCLUDE", "DOC_COUNT", "TOP", "INSERT", "VALUES", "ID",
		"SLICE", "EXPORT", "HEADER", "JSON", "CSV", "EXCEL", "SEP", "SCRIPT",
		"LANG", "RETURN", "ON", "PK", "UUID", "MEM", "RIGHT", "LEFT", "JOIN",
		"AGG", "ALIAS", "ALTER", "RLIKE", "LIKE", "NOT_LIKE", "STARTS_WITH",
		"IN", "OUT", "HAS_ANY", "HAS_ALL", "EXIST", "MISS", "QUERY_STRING",
		"MATCH", "MULTI_MATCH", "MATCH_PHRASE_PREFIX", "MATCH_PHRASE", "KNN",
		"LOCAL_FILE", "HAS_CHILD", "HAS_PARENT", "COUNT", "MAX", "MIN", "AVG",
		"AVG_DATE", "SUM", "DISTINCT", "VALUE_COUNT", "PERCENTILE_RANKS", "PERCENTILES",
		"PERCENT", "DISTINCT_PERCENT", "TOP_HITS", "POST_EXPR", "MATH", "RANGE",
		"DATE_RANGE", "HISTOGRAM", "DATE_HISTOGRAM", "INTERVAL", "FORMAT", "KEYED",
		"SIZE", "MISSING", "NULL", "WHEN", "END", "THEN", "SAMPLE", "SIGNIFICANT",
		"IDS", "IDS_FILE", "SET", "UPDATE", "UPSERT", "PUT", "ADD", "BATCH_UPDATE",
		"BATCH_UPSERT", "DELETE", "ARRAY", "FALSE", "TRUE", "NUMBER", "STRING",
		"BOOLEAN_T", "LONG_T", "DOUBLE_T", "INTEGER_T", "DATETIME_T", "TIMESTAMP_T",
		"DATE_T", "TIME_T", "FLOAT_T", "LOCAL", "DATA", "LOAD", "LIST", "SEPARATED",
		"ANALYZE", "NLP", "ENABLE", "SEGMENT", "NAME", "ORG", "LOC", "PLUS",
		"MINUS", "MUL", "DIV", "MOD", "POWER", "DOT", "EQ", "NE", "LT", "LE",
		"GT", "GE", "LONG", "DOUBLE", "QUOTASTR", "IDENTIFIER", "EXT_IDENTIFIER",
		"LINE_COMMENT", "BLOCK_COMMNET", "WS",
	}
	staticData.RuleNames = []string{
		"elasticSQL", "statement", "queryStatement", "selectItem", "collapseExpr",
		"customScoreExpr", "rescoreExpr", "memSort", "innerHit", "scriptField",
		"highlight", "fieldAs", "whereExpression", "logicalExpr", "comparableExpression",
		"termCompare", "btwCompare", "arithmeticExpressionCompare", "arithmeticExpression",
		"addition", "multiplyingExpression", "multi", "atom", "functionalCompare",
		"joinFunction", "joinFunctionNames", "scriptFunction", "fullLevelFunction",
		"fullLevelFunctionNames", "termLevelFunction", "termLevelFunctionNames",
		"prop", "param", "param2", "arrayValue", "sortItem", "exportStatement",
		"exportField", "analysisStatement", "aggStatement", "metricAgg", "metricNames",
		"metricParams", "mkv", "metricParamNames", "scriptPhrase", "bucketAggList",
		"bucketAgg", "bucketAggChoice", "termsBucket", "havingExpr", "rangeBucket",
		"rangeExpr", "rangeUnit", "rangeFromTo", "dateRangeBucket", "dateRangeExpr",
		"dateRange", "dateRangeFromTo", "histogramBucket", "dateHistogramBucket",
		"significantBucket", "filtersBucket", "sparkStatement", "dataStruct",
		"joinQueryAnalysisStatement", "insertStatement", "fieldList", "valueList",
		"paramValues", "updateStatement", "updateField", "batchUpdateStatement",
		"deleteStatement", "descStatement", "aliasStatement", "alterStatement",
		"hive2Statement", "jdbcStatement", "basicSQL", "fileLoadStatement",
		"fieldDefine", "analyzeStatement", "hanLPStatement", "nlpFunc", "dataType",
		"comparisonOperator", "pathIdentifier", "fieldIdentifier", "indexIdentifier",
		"indexName", "strictIdentifier", "str", "number", "booleanValue", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 194, 1730, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 1, 0, 1, 0, 1, 0, 5, 0, 196, 8, 0, 10, 0, 12, 0, 199,
		9, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 217, 8, 1, 1, 2, 1, 2, 3, 2, 221, 8,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 228, 8, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 3, 2, 235, 8, 2, 3, 2, 237, 8, 2, 1, 2, 3, 2, 240, 8, 2, 1, 2,
		1, 2, 3, 2, 244, 8, 2, 1, 2, 5, 2, 247, 8, 2, 10, 2, 12, 2, 250, 9, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 256, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2,
		262, 8, 2, 10, 2, 12, 2, 265, 9, 2, 1, 2, 1, 2, 1, 2, 3, 2, 270, 8, 2,
		3, 2, 272, 8, 2, 1, 2, 3, 2, 275, 8, 2, 1, 2, 3, 2, 278, 8, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 5, 2, 285, 8, 2, 10, 2, 12, 2, 288, 9, 2, 3, 2, 290,
		8, 2, 1, 2, 1, 2, 3, 2, 294, 8, 2, 1, 2, 1, 2, 1, 2, 3, 2, 299, 8, 2, 1,
		2, 1, 2, 3, 2, 303, 8, 2, 3, 2, 305, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		3, 2, 312, 8, 2, 1, 2, 3, 2, 315, 8, 2, 3, 2, 317, 8, 2, 3, 2, 319, 8,
		2, 3, 2, 321, 8, 2, 1, 2, 1, 2, 3, 2, 325, 8, 2, 1, 2, 3, 2, 328, 8, 2,
		1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 334, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 5,
		1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 347, 8, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 3, 6, 355, 8, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 5, 7, 364, 8, 7, 10, 7, 12, 7, 367, 9, 7, 1, 7, 1, 7, 3, 7, 371,
		8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 378, 8, 8, 10, 8, 12, 8, 381,
		9, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 5, 10, 396, 8, 10, 10, 10, 12, 10, 399, 9, 10, 1, 10,
		1, 10, 1, 10, 3, 10, 404, 8, 10, 1, 11, 1, 11, 3, 11, 408, 8, 11, 1, 11,
		3, 11, 411, 8, 11, 1, 11, 1, 11, 3, 11, 415, 8, 11, 1, 12, 1, 12, 3, 12,
		419, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 427, 8, 12,
		1, 12, 1, 12, 3, 12, 431, 8, 12, 3, 12, 433, 8, 12, 1, 12, 3, 12, 436,
		8, 12, 1, 13, 1, 13, 1, 13, 3, 13, 441, 8, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 3, 13, 447, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13,
		455, 8, 13, 10, 13, 12, 13, 458, 9, 13, 1, 14, 3, 14, 461, 8, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 3, 14, 467, 8, 14, 1, 15, 1, 15, 1, 15, 3, 15, 472,
		8, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 3, 16, 479, 8, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 489, 8, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 496, 8, 16, 3, 16, 498, 8, 16, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 5, 18, 506, 8, 18, 10, 18, 12, 18, 509,
		9, 18, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 5, 20, 516, 8, 20, 10, 20, 12,
		20, 519, 9, 20, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 535, 8, 22, 1, 23, 1,
		23, 1, 23, 1, 23, 3, 23, 541, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		3, 24, 548, 8, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1,
		27, 1, 27, 1, 27, 1, 27, 5, 27, 561, 8, 27, 10, 27, 12, 27, 564, 9, 27,
		1, 27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 3, 29, 573, 8, 29, 3,
		29, 575, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 5, 29, 582, 8, 29, 10,
		29, 12, 29, 585, 9, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		3, 29, 594, 8, 29, 1, 29, 1, 29, 5, 29, 598, 8, 29, 10, 29, 12, 29, 601,
		9, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 608, 8, 29, 3, 29, 610,
		8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 617, 8, 29, 1, 30, 1,
		30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32,
		3, 32, 631, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 639,
		8, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 3, 35, 646, 8, 35, 1, 35, 3,
		35, 649, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 655, 8, 35, 1, 35, 3,
		35, 658, 8, 35, 1, 35, 3, 35, 661, 8, 35, 1, 36, 1, 36, 3, 36, 665, 8,
		36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 671, 8, 36, 10, 36, 12, 36, 674,
		9, 36, 1, 36, 1, 36, 3, 36, 678, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1,
		36, 5, 36, 685, 8, 36, 10, 36, 12, 36, 688, 9, 36, 1, 36, 1, 36, 3, 36,
		692, 8, 36, 3, 36, 694, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 700,
		8, 36, 3, 36, 702, 8, 36, 1, 36, 1, 36, 1, 37, 1, 37, 3, 37, 708, 8, 37,
		1, 38, 1, 38, 3, 38, 712, 8, 38, 1, 38, 1, 38, 1, 38, 5, 38, 717, 8, 38,
		10, 38, 12, 38, 720, 9, 38, 1, 39, 1, 39, 3, 39, 724, 8, 39, 1, 39, 3,
		39, 727, 8, 39, 1, 39, 1, 39, 1, 39, 5, 39, 732, 8, 39, 10, 39, 12, 39,
		735, 9, 39, 1, 39, 1, 39, 1, 39, 3, 39, 740, 8, 39, 1, 39, 3, 39, 743,
		8, 39, 1, 39, 1, 39, 3, 39, 747, 8, 39, 1, 39, 1, 39, 3, 39, 751, 8, 39,
		1, 39, 3, 39, 754, 8, 39, 1, 40, 1, 40, 3, 40, 758, 8, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 769, 8, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 778, 8, 40, 1, 40,
		3, 40, 781, 8, 40, 1, 40, 3, 40, 784, 8, 40, 1, 41, 1, 41, 1, 42, 1, 42,
		1, 42, 5, 42, 791, 8, 42, 10, 42, 12, 42, 794, 9, 42, 1, 42, 1, 42, 3,
		42, 798, 8, 42, 1, 42, 3, 42, 801, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45,
		817, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 5, 45, 823, 8, 45, 10, 45, 12,
		45, 826, 9, 45, 1, 45, 1, 45, 3, 45, 830, 8, 45, 1, 45, 3, 45, 833, 8,
		45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 840, 8, 46, 10, 46, 12, 46,
		843, 9, 46, 1, 46, 1, 46, 3, 46, 847, 8, 46, 1, 47, 1, 47, 3, 47, 851,
		8, 47, 1, 47, 3, 47, 854, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 3, 48, 863, 8, 48, 1, 49, 3, 49, 866, 8, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 5, 49, 873, 8, 49, 10, 49, 12, 49, 876, 9, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 885, 8, 49, 10, 49, 12,
		49, 888, 9, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 905, 8, 49, 5,
		49, 907, 8, 49, 10, 49, 12, 49, 910, 9, 49, 1, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 925,
		8, 51, 1, 51, 3, 51, 928, 8, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1,
		52, 1, 52, 5, 52, 937, 8, 52, 10, 52, 12, 52, 940, 9, 52, 1, 53, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 948, 8, 53, 1, 53, 1, 53, 1, 54, 1,
		54, 3, 54, 954, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55,
		962, 8, 55, 1, 55, 3, 55, 965, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55,
		971, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 5, 56, 980,
		8, 56, 10, 56, 12, 56, 983, 9, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 3, 57, 991, 8, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 3, 58, 998, 8,
		58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1006, 8, 59, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1013, 8, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 3, 59, 1019, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1026,
		8, 59, 3, 59, 1028, 8, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 3, 60, 1038, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60,
		1045, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1051, 8, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 3, 60, 1057, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
		3, 60, 1064, 8, 60, 3, 60, 1066, 8, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61, 1090, 8, 61, 10,
		61, 12, 61, 1093, 9, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 5, 61, 1103, 8, 61, 10, 61, 12, 61, 1106, 9, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 5, 61, 1113, 8, 61, 10, 61, 12, 61, 1116, 9, 61, 1, 61,
		1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 4, 62, 1126, 8, 62, 11,
		62, 12, 62, 1127, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5, 63,
		1137, 8, 63, 10, 63, 12, 63, 1140, 9, 63, 1, 63, 1, 63, 3, 63, 1144, 8,
		63, 1, 63, 1, 63, 1, 63, 3, 63, 1149, 8, 63, 1, 63, 1, 63, 3, 63, 1153,
		8, 63, 1, 63, 3, 63, 1156, 8, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 5, 64, 1165, 8, 64, 10, 64, 12, 64, 1168, 9, 64, 1, 64, 1, 64,
		1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 1176, 8, 65, 10, 65, 12, 65, 1179, 9,
		65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1188, 8, 65,
		3, 65, 1190, 8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 1196, 8, 65, 10,
		65, 12, 65, 1199, 9, 65, 1, 65, 1, 65, 3, 65, 1203, 8, 65, 1, 65, 1, 65,
		3, 65, 1207, 8, 65, 1, 65, 3, 65, 1210, 8, 65, 1, 65, 3, 65, 1213, 8, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1219, 8, 65, 1, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 1230, 8, 65, 10, 65, 12,
		65, 1233, 9, 65, 3, 65, 1235, 8, 65, 1, 65, 1, 65, 3, 65, 1239, 8, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1246, 8, 65, 1, 65, 3, 65, 1249,
		8, 65, 3, 65, 1251, 8, 65, 1, 65, 3, 65, 1254, 8, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 5, 65, 1260, 8, 65, 10, 65, 12, 65, 1263, 9, 65, 3, 65, 1265,
		8, 65, 1, 65, 1, 65, 3, 65, 1269, 8, 65, 1, 66, 1, 66, 3, 66, 1273, 8,
		66, 1, 66, 3, 66, 1276, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66,
		1283, 8, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1288, 8, 66, 3, 66, 1290, 8, 66,
		1, 66, 1, 66, 3, 66, 1294, 8, 66, 1, 66, 1, 66, 3, 66, 1298, 8, 66, 1,
		66, 1, 66, 3, 66, 1302, 8, 66, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 1308,
		8, 67, 10, 67, 12, 67, 1311, 9, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68,
		1, 68, 3, 68, 1319, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 5, 69, 1325, 8,
		69, 10, 69, 12, 69, 1328, 9, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1,
		70, 5, 70, 1336, 8, 70, 10, 70, 12, 70, 1339, 9, 70, 1, 70, 3, 70, 1342,
		8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70, 1348, 8, 70, 10, 70, 12, 70,
		1351, 9, 70, 3, 70, 1353, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70, 1369,
		8, 70, 10, 70, 12, 70, 1372, 9, 70, 1, 70, 1, 70, 3, 70, 1376, 8, 70, 1,
		70, 1, 70, 3, 70, 1380, 8, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71,
		1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 5, 71, 1393, 8, 71, 10, 71, 12, 71,
		1396, 9, 71, 1, 71, 1, 71, 3, 71, 1400, 8, 71, 1, 71, 1, 71, 1, 71, 1,
		71, 1, 71, 1, 71, 1, 71, 1, 71, 5, 71, 1410, 8, 71, 10, 71, 12, 71, 1413,
		9, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1,
		71, 5, 71, 1425, 8, 71, 10, 71, 12, 71, 1428, 9, 71, 1, 71, 1, 71, 3, 71,
		1432, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 5, 72, 1438, 8, 72, 10, 72, 12,
		72, 1441, 9, 72, 1, 72, 3, 72, 1444, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72,
		1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 5, 72, 1455, 8, 72, 10, 72, 12, 72,
		1458, 9, 72, 3, 72, 1460, 8, 72, 1, 72, 1, 72, 3, 72, 1464, 8, 72, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 5, 73, 1471, 8, 73, 10, 73, 12, 73, 1474, 9,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1491, 8, 73, 1, 73, 1, 73, 3,
		73, 1495, 8, 73, 1, 74, 1, 74, 3, 74, 1499, 8, 74, 1, 74, 1, 74, 1, 74,
		5, 74, 1504, 8, 74, 10, 74, 12, 74, 1507, 9, 74, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 5, 75, 1516, 8, 75, 10, 75, 12, 75, 1519, 9, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 5, 75, 1528, 8, 75, 10,
		75, 12, 75, 1531, 9, 75, 3, 75, 1533, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76,
		5, 76, 1539, 8, 76, 10, 76, 12, 76, 1542, 9, 76, 1, 76, 1, 76, 1, 76, 1,
		76, 5, 76, 1548, 8, 76, 10, 76, 12, 76, 1551, 9, 76, 1, 77, 1, 77, 3, 77,
		1555, 8, 77, 1, 77, 1, 77, 1, 77, 1, 77, 5, 77, 1561, 8, 77, 10, 77, 12,
		77, 1564, 9, 77, 1, 77, 1, 77, 3, 77, 1568, 8, 77, 1, 77, 3, 77, 1571,
		8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1581,
		8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1586, 8, 78, 1, 78, 3, 78, 1589, 8,
		78, 1, 78, 1, 78, 1, 78, 5, 78, 1594, 8, 78, 10, 78, 12, 78, 1597, 9, 78,
		1, 79, 1, 79, 1, 79, 3, 79, 1602, 8, 79, 1, 79, 3, 79, 1605, 8, 79, 1,
		80, 1, 80, 3, 80, 1609, 8, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1614, 8, 80,
		1, 80, 1, 80, 5, 80, 1618, 8, 80, 10, 80, 12, 80, 1621, 9, 80, 1, 80, 1,
		80, 1, 80, 3, 80, 1626, 8, 80, 3, 80, 1628, 8, 80, 1, 80, 1, 80, 3, 80,
		1632, 8, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1638, 8, 80, 1, 80, 1,
		80, 1, 80, 3, 80, 1643, 8, 80, 1, 80, 3, 80, 1646, 8, 80, 1, 80, 1, 80,
		3, 80, 1650, 8, 80, 1, 81, 1, 81, 3, 81, 1654, 8, 81, 1, 82, 1, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 3, 82, 1662, 8, 82, 3, 82, 1664, 8, 82, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 1674, 8, 83, 10,
		83, 12, 83, 1677, 9, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1, 86,
		1, 86, 1, 87, 1, 87, 1, 87, 5, 87, 1690, 8, 87, 10, 87, 12, 87, 1693, 9,
		87, 1, 88, 1, 88, 1, 88, 5, 88, 1698, 8, 88, 10, 88, 12, 88, 1701, 9, 88,
		1, 88, 3, 88, 1704, 8, 88, 1, 89, 1, 89, 1, 89, 3, 89, 1709, 8, 89, 1,
		90, 1, 90, 3, 90, 1713, 8, 90, 1, 90, 3, 90, 1716, 8, 90, 1, 91, 1, 91,
		3, 91, 1720, 8, 91, 1, 92, 1, 92, 1, 93, 1, 93, 1, 94, 1, 94, 1, 95, 1,
		95, 1, 95, 0, 1, 26, 96, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
		26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
		62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
		98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
		128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156,
		158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186,
		188, 190, 0, 26, 1, 0, 174, 175, 1, 0, 176, 177, 1, 0, 106, 107, 1, 0,
		99, 104, 3, 0, 89, 98, 105, 105, 138, 138, 1, 0, 151, 152, 1, 0, 49, 50,
		2, 0, 109, 111, 113, 113, 1, 0, 72, 74, 2, 0, 24, 24, 108, 121, 4, 0, 10,
		11, 48, 48, 63, 63, 128, 131, 2, 0, 55, 55, 83, 84, 1, 0, 141, 142, 2,
		0, 44, 44, 165, 165, 1, 0, 145, 146, 1, 0, 50, 51, 1, 0, 36, 38, 1, 0,
		170, 173, 1, 0, 152, 161, 1, 0, 181, 186, 2, 0, 180, 180, 185, 185, 2,
		0, 12, 12, 180, 180, 1, 0, 189, 191, 1, 0, 187, 188, 1, 0, 149, 150, 29,
		0, 18, 18, 21, 24, 33, 34, 36, 36, 39, 41, 46, 46, 52, 52, 55, 55, 57,
		59, 62, 63, 68, 69, 72, 78, 80, 84, 87, 87, 89, 90, 93, 94, 97, 104, 106,
		111, 113, 120, 122, 123, 127, 132, 134, 134, 136, 136, 138, 139, 143, 144,
		151, 152, 157, 160, 162, 163, 165, 173, 1925, 0, 192, 1, 0, 0, 0, 2, 216,
		1, 0, 0, 0, 4, 220, 1, 0, 0, 0, 6, 333, 1, 0, 0, 0, 8, 335, 1, 0, 0, 0,
		10, 339, 1, 0, 0, 0, 12, 342, 1, 0, 0, 0, 14, 358, 1, 0, 0, 0, 16, 372,
		1, 0, 0, 0, 18, 386, 1, 0, 0, 0, 20, 390, 1, 0, 0, 0, 22, 405, 1, 0, 0,
		0, 24, 426, 1, 0, 0, 0, 26, 446, 1, 0, 0, 0, 28, 460, 1, 0, 0, 0, 30, 468,
		1, 0, 0, 0, 32, 476, 1, 0, 0, 0, 34, 499, 1, 0, 0, 0, 36, 503, 1, 0, 0,
		0, 38, 510, 1, 0, 0, 0, 40, 513, 1, 0, 0, 0, 42, 520, 1, 0, 0, 0, 44, 534,
		1, 0, 0, 0, 46, 540, 1, 0, 0, 0, 48, 542, 1, 0, 0, 0, 50, 551, 1, 0, 0,
		0, 52, 553, 1, 0, 0, 0, 54, 555, 1, 0, 0, 0, 56, 567, 1, 0, 0, 0, 58, 616,
		1, 0, 0, 0, 60, 618, 1, 0, 0, 0, 62, 620, 1, 0, 0, 0, 64, 630, 1, 0, 0,
		0, 66, 638, 1, 0, 0, 0, 68, 640, 1, 0, 0, 0, 70, 648, 1, 0, 0, 0, 72, 662,
		1, 0, 0, 0, 74, 707, 1, 0, 0, 0, 76, 711, 1, 0, 0, 0, 78, 726, 1, 0, 0,
		0, 80, 757, 1, 0, 0, 0, 82, 785, 1, 0, 0, 0, 84, 800, 1, 0, 0, 0, 86, 802,
		1, 0, 0, 0, 88, 806, 1, 0, 0, 0, 90, 832, 1, 0, 0, 0, 92, 846, 1, 0, 0,
		0, 94, 848, 1, 0, 0, 0, 96, 862, 1, 0, 0, 0, 98, 865, 1, 0, 0, 0, 100,
		911, 1, 0, 0, 0, 102, 918, 1, 0, 0, 0, 104, 933, 1, 0, 0, 0, 106, 941,
		1, 0, 0, 0, 108, 953, 1, 0, 0, 0, 110, 955, 1, 0, 0, 0, 112, 976, 1, 0,
		0, 0, 114, 984, 1, 0, 0, 0, 116, 997, 1, 0, 0, 0, 118, 999, 1, 0, 0, 0,
		120, 1031, 1, 0, 0, 0, 122, 1069, 1, 0, 0, 0, 124, 1119, 1, 0, 0, 0, 126,
		1131, 1, 0, 0, 0, 128, 1157, 1, 0, 0, 0, 130, 1171, 1, 0, 0, 0, 132, 1272,
		1, 0, 0, 0, 134, 1303, 1, 0, 0, 0, 136, 1314, 1, 0, 0, 0, 138, 1320, 1,
		0, 0, 0, 140, 1331, 1, 0, 0, 0, 142, 1431, 1, 0, 0, 0, 144, 1433, 1, 0,
		0, 0, 146, 1465, 1, 0, 0, 0, 148, 1496, 1, 0, 0, 0, 150, 1532, 1, 0, 0,
		0, 152, 1534, 1, 0, 0, 0, 154, 1554, 1, 0, 0, 0, 156, 1572, 1, 0, 0, 0,
		158, 1598, 1, 0, 0, 0, 160, 1606, 1, 0, 0, 0, 162, 1651, 1, 0, 0, 0, 164,
		1655, 1, 0, 0, 0, 166, 1665, 1, 0, 0, 0, 168, 1680, 1, 0, 0, 0, 170, 1682,
		1, 0, 0, 0, 172, 1684, 1, 0, 0, 0, 174, 1686, 1, 0, 0, 0, 176, 1703, 1,
		0, 0, 0, 178, 1705, 1, 0, 0, 0, 180, 1715, 1, 0, 0, 0, 182, 1719, 1, 0,
		0, 0, 184, 1721, 1, 0, 0, 0, 186, 1723, 1, 0, 0, 0, 188, 1725, 1, 0, 0,
		0, 190, 1727, 1, 0, 0, 0, 192, 197, 3, 2, 1, 0, 193, 194, 5, 1, 0, 0, 194,
		196, 3, 2, 1, 0, 195, 193, 1, 0, 0, 0, 196, 199, 1, 0, 0, 0, 197, 195,
		1, 0, 0, 0, 197, 198, 1, 0, 0, 0, 198, 1, 1, 0, 0, 0, 199, 197, 1, 0, 0,
		0, 200, 217, 3, 4, 2, 0, 201, 217, 3, 76, 38, 0, 202, 217, 3, 126, 63,
		0, 203, 217, 3, 132, 66, 0, 204, 217, 3, 140, 70, 0, 205, 217, 3, 144,
		72, 0, 206, 217, 3, 146, 73, 0, 207, 217, 3, 148, 74, 0, 208, 217, 3, 150,
		75, 0, 209, 217, 3, 152, 76, 0, 210, 217, 3, 130, 65, 0, 211, 217, 3, 154,
		77, 0, 212, 217, 3, 156, 78, 0, 213, 217, 3, 160, 80, 0, 214, 217, 3, 164,
		82, 0, 215, 217, 3, 166, 83, 0, 216, 200, 1, 0, 0, 0, 216, 201, 1, 0, 0,
		0, 216, 202, 1, 0, 0, 0, 216, 203, 1, 0, 0, 0, 216, 204, 1, 0, 0, 0, 216,
		205, 1, 0, 0, 0, 216, 206, 1, 0, 0, 0, 216, 207, 1, 0, 0, 0, 216, 208,
		1, 0, 0, 0, 216, 209, 1, 0, 0, 0, 216, 210, 1, 0, 0, 0, 216, 211, 1, 0,
		0, 0, 216, 212, 1, 0, 0, 0, 216, 213, 1, 0, 0, 0, 216, 214, 1, 0, 0, 0,
		216, 215, 1, 0, 0, 0, 217, 3, 1, 0, 0, 0, 218, 219, 5, 45, 0, 0, 219, 221,
		3, 182, 91, 0, 220, 218, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221, 222, 1,
		0, 0, 0, 222, 239, 5, 14, 0, 0, 223, 227, 5, 2, 0, 0, 224, 225, 5, 15,
		0, 0, 225, 226, 5, 181, 0, 0, 226, 228, 3, 184, 92, 0, 227, 224, 1, 0,
		0, 0, 227, 228, 1, 0, 0, 0, 228, 236, 1, 0, 0, 0, 229, 234, 5, 24, 0, 0,
		230, 231, 5, 181, 0, 0, 231, 235, 3, 188, 94, 0, 232, 233, 5, 186, 0, 0,
		233, 235, 3, 186, 93, 0, 234, 230, 1, 0, 0, 0, 234, 232, 1, 0, 0, 0, 235,
		237, 1, 0, 0, 0, 236, 229, 1, 0, 0, 0, 236, 237, 1, 0, 0, 0, 237, 238,
		1, 0, 0, 0, 238, 240, 5, 3, 0, 0, 239, 223, 1, 0, 0, 0, 239, 240, 1, 0,
		0, 0, 240, 241, 1, 0, 0, 0, 241, 248, 3, 6, 3, 0, 242, 244, 5, 4, 0, 0,
		243, 242, 1, 0, 0, 0, 243, 244, 1, 0, 0, 0, 244, 245, 1, 0, 0, 0, 245,
		247, 3, 6, 3, 0, 246, 243, 1, 0, 0, 0, 247, 250, 1, 0, 0, 0, 248, 246,
		1, 0, 0, 0, 248, 249, 1, 0, 0, 0, 249, 320, 1, 0, 0, 0, 250, 248, 1, 0,
		0, 0, 251, 252, 5, 47, 0, 0, 252, 253, 5, 17, 0, 0, 253, 254, 5, 181, 0,
		0, 254, 256, 5, 189, 0, 0, 255, 251, 1, 0, 0, 0, 255, 256, 1, 0, 0, 0,
		256, 321, 1, 0, 0, 0, 257, 258, 5, 60, 0, 0, 258, 263, 3, 178, 89, 0, 259,
		260, 5, 4, 0, 0, 260, 262, 3, 178, 89, 0, 261, 259, 1, 0, 0, 0, 262, 265,
		1, 0, 0, 0, 263, 261, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 271, 1, 0,
		0, 0, 265, 263, 1, 0, 0, 0, 266, 267, 5, 19, 0, 0, 267, 269, 3, 24, 12,
		0, 268, 270, 3, 10, 5, 0, 269, 268, 1, 0, 0, 0, 269, 270, 1, 0, 0, 0, 270,
		272, 1, 0, 0, 0, 271, 266, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272, 274,
		1, 0, 0, 0, 273, 275, 3, 12, 6, 0, 274, 273, 1, 0, 0, 0, 274, 275, 1, 0,
		0, 0, 275, 277, 1, 0, 0, 0, 276, 278, 3, 8, 4, 0, 277, 276, 1, 0, 0, 0,
		277, 278, 1, 0, 0, 0, 278, 289, 1, 0, 0, 0, 279, 280, 5, 48, 0, 0, 280,
		281, 5, 47, 0, 0, 281, 286, 3, 70, 35, 0, 282, 283, 5, 4, 0, 0, 283, 285,
		3, 70, 35, 0, 284, 282, 1, 0, 0, 0, 285, 288, 1, 0, 0, 0, 286, 284, 1,
		0, 0, 0, 286, 287, 1, 0, 0, 0, 287, 290, 1, 0, 0, 0, 288, 286, 1, 0, 0,
		0, 289, 279, 1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290, 293, 1, 0, 0, 0, 291,
		292, 5, 31, 0, 0, 292, 294, 5, 187, 0, 0, 293, 291, 1, 0, 0, 0, 293, 294,
		1, 0, 0, 0, 294, 304, 1, 0, 0, 0, 295, 298, 5, 30, 0, 0, 296, 297, 5, 187,
		0, 0, 297, 299, 5, 4, 0, 0, 298, 296, 1, 0, 0, 0, 298, 299, 1, 0, 0, 0,
		299, 300, 1, 0, 0, 0, 300, 302, 5, 187, 0, 0, 301, 303, 3, 14, 7, 0, 302,
		301, 1, 0, 0, 0, 302, 303, 1, 0, 0, 0, 303, 305, 1, 0, 0, 0, 304, 295,
		1, 0, 0, 0, 304, 305, 1, 0, 0, 0, 305, 316, 1, 0, 0, 0, 306, 314, 5, 69,
		0, 0, 307, 308, 5, 5, 0, 0, 308, 311, 5, 187, 0, 0, 309, 310, 5, 4, 0,
		0, 310, 312, 3, 176, 88, 0, 311, 309, 1, 0, 0, 0, 311, 312, 1, 0, 0, 0,
		312, 313, 1, 0, 0, 0, 313, 315, 5, 6, 0, 0, 314, 307, 1, 0, 0, 0, 314,
		315, 1, 0, 0, 0, 315, 317, 1, 0, 0, 0, 316, 306, 1, 0, 0, 0, 316, 317,
		1, 0, 0, 0, 317, 319, 1, 0, 0, 0, 318, 257, 1, 0, 0, 0, 318, 319, 1, 0,
		0, 0, 319, 321, 1, 0, 0, 0, 320, 255, 1, 0, 0, 0, 320, 318, 1, 0, 0, 0,
		321, 324, 1, 0, 0, 0, 322, 323, 5, 44, 0, 0, 323, 325, 3, 182, 91, 0, 324,
		322, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325, 327, 1, 0, 0, 0, 326, 328,
		3, 72, 36, 0, 327, 326, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0, 328, 5, 1, 0,
		0, 0, 329, 334, 3, 176, 88, 0, 330, 334, 3, 20, 10, 0, 331, 334, 3, 18,
		9, 0, 332, 334, 3, 16, 8, 0, 333, 329, 1, 0, 0, 0, 333, 330, 1, 0, 0, 0,
		333, 331, 1, 0, 0, 0, 333, 332, 1, 0, 0, 0, 334, 7, 1, 0, 0, 0, 335, 336,
		5, 23, 0, 0, 336, 337, 5, 47, 0, 0, 337, 338, 3, 176, 88, 0, 338, 9, 1,
		0, 0, 0, 339, 340, 5, 20, 0, 0, 340, 341, 3, 90, 45, 0, 341, 11, 1, 0,
		0, 0, 342, 346, 5, 21, 0, 0, 343, 344, 5, 22, 0, 0, 344, 345, 5, 181, 0,
		0, 345, 347, 5, 187, 0, 0, 346, 343, 1, 0, 0, 0, 346, 347, 1, 0, 0, 0,
		347, 354, 1, 0, 0, 0, 348, 349, 5, 27, 0, 0, 349, 350, 5, 5, 0, 0, 350,
		351, 5, 188, 0, 0, 351, 352, 5, 4, 0, 0, 352, 353, 5, 188, 0, 0, 353, 355,
		5, 6, 0, 0, 354, 348, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355, 356, 1, 0,
		0, 0, 356, 357, 3, 24, 12, 0, 357, 13, 1, 0, 0, 0, 358, 359, 5, 25, 0,
		0, 359, 360, 5, 47, 0, 0, 360, 365, 3, 70, 35, 0, 361, 362, 5, 4, 0, 0,
		362, 364, 3, 70, 35, 0, 363, 361, 1, 0, 0, 0, 364, 367, 1, 0, 0, 0, 365,
		363, 1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366, 370, 1, 0, 0, 0, 367, 365,
		1, 0, 0, 0, 368, 369, 5, 26, 0, 0, 369, 371, 5, 187, 0, 0, 370, 368, 1,
		0, 0, 0, 370, 371, 1, 0, 0, 0, 371, 15, 1, 0, 0, 0, 372, 373, 5, 18, 0,
		0, 373, 374, 5, 5, 0, 0, 374, 379, 3, 62, 31, 0, 375, 376, 5, 4, 0, 0,
		376, 378, 3, 62, 31, 0, 377, 375, 1, 0, 0, 0, 378, 381, 1, 0, 0, 0, 379,
		377, 1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380, 382, 1, 0, 0, 0, 381, 379,
		1, 0, 0, 0, 382, 383, 5, 6, 0, 0, 383, 384, 5, 43, 0, 0, 384, 385, 3, 182,
		91, 0, 385, 17, 1, 0, 0, 0, 386, 387, 3, 90, 45, 0, 387, 388, 5, 43, 0,
		0, 388, 389, 3, 182, 91, 0, 389, 19, 1, 0, 0, 0, 390, 391, 5, 16, 0, 0,
		391, 392, 5, 5, 0, 0, 392, 397, 3, 22, 11, 0, 393, 394, 5, 4, 0, 0, 394,
		396, 3, 22, 11, 0, 395, 393, 1, 0, 0, 0, 396, 399, 1, 0, 0, 0, 397, 395,
		1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 400, 1, 0, 0, 0, 399, 397, 1, 0,
		0, 0, 400, 403, 5, 6, 0, 0, 401, 402, 5, 47, 0, 0, 402, 404, 5, 189, 0,
		0, 403, 401, 1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404, 21, 1, 0, 0, 0, 405,
		410, 3, 176, 88, 0, 406, 408, 5, 43, 0, 0, 407, 406, 1, 0, 0, 0, 407, 408,
		1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 411, 3, 182, 91, 0, 410, 407, 1,
		0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 414, 1, 0, 0, 0, 412, 413, 5, 47, 0,
		0, 413, 415, 5, 189, 0, 0, 414, 412, 1, 0, 0, 0, 414, 415, 1, 0, 0, 0,
		415, 23, 1, 0, 0, 0, 416, 418, 5, 2, 0, 0, 417, 419, 5, 28, 0, 0, 418,
		417, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 420, 1, 0, 0, 0, 420, 421,
		5, 24, 0, 0, 421, 422, 5, 181, 0, 0, 422, 423, 3, 188, 94, 0, 423, 424,
		1, 0, 0, 0, 424, 425, 5, 3, 0, 0, 425, 427, 1, 0, 0, 0, 426, 416, 1, 0,
		0, 0, 426, 427, 1, 0, 0, 0, 427, 432, 1, 0, 0, 0, 428, 430, 5, 55, 0, 0,
		429, 431, 5, 56, 0, 0, 430, 429, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431,
		433, 1, 0, 0, 0, 432, 428, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 435,
		1, 0, 0, 0, 434, 436, 3, 26, 13, 0, 435, 434, 1, 0, 0, 0, 435, 436, 1,
		0, 0, 0, 436, 25, 1, 0, 0, 0, 437, 438, 6, 13, -1, 0, 438, 447, 3, 28,
		14, 0, 439, 441, 5, 57, 0, 0, 440, 439, 1, 0, 0, 0, 440, 441, 1, 0, 0,
		0, 441, 442, 1, 0, 0, 0, 442, 443, 5, 5, 0, 0, 443, 444, 3, 26, 13, 0,
		444, 445, 5, 6, 0, 0, 445, 447, 1, 0, 0, 0, 446, 437, 1, 0, 0, 0, 446,
		440, 1, 0, 0, 0, 447, 456, 1, 0, 0, 0, 448, 449, 10, 2, 0, 0, 449, 450,
		5, 56, 0, 0, 450, 455, 3, 26, 13, 3, 451, 452, 10, 1, 0, 0, 452, 453, 5,
		54, 0, 0, 453, 455, 3, 26, 13, 2, 454, 448, 1, 0, 0, 0, 454, 451, 1, 0,
		0, 0, 455, 458, 1, 0, 0, 0, 456, 454, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0,
		457, 27, 1, 0, 0, 0, 458, 456, 1, 0, 0, 0, 459, 461, 5, 57, 0, 0, 460,
		459, 1, 0, 0, 0, 460, 461, 1, 0, 0, 0, 461, 466, 1, 0, 0, 0, 462, 467,
		3, 30, 15, 0, 463, 467, 3, 32, 16, 0, 464, 467, 3, 46, 23, 0, 465, 467,
		3, 34, 17, 0, 466, 462, 1, 0, 0, 0, 466, 463, 1, 0, 0, 0, 466, 464, 1,
		0, 0, 0, 466, 465, 1, 0, 0, 0, 467, 29, 1, 0, 0, 0, 468, 471, 3, 176, 88,
		0, 469, 470, 5, 179, 0, 0, 470, 472, 3, 186, 93, 0, 471, 469, 1, 0, 0,
		0, 471, 472, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 474, 3, 172, 86, 0,
		474, 475, 3, 64, 32, 0, 475, 31, 1, 0, 0, 0, 476, 478, 3, 176, 88, 0, 477,
		479, 5, 57, 0, 0, 478, 477, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 497,
		1, 0, 0, 0, 480, 481, 5, 53, 0, 0, 481, 482, 3, 64, 32, 0, 482, 483, 5,
		56, 0, 0, 483, 484, 3, 64, 32, 0, 484, 498, 1, 0, 0, 0, 485, 488, 5, 123,
		0, 0, 486, 489, 5, 7, 0, 0, 487, 489, 5, 5, 0, 0, 488, 486, 1, 0, 0, 0,
		488, 487, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 491, 3, 64, 32, 0, 491,
		492, 5, 4, 0, 0, 492, 495, 3, 64, 32, 0, 493, 496, 5, 8, 0, 0, 494, 496,
		5, 6, 0, 0, 495, 493, 1, 0, 0, 0, 495, 494, 1, 0, 0, 0, 496, 498, 1, 0,
		0, 0, 497, 480, 1, 0, 0, 0, 497, 485, 1, 0, 0, 0, 498, 33, 1, 0, 0, 0,
		499, 500, 3, 36, 18, 0, 500, 501, 3, 172, 86, 0, 501, 502, 3, 40, 20, 0,
		502, 35, 1, 0, 0, 0, 503, 507, 3, 40, 20, 0, 504, 506, 3, 38, 19, 0, 505,
		504, 1, 0, 0, 0, 506, 509, 1, 0, 0, 0, 507, 505, 1, 0, 0, 0, 507, 508,
		1, 0, 0, 0, 508, 37, 1, 0, 0, 0, 509, 507, 1, 0, 0, 0, 510, 511, 7, 0,
		0, 0, 511, 512, 3, 40, 20, 0, 512, 39, 1, 0, 0, 0, 513, 517, 3, 44, 22,
		0, 514, 516, 3, 42, 21, 0, 515, 514, 1, 0, 0, 0, 516, 519, 1, 0, 0, 0,
		517, 515, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0, 518, 41, 1, 0, 0, 0, 519, 517,
		1, 0, 0, 0, 520, 521, 7, 1, 0, 0, 521, 522, 3, 44, 22, 0, 522, 43, 1, 0,
		0, 0, 523, 535, 3, 176, 88, 0, 524, 525, 5, 160, 0, 0, 525, 526, 5, 5,
		0, 0, 526, 527, 3, 176, 88, 0, 527, 528, 5, 6, 0, 0, 528, 535, 1, 0, 0,
		0, 529, 535, 3, 64, 32, 0, 530, 531, 5, 5, 0, 0, 531, 532, 3, 36, 18, 0,
		532, 533, 5, 6, 0, 0, 533, 535, 1, 0, 0, 0, 534, 523, 1, 0, 0, 0, 534,
		524, 1, 0, 0, 0, 534, 529, 1, 0, 0, 0, 534, 530, 1, 0, 0, 0, 535, 45, 1,
		0, 0, 0, 536, 541, 3, 58, 29, 0, 537, 541, 3, 54, 27, 0, 538, 541, 3, 52,
		26, 0, 539, 541, 3, 48, 24, 0, 540, 536, 1, 0, 0, 0, 540, 537, 1, 0, 0,
		0, 540, 538, 1, 0, 0, 0, 540, 539, 1, 0, 0, 0, 541, 47, 1, 0, 0, 0, 542,
		543, 3, 50, 25, 0, 543, 544, 5, 5, 0, 0, 544, 547, 3, 182, 91, 0, 545,
		546, 5, 79, 0, 0, 546, 548, 3, 24, 12, 0, 547, 545, 1, 0, 0, 0, 547, 548,
		1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 550, 5, 6, 0, 0, 550, 49, 1, 0,
		0, 0, 551, 552, 7, 2, 0, 0, 552, 51, 1, 0, 0, 0, 553, 554, 3, 90, 45, 0,
		554, 53, 1, 0, 0, 0, 555, 556, 3, 56, 28, 0, 556, 557, 5, 5, 0, 0, 557,
		562, 3, 62, 31, 0, 558, 559, 5, 4, 0, 0, 559, 561, 3, 62, 31, 0, 560, 558,
		1, 0, 0, 0, 561, 564, 1, 0, 0, 0, 562, 560, 1, 0, 0, 0, 562, 563, 1, 0,
		0, 0, 563, 565, 1, 0, 0, 0, 564, 562, 1, 0, 0, 0, 565, 566, 5, 6, 0, 0,
		566, 55, 1, 0, 0, 0, 567, 568, 7, 3, 0, 0, 568, 57, 1, 0, 0, 0, 569, 572,
		3, 176, 88, 0, 570, 571, 5, 179, 0, 0, 571, 573, 3, 186, 93, 0, 572, 570,
		1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 575, 1, 0, 0, 0, 574, 569, 1, 0,
		0, 0, 574, 575, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 577, 3, 60, 30,
		0, 577, 578, 5, 5, 0, 0, 578, 583, 3, 66, 33, 0, 579, 580, 5, 4, 0, 0,
		580, 582, 3, 66, 33, 0, 581, 579, 1, 0, 0, 0, 582, 585, 1, 0, 0, 0, 583,
		581, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0, 584, 586, 1, 0, 0, 0, 585, 583,
		1, 0, 0, 0, 586, 587, 5, 6, 0, 0, 587, 617, 1, 0, 0, 0, 588, 589, 3, 60,
		30, 0, 589, 590, 5, 5, 0, 0, 590, 593, 3, 176, 88, 0, 591, 592, 5, 179,
		0, 0, 592, 594, 3, 186, 93, 0, 593, 591, 1, 0, 0, 0, 593, 594, 1, 0, 0,
		0, 594, 599, 1, 0, 0, 0, 595, 596, 5, 4, 0, 0, 596, 598, 3, 66, 33, 0,
		597, 595, 1, 0, 0, 0, 598, 601, 1, 0, 0, 0, 599, 597, 1, 0, 0, 0, 599,
		600, 1, 0, 0, 0, 600, 602, 1, 0, 0, 0, 601, 599, 1, 0, 0, 0, 602, 603,
		5, 6, 0, 0, 603, 617, 1, 0, 0, 0, 604, 607, 3, 176, 88, 0, 605, 606, 5,
		179, 0, 0, 606, 608, 3, 186, 93, 0, 607, 605, 1, 0, 0, 0, 607, 608, 1,
		0, 0, 0, 608, 610, 1, 0, 0, 0, 609, 604, 1, 0, 0, 0, 609, 610, 1, 0, 0,
		0, 610, 611, 1, 0, 0, 0, 611, 612, 3, 60, 30, 0, 612, 613, 5, 5, 0, 0,
		613, 614, 3, 176, 88, 0, 614, 615, 5, 6, 0, 0, 615, 617, 1, 0, 0, 0, 616,
		574, 1, 0, 0, 0, 616, 588, 1, 0, 0, 0, 616, 609, 1, 0, 0, 0, 617, 59, 1,
		0, 0, 0, 618, 619, 7, 4, 0, 0, 619, 61, 1, 0, 0, 0, 620, 621, 3, 182, 91,
		0, 621, 622, 5, 181, 0, 0, 622, 623, 3, 64, 32, 0, 623, 63, 1, 0, 0, 0,
		624, 631, 3, 68, 34, 0, 625, 631, 3, 188, 94, 0, 626, 631, 5, 187, 0, 0,
		627, 631, 5, 188, 0, 0, 628, 631, 3, 184, 92, 0, 629, 631, 5, 176, 0, 0,
		630, 624, 1, 0, 0, 0, 630, 625, 1, 0, 0, 0, 630, 626, 1, 0, 0, 0, 630,
		627, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 630, 629, 1, 0, 0, 0, 631, 65, 1,
		0, 0, 0, 632, 639, 3, 68, 34, 0, 633, 639, 3, 188, 94, 0, 634, 639, 5,
		187, 0, 0, 635, 639, 5, 188, 0, 0, 636, 639, 5, 189, 0, 0, 637, 639, 5,
		176, 0, 0, 638, 632, 1, 0, 0, 0, 638, 633, 1, 0, 0, 0, 638, 634, 1, 0,
		0, 0, 638, 635, 1, 0, 0, 0, 638, 636, 1, 0, 0, 0, 638, 637, 1, 0, 0, 0,
		639, 67, 1, 0, 0, 0, 640, 641, 5, 148, 0, 0, 641, 642, 3, 138, 69, 0, 642,
		69, 1, 0, 0, 0, 643, 649, 3, 176, 88, 0, 644, 646, 7, 5, 0, 0, 645, 644,
		1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 649, 3, 90,
		45, 0, 648, 643, 1, 0, 0, 0, 648, 645, 1, 0, 0, 0, 649, 654, 1, 0, 0, 0,
		650, 651, 5, 5, 0, 0, 651, 652, 3, 24, 12, 0, 652, 653, 5, 6, 0, 0, 653,
		655, 1, 0, 0, 0, 654, 650, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 657,
		1, 0, 0, 0, 656, 658, 7, 6, 0, 0, 657, 656, 1, 0, 0, 0, 657, 658, 1, 0,
		0, 0, 658, 660, 1, 0, 0, 0, 659, 661, 7, 7, 0, 0, 660, 659, 1, 0, 0, 0,
		660, 661, 1, 0, 0, 0, 661, 71, 1, 0, 0, 0, 662, 664, 5, 70, 0, 0, 663,
		665, 5, 114, 0, 0, 664, 663, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 677,
		1, 0, 0, 0, 666, 667, 5, 5, 0, 0, 667, 672, 3, 74, 37, 0, 668, 669, 5,
		4, 0, 0, 669, 671, 3, 74, 37, 0, 670, 668, 1, 0, 0, 0, 671, 674, 1, 0,
		0, 0, 672, 670, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673, 675, 1, 0, 0, 0,
		674, 672, 1, 0, 0, 0, 675, 676, 5, 6, 0, 0, 676, 678, 1, 0, 0, 0, 677,
		666, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 693, 1, 0, 0, 0, 679, 691,
		5, 71, 0, 0, 680, 681, 5, 5, 0, 0, 681, 686, 3, 184, 92, 0, 682, 683, 5,
		4, 0, 0, 683, 685, 3, 184, 92, 0, 684, 682, 1, 0, 0, 0, 685, 688, 1, 0,
		0, 0, 686, 684, 1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687, 689, 1, 0, 0, 0,
		688, 686, 1, 0, 0, 0, 689, 690, 5, 6, 0, 0, 690, 692, 1, 0, 0, 0, 691,
		680, 1, 0, 0, 0, 691, 692, 1, 0, 0, 0, 692, 694, 1, 0, 0, 0, 693, 679,
		1, 0, 0, 0, 693, 694, 1, 0, 0, 0, 694, 701, 1, 0, 0, 0, 695, 699, 7, 8,
		0, 0, 696, 697, 5, 75, 0, 0, 697, 698, 5, 181, 0, 0, 698, 700, 5, 189,
		0, 0, 699, 696, 1, 0, 0, 0, 699, 700, 1, 0, 0, 0, 700, 702, 1, 0, 0, 0,
		701, 695, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703,
		704, 3, 184, 92, 0, 704, 73, 1, 0, 0, 0, 705, 708, 3, 176, 88, 0, 706,
		708, 3, 82, 41, 0, 707, 705, 1, 0, 0, 0, 707, 706, 1, 0, 0, 0, 708, 75,
		1, 0, 0, 0, 709, 710, 5, 45, 0, 0, 710, 712, 3, 182, 91, 0, 711, 709, 1,
		0, 0, 0, 711, 712, 1, 0, 0, 0, 712, 713, 1, 0, 0, 0, 713, 718, 3, 78, 39,
		0, 714, 715, 5, 9, 0, 0, 715, 717, 3, 78, 39, 0, 716, 714, 1, 0, 0, 0,
		717, 720, 1, 0, 0, 0, 718, 716, 1, 0, 0, 0, 718, 719, 1, 0, 0, 0, 719,
		77, 1, 0, 0, 0, 720, 718, 1, 0, 0, 0, 721, 723, 5, 19, 0, 0, 722, 724,
		5, 108, 0, 0, 723, 722, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 725, 1,
		0, 0, 0, 725, 727, 3, 24, 12, 0, 726, 721, 1, 0, 0, 0, 726, 727, 1, 0,
		0, 0, 727, 728, 1, 0, 0, 0, 728, 733, 3, 80, 40, 0, 729, 730, 5, 4, 0,
		0, 730, 732, 3, 80, 40, 0, 731, 729, 1, 0, 0, 0, 732, 735, 1, 0, 0, 0,
		733, 731, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734, 739, 1, 0, 0, 0, 735,
		733, 1, 0, 0, 0, 736, 737, 5, 46, 0, 0, 737, 738, 5, 47, 0, 0, 738, 740,
		3, 92, 46, 0, 739, 736, 1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 742, 1,
		0, 0, 0, 741, 743, 3, 100, 50, 0, 742, 741, 1, 0, 0, 0, 742, 743, 1, 0,
		0, 0, 743, 746, 1, 0, 0, 0, 744, 745, 5, 30, 0, 0, 745, 747, 5, 187, 0,
		0, 746, 744, 1, 0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 750, 1, 0, 0, 0, 748,
		749, 5, 44, 0, 0, 749, 751, 3, 182, 91, 0, 750, 748, 1, 0, 0, 0, 750, 751,
		1, 0, 0, 0, 751, 753, 1, 0, 0, 0, 752, 754, 3, 72, 36, 0, 753, 752, 1,
		0, 0, 0, 753, 754, 1, 0, 0, 0, 754, 79, 1, 0, 0, 0, 755, 756, 5, 42, 0,
		0, 756, 758, 3, 24, 12, 0, 757, 755, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0,
		758, 777, 1, 0, 0, 0, 759, 760, 3, 82, 41, 0, 760, 761, 5, 5, 0, 0, 761,
		762, 5, 6, 0, 0, 762, 778, 1, 0, 0, 0, 763, 764, 3, 82, 41, 0, 764, 765,
		5, 5, 0, 0, 765, 768, 3, 176, 88, 0, 766, 767, 5, 4, 0, 0, 767, 769, 3,
		84, 42, 0, 768, 766, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 770, 1, 0,
		0, 0, 770, 771, 5, 6, 0, 0, 771, 778, 1, 0, 0, 0, 772, 773, 3, 82, 41,
		0, 773, 774, 5, 5, 0, 0, 774, 775, 3, 84, 42, 0, 775, 776, 5, 6, 0, 0,
		776, 778, 1, 0, 0, 0, 777, 759, 1, 0, 0, 0, 777, 763, 1, 0, 0, 0, 777,
		772, 1, 0, 0, 0, 778, 783, 1, 0, 0, 0, 779, 781, 5, 43, 0, 0, 780, 779,
		1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781, 782, 1, 0, 0, 0, 782, 784, 3, 74,
		37, 0, 783, 780, 1, 0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 81, 1, 0, 0, 0,
		785, 786, 7, 9, 0, 0, 786, 83, 1, 0, 0, 0, 787, 792, 3, 86, 43, 0, 788,
		789, 5, 4, 0, 0, 789, 791, 3, 86, 43, 0, 790, 788, 1, 0, 0, 0, 791, 794,
		1, 0, 0, 0, 792, 790, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0, 793, 797, 1, 0,
		0, 0, 794, 792, 1, 0, 0, 0, 795, 796, 5, 4, 0, 0, 796, 798, 3, 90, 45,
		0, 797, 795, 1, 0, 0, 0, 797, 798, 1, 0, 0, 0, 798, 801, 1, 0, 0, 0, 799,
		801, 3, 90, 45, 0, 800, 787, 1, 0, 0, 0, 800, 799, 1, 0, 0, 0, 801, 85,
		1, 0, 0, 0, 802, 803, 3, 88, 44, 0, 803, 804, 5, 181, 0, 0, 804, 805, 3,
		64, 32, 0, 805, 87, 1, 0, 0, 0, 806, 807, 7, 10, 0, 0, 807, 89, 1, 0, 0,
		0, 808, 816, 5, 76, 0, 0, 809, 810, 5, 2, 0, 0, 810, 811, 5, 77, 0, 0,
		811, 812, 5, 181, 0, 0, 812, 813, 3, 184, 92, 0, 813, 814, 1, 0, 0, 0,
		814, 815, 5, 3, 0, 0, 815, 817, 1, 0, 0, 0, 816, 809, 1, 0, 0, 0, 816,
		817, 1, 0, 0, 0, 817, 818, 1, 0, 0, 0, 818, 819, 5, 5, 0, 0, 819, 824,
		5, 189, 0, 0, 820, 821, 5, 4, 0, 0, 821, 823, 3, 62, 31, 0, 822, 820, 1,
		0, 0, 0, 823, 826, 1, 0, 0, 0, 824, 822, 1, 0, 0, 0, 824, 825, 1, 0, 0,
		0, 825, 827, 1, 0, 0, 0, 826, 824, 1, 0, 0, 0, 827, 833, 5, 6, 0, 0, 828,
		830, 5, 122, 0, 0, 829, 828, 1, 0, 0, 0, 829, 830, 1, 0, 0, 0, 830, 831,
		1, 0, 0, 0, 831, 833, 3, 36, 18, 0, 832, 808, 1, 0, 0, 0, 832, 829, 1,
		0, 0, 0, 833, 91, 1, 0, 0, 0, 834, 847, 3, 94, 47, 0, 835, 836, 5, 5, 0,
		0, 836, 841, 3, 94, 47, 0, 837, 838, 5, 4, 0, 0, 838, 840, 3, 94, 47, 0,
		839, 837, 1, 0, 0, 0, 840, 843, 1, 0, 0, 0, 841, 839, 1, 0, 0, 0, 841,
		842, 1, 0, 0, 0, 842, 844, 1, 0, 0, 0, 843, 841, 1, 0, 0, 0, 844, 845,
		5, 6, 0, 0, 845, 847, 1, 0, 0, 0, 846, 834, 1, 0, 0, 0, 846, 835, 1, 0,
		0, 0, 847, 93, 1, 0, 0, 0, 848, 853, 3, 96, 48, 0, 849, 851, 5, 43, 0,
		0, 850, 849, 1, 0, 0, 0, 850, 851, 1, 0, 0, 0, 851, 852, 1, 0, 0, 0, 852,
		854, 3, 74, 37, 0, 853, 850, 1, 0, 0, 0, 853, 854, 1, 0, 0, 0, 854, 95,
		1, 0, 0, 0, 855, 863, 3, 98, 49, 0, 856, 863, 3, 102, 51, 0, 857, 863,
		3, 110, 55, 0, 858, 863, 3, 118, 59, 0, 859, 863, 3, 120, 60, 0, 860, 863,
		3, 124, 62, 0, 861, 863, 3, 122, 61, 0, 862, 855, 1, 0, 0, 0, 862, 856,
		1, 0, 0, 0, 862, 857, 1, 0, 0, 0, 862, 858, 1, 0, 0, 0, 862, 859, 1, 0,
		0, 0, 862, 860, 1, 0, 0, 0, 862, 861, 1, 0, 0, 0, 863, 97, 1, 0, 0, 0,
		864, 866, 3, 176, 88, 0, 865, 864, 1, 0, 0, 0, 865, 866, 1, 0, 0, 0, 866,
		908, 1, 0, 0, 0, 867, 868, 5, 63, 0, 0, 868, 869, 5, 5, 0, 0, 869, 874,
		3, 64, 32, 0, 870, 871, 5, 4, 0, 0, 871, 873, 3, 64, 32, 0, 872, 870, 1,
		0, 0, 0, 873, 876, 1, 0, 0, 0, 874, 872, 1, 0, 0, 0, 874, 875, 1, 0, 0,
		0, 875, 877, 1, 0, 0, 0, 876, 874, 1, 0, 0, 0, 877, 878, 5, 6, 0, 0, 878,
		907, 1, 0, 0, 0, 879, 880, 5, 62, 0, 0, 880, 881, 5, 5, 0, 0, 881, 886,
		3, 64, 32, 0, 882, 883, 5, 4, 0, 0, 883, 885, 3, 64, 32, 0, 884, 882, 1,
		0, 0, 0, 885, 888, 1, 0, 0, 0, 886, 884, 1, 0, 0, 0, 886, 887, 1, 0, 0,
		0, 887, 889, 1, 0, 0, 0, 888, 886, 1, 0, 0, 0, 889, 890, 5, 6, 0, 0, 890,
		907, 1, 0, 0, 0, 891, 892, 5, 64, 0, 0, 892, 907, 5, 187, 0, 0, 893, 894,
		5, 131, 0, 0, 894, 895, 5, 43, 0, 0, 895, 907, 3, 64, 32, 0, 896, 907,
		3, 90, 45, 0, 897, 898, 5, 65, 0, 0, 898, 907, 5, 187, 0, 0, 899, 900,
		5, 48, 0, 0, 900, 901, 5, 47, 0, 0, 901, 904, 3, 174, 87, 0, 902, 905,
		5, 49, 0, 0, 903, 905, 5, 50, 0, 0, 904, 902, 1, 0, 0, 0, 904, 903, 1,
		0, 0, 0, 904, 905, 1, 0, 0, 0, 905, 907, 1, 0, 0, 0, 906, 867, 1, 0, 0,
		0, 906, 879, 1, 0, 0, 0, 906, 891, 1, 0, 0, 0, 906, 893, 1, 0, 0, 0, 906,
		896, 1, 0, 0, 0, 906, 897, 1, 0, 0, 0, 906, 899, 1, 0, 0, 0, 907, 910,
		1, 0, 0, 0, 908, 906, 1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 99, 1, 0,
		0, 0, 910, 908, 1, 0, 0, 0, 911, 912, 5, 61, 0, 0, 912, 913, 5, 5, 0, 0,
		913, 914, 3, 174, 87, 0, 914, 915, 5, 4, 0, 0, 915, 916, 3, 184, 92, 0,
		916, 917, 5, 6, 0, 0, 917, 101, 1, 0, 0, 0, 918, 919, 5, 123, 0, 0, 919,
		920, 5, 5, 0, 0, 920, 927, 3, 176, 88, 0, 921, 924, 5, 4, 0, 0, 922, 923,
		5, 131, 0, 0, 923, 925, 5, 181, 0, 0, 924, 922, 1, 0, 0, 0, 924, 925, 1,
		0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 928, 3, 64, 32, 0, 927, 921, 1, 0,
		0, 0, 927, 928, 1, 0, 0, 0, 928, 929, 1, 0, 0, 0, 929, 930, 5, 4, 0, 0,
		930, 931, 3, 104, 52, 0, 931, 932, 5, 6, 0, 0, 932, 103, 1, 0, 0, 0, 933,
		938, 3, 106, 53, 0, 934, 935, 5, 4, 0, 0, 935, 937, 3, 106, 53, 0, 936,
		934, 1, 0, 0, 0, 937, 940, 1, 0, 0, 0, 938, 936, 1, 0, 0, 0, 938, 939,
		1, 0, 0, 0, 939, 105, 1, 0, 0, 0, 940, 938, 1, 0, 0, 0, 941, 942, 5, 7,
		0, 0, 942, 943, 3, 108, 54, 0, 943, 944, 5, 4, 0, 0, 944, 947, 3, 108,
		54, 0, 945, 946, 5, 4, 0, 0, 946, 948, 3, 184, 92, 0, 947, 945, 1, 0, 0,
		0, 947, 948, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 950, 5, 8, 0, 0, 950,
		107, 1, 0, 0, 0, 951, 954, 5, 175, 0, 0, 952, 954, 3, 186, 93, 0, 953,
		951, 1, 0, 0, 0, 953, 952, 1, 0, 0, 0, 954, 109, 1, 0, 0, 0, 955, 956,
		5, 124, 0, 0, 956, 957, 5, 5, 0, 0, 957, 964, 3, 176, 88, 0, 958, 961,
		5, 4, 0, 0, 959, 960, 5, 128, 0, 0, 960, 962, 5, 181, 0, 0, 961, 959, 1,
		0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 965, 3, 184,
		92, 0, 964, 958, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0, 965, 970, 1, 0, 0, 0,
		966, 967, 5, 4, 0, 0, 967, 968, 5, 131, 0, 0, 968, 969, 5, 181, 0, 0, 969,
		971, 3, 184, 92, 0, 970, 966, 1, 0, 0, 0, 970, 971, 1, 0, 0, 0, 971, 972,
		1, 0, 0, 0, 972, 973, 5, 4, 0, 0, 973, 974, 3, 112, 56, 0, 974, 975, 5,
		6, 0, 0, 975, 111, 1, 0, 0, 0, 976, 981, 3, 114, 57, 0, 977, 978, 5, 4,
		0, 0, 978, 980, 3, 114, 57, 0, 979, 977, 1, 0, 0, 0, 980, 983, 1, 0, 0,
		0, 981, 979, 1, 0, 0, 0, 981, 982, 1, 0, 0, 0, 982, 113, 1, 0, 0, 0, 983,
		981, 1, 0, 0, 0, 984, 985, 5, 7, 0, 0, 985, 986, 3, 116, 58, 0, 986, 987,
		5, 4, 0, 0, 987, 990, 3, 116, 58, 0, 988, 989, 5, 4, 0, 0, 989, 991, 3,
		184, 92, 0, 990, 988, 1, 0, 0, 0, 990, 991, 1, 0, 0, 0, 991, 992, 1, 0,
		0, 0, 992, 993, 5, 8, 0, 0, 993, 115, 1, 0, 0, 0, 994, 998, 5, 175, 0,
		0, 995, 998, 5, 187, 0, 0, 996, 998, 3, 184, 92, 0, 997, 994, 1, 0, 0,
		0, 997, 995, 1, 0, 0, 0, 997, 996, 1, 0, 0, 0, 998, 117, 1, 0, 0, 0, 999,
		1000, 5, 125, 0, 0, 1000, 1001, 5, 5, 0, 0, 1001, 1002, 3, 176, 88, 0,
		1002, 1005, 5, 4, 0, 0, 1003, 1004, 5, 127, 0, 0, 1004, 1006, 5, 181, 0,
		0, 1005, 1003, 1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1007, 1, 0, 0,
		0, 1007, 1012, 3, 64, 32, 0, 1008, 1009, 5, 4, 0, 0, 1009, 1010, 5, 131,
		0, 0, 1010, 1011, 5, 181, 0, 0, 1011, 1013, 3, 64, 32, 0, 1012, 1008, 1,
		0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 1018, 1, 0, 0, 0, 1014, 1015, 5,
		4, 0, 0, 1015, 1016, 5, 32, 0, 0, 1016, 1017, 5, 181, 0, 0, 1017, 1019,
		3, 64, 32, 0, 1018, 1014, 1, 0, 0, 0, 1018, 1019, 1, 0, 0, 0, 1019, 1027,
		1, 0, 0, 0, 1020, 1021, 5, 4, 0, 0, 1021, 1022, 5, 48, 0, 0, 1022, 1023,
		5, 181, 0, 0, 1023, 1025, 3, 174, 87, 0, 1024, 1026, 5, 49, 0, 0, 1025,
		1024, 1, 0, 0, 0, 1025, 1026, 1, 0, 0, 0, 1026, 1028, 1, 0, 0, 0, 1027,
		1020, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029,
		1030, 5, 6, 0, 0, 1030, 119, 1, 0, 0, 0, 1031, 1032, 5, 126, 0, 0, 1032,
		1033, 5, 5, 0, 0, 1033, 1034, 3, 176, 88, 0, 1034, 1037, 5, 4, 0, 0, 1035,
		1036, 5, 127, 0, 0, 1036, 1038, 5, 181, 0, 0, 1037, 1035, 1, 0, 0, 0, 1037,
		1038, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039, 1044, 3, 184, 92, 0, 1040,
		1041, 5, 4, 0, 0, 1041, 1042, 5, 128, 0, 0, 1042, 1043, 5, 181, 0, 0, 1043,
		1045, 3, 184, 92, 0, 1044, 1040, 1, 0, 0, 0, 1044, 1045, 1, 0, 0, 0, 1045,
		1050, 1, 0, 0, 0, 1046, 1047, 5, 4, 0, 0, 1047, 1048, 5, 131, 0, 0, 1048,
		1049, 5, 181, 0, 0, 1049, 1051, 3, 64, 32, 0, 1050, 1046, 1, 0, 0, 0, 1050,
		1051, 1, 0, 0, 0, 1051, 1056, 1, 0, 0, 0, 1052, 1053, 5, 4, 0, 0, 1053,
		1054, 5, 32, 0, 0, 1054, 1055, 5, 181, 0, 0, 1055, 1057, 3, 64, 32, 0,
		1056, 1052, 1, 0, 0, 0, 1056, 1057, 1, 0, 0, 0, 1057, 1065, 1, 0, 0, 0,
		1058, 1059, 5, 4, 0, 0, 1059, 1060, 5, 48, 0, 0, 1060, 1061, 5, 181, 0,
		0, 1061, 1063, 3, 174, 87, 0, 1062, 1064, 5, 49, 0, 0, 1063, 1062, 1, 0,
		0, 0, 1063, 1064, 1, 0, 0, 0, 1064, 1066, 1, 0, 0, 0, 1065, 1058, 1, 0,
		0, 0, 1065, 1066, 1, 0, 0, 0, 1066, 1067, 1, 0, 0, 0, 1067, 1068, 5, 6,
		0, 0, 1068, 121, 1, 0, 0, 0, 1069, 1070, 5, 137, 0, 0, 1070, 1071, 5, 5,
		0, 0, 1071, 1114, 3, 176, 88, 0, 1072, 1073, 5, 4, 0, 0, 1073, 1074, 5,
		136, 0, 0, 1074, 1075, 5, 181, 0, 0, 1075, 1113, 5, 187, 0, 0, 1076, 1077,
		5, 4, 0, 0, 1077, 1078, 5, 64, 0, 0, 1078, 1113, 5, 187, 0, 0, 1079, 1080,
		5, 4, 0, 0, 1080, 1081, 5, 24, 0, 0, 1081, 1082, 5, 181, 0, 0, 1082, 1113,
		3, 184, 92, 0, 1083, 1084, 5, 4, 0, 0, 1084, 1085, 5, 62, 0, 0, 1085, 1086,
		5, 5, 0, 0, 1086, 1091, 3, 64, 32, 0, 1087, 1088, 5, 4, 0, 0, 1088, 1090,
		3, 64, 32, 0, 1089, 1087, 1, 0, 0, 0, 1090, 1093, 1, 0, 0, 0, 1091, 1089,
		1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 1094, 1, 0, 0, 0, 1093, 1091,
		1, 0, 0, 0, 1094, 1095, 5, 6, 0, 0, 1095, 1113, 1, 0, 0, 0, 1096, 1097,
		5, 4, 0, 0, 1097, 1098, 5, 63, 0, 0, 1098, 1099, 5, 5, 0, 0, 1099, 1104,
		3, 64, 32, 0, 1100, 1101, 5, 4, 0, 0, 1101, 1103, 3, 64, 32, 0, 1102, 1100,
		1, 0, 0, 0, 1103, 1106, 1, 0, 0, 0, 1104, 1102, 1, 0, 0, 0, 1104, 1105,
		1, 0, 0, 0, 1105, 1107, 1, 0, 0, 0, 1106, 1104, 1, 0, 0, 0, 1107, 1108,
		5, 6, 0, 0, 1108, 1113, 1, 0, 0, 0, 1109, 1110, 5, 4, 0, 0, 1110, 1111,
		5, 65, 0, 0, 1111, 1113, 5, 187, 0, 0, 1112, 1072, 1, 0, 0, 0, 1112, 1076,
		1, 0, 0, 0, 1112, 1079, 1, 0, 0, 0, 1112, 1083, 1, 0, 0, 0, 1112, 1096,
		1, 0, 0, 0, 1112, 1109, 1, 0, 0, 0, 1113, 1116, 1, 0, 0, 0, 1114, 1112,
		1, 0, 0, 0, 1114, 1115, 1, 0, 0, 0, 1115, 1117, 1, 0, 0, 0, 1116, 1114,
		1, 0, 0, 0, 1117, 1118, 5, 6, 0, 0, 1118, 123, 1, 0, 0, 0, 1119, 1125,
		3, 176, 88, 0, 1120, 1121, 5, 133, 0, 0, 1121, 1122, 3, 24, 12, 0, 1122,
		1123, 5, 135, 0, 0, 1123, 1124, 3, 184, 92, 0, 1124, 1126, 1, 0, 0, 0,
		1125, 1120, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0,
		1127, 1128, 1, 0, 0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 1130, 5, 134, 0,
		0, 1130, 125, 1, 0, 0, 0, 1131, 1143, 5, 33, 0, 0, 1132, 1133, 5, 2, 0,
		0, 1133, 1138, 3, 128, 64, 0, 1134, 1135, 5, 4, 0, 0, 1135, 1137, 3, 128,
		64, 0, 1136, 1134, 1, 0, 0, 0, 1137, 1140, 1, 0, 0, 0, 1138, 1136, 1, 0,
		0, 0, 1138, 1139, 1, 0, 0, 0, 1139, 1141, 1, 0, 0, 0, 1140, 1138, 1, 0,
		0, 0, 1141, 1142, 5, 3, 0, 0, 1142, 1144, 1, 0, 0, 0, 1143, 1132, 1, 0,
		0, 0, 1143, 1144, 1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145, 1148, 5, 189,
		0, 0, 1146, 1147, 5, 30, 0, 0, 1147, 1149, 5, 187, 0, 0, 1148, 1146, 1,
		0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1152, 1, 0, 0, 0, 1150, 1151, 5,
		44, 0, 0, 1151, 1153, 3, 182, 91, 0, 1152, 1150, 1, 0, 0, 0, 1152, 1153,
		1, 0, 0, 0, 1153, 1155, 1, 0, 0, 0, 1154, 1156, 3, 72, 36, 0, 1155, 1154,
		1, 0, 0, 0, 1155, 1156, 1, 0, 0, 0, 1156, 127, 1, 0, 0, 0, 1157, 1158,
		5, 34, 0, 0, 1158, 1159, 5, 5, 0, 0, 1159, 1160, 3, 182, 91, 0, 1160, 1161,
		5, 4, 0, 0, 1161, 1166, 3, 74, 37, 0, 1162, 1163, 5, 4, 0, 0, 1163, 1165,
		3, 74, 37, 0, 1164, 1162, 1, 0, 0, 0, 1165, 1168, 1, 0, 0, 0, 1166, 1164,
		1, 0, 0, 0, 1166, 1167, 1, 0, 0, 0, 1167, 1169, 1, 0, 0, 0, 1168, 1166,
		1, 0, 0, 0, 1169, 1170, 5, 6, 0, 0, 1170, 129, 1, 0, 0, 0, 1171, 1172,
		5, 14, 0, 0, 1172, 1177, 3, 176, 88, 0, 1173, 1174, 5, 4, 0, 0, 1174, 1176,
		3, 176, 88, 0, 1175, 1173, 1, 0, 0, 0, 1176, 1179, 1, 0, 0, 0, 1177, 1175,
		1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 1189, 1, 0, 0, 0, 1179, 1177,
		1, 0, 0, 0, 1180, 1181, 5, 4, 0, 0, 1181, 1182, 5, 121, 0, 0, 1182, 1183,
		5, 5, 0, 0, 1183, 1184, 3, 36, 18, 0, 1184, 1187, 5, 6, 0, 0, 1185, 1186,
		5, 43, 0, 0, 1186, 1188, 3, 182, 91, 0, 1187, 1185, 1, 0, 0, 0, 1187, 1188,
		1, 0, 0, 0, 1188, 1190, 1, 0, 0, 0, 1189, 1180, 1, 0, 0, 0, 1189, 1190,
		1, 0, 0, 0, 1190, 1191, 1, 0, 0, 0, 1191, 1192, 5, 60, 0, 0, 1192, 1197,
		3, 178, 89, 0, 1193, 1194, 5, 4, 0, 0, 1194, 1196, 3, 178, 89, 0, 1195,
		1193, 1, 0, 0, 0, 1196, 1199, 1, 0, 0, 0, 1197, 1195, 1, 0, 0, 0, 1197,
		1198, 1, 0, 0, 0, 1198, 1202, 1, 0, 0, 0, 1199, 1197, 1, 0, 0, 0, 1200,
		1201, 5, 43, 0, 0, 1201, 1203, 3, 182, 91, 0, 1202, 1200, 1, 0, 0, 0, 1202,
		1203, 1, 0, 0, 0, 1203, 1206, 1, 0, 0, 0, 1204, 1205, 5, 19, 0, 0, 1205,
		1207, 3, 24, 12, 0, 1206, 1204, 1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207,
		1209, 1, 0, 0, 0, 1208, 1210, 5, 82, 0, 0, 1209, 1208, 1, 0, 0, 0, 1209,
		1210, 1, 0, 0, 0, 1210, 1212, 1, 0, 0, 0, 1211, 1213, 7, 11, 0, 0, 1212,
		1211, 1, 0, 0, 0, 1212, 1213, 1, 0, 0, 0, 1213, 1214, 1, 0, 0, 0, 1214,
		1215, 5, 85, 0, 0, 1215, 1218, 3, 182, 91, 0, 1216, 1217, 5, 43, 0, 0,
		1217, 1219, 3, 182, 91, 0, 1218, 1216, 1, 0, 0, 0, 1218, 1219, 1, 0, 0,
		0, 1219, 1220, 1, 0, 0, 0, 1220, 1221, 5, 79, 0, 0, 1221, 1222, 3, 176,
		88, 0, 1222, 1223, 5, 181, 0, 0, 1223, 1234, 3, 176, 88, 0, 1224, 1225,
		5, 48, 0, 0, 1225, 1226, 5, 47, 0, 0, 1226, 1231, 3, 70, 35, 0, 1227, 1228,
		5, 4, 0, 0, 1228, 1230, 3, 70, 35, 0, 1229, 1227, 1, 0, 0, 0, 1230, 1233,
		1, 0, 0, 0, 1231, 1229, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 1235,
		1, 0, 0, 0, 1233, 1231, 1, 0, 0, 0, 1234, 1224, 1, 0, 0, 0, 1234, 1235,
		1, 0, 0, 0, 1235, 1238, 1, 0, 0, 0, 1236, 1237, 5, 30, 0, 0, 1237, 1239,
		5, 187, 0, 0, 1238, 1236, 1, 0, 0, 0, 1238, 1239, 1, 0, 0, 0, 1239, 1250,
		1, 0, 0, 0, 1240, 1248, 5, 69, 0, 0, 1241, 1242, 5, 5, 0, 0, 1242, 1245,
		5, 187, 0, 0, 1243, 1244, 5, 4, 0, 0, 1244, 1246, 3, 176, 88, 0, 1245,
		1243, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1247, 1, 0, 0, 0, 1247,
		1249, 5, 6, 0, 0, 1248, 1241, 1, 0, 0, 0, 1248, 1249, 1, 0, 0, 0, 1249,
		1251, 1, 0, 0, 0, 1250, 1240, 1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251,
		1253, 1, 0, 0, 0, 1252, 1254, 3, 72, 36, 0, 1253, 1252, 1, 0, 0, 0, 1253,
		1254, 1, 0, 0, 0, 1254, 1264, 1, 0, 0, 0, 1255, 1256, 5, 86, 0, 0, 1256,
		1261, 3, 78, 39, 0, 1257, 1258, 5, 9, 0, 0, 1258, 1260, 3, 78, 39, 0, 1259,
		1257, 1, 0, 0, 0, 1260, 1263, 1, 0, 0, 0, 1261, 1259, 1, 0, 0, 0, 1261,
		1262, 1, 0, 0, 0, 1262, 1265, 1, 0, 0, 0, 1263, 1261, 1, 0, 0, 0, 1264,
		1255, 1, 0, 0, 0, 1264, 1265, 1, 0, 0, 0, 1265, 1268, 1, 0, 0, 0, 1266,
		1267, 5, 44, 0, 0, 1267, 1269, 3, 182, 91, 0, 1268, 1266, 1, 0, 0, 0, 1268,
		1269, 1, 0, 0, 0, 1269, 131, 1, 0, 0, 0, 1270, 1271, 5, 45, 0, 0, 1271,
		1273, 3, 182, 91, 0, 1272, 1270, 1, 0, 0, 0, 1272, 1273, 1, 0, 0, 0, 1273,
		1275, 1, 0, 0, 0, 1274, 1276, 5, 38, 0, 0, 1275, 1274, 1, 0, 0, 0, 1275,
		1276, 1, 0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277, 1278, 5, 66, 0, 0, 1278,
		1282, 5, 58, 0, 0, 1279, 1280, 3, 182, 91, 0, 1280, 1281, 5, 180, 0, 0,
		1281, 1283, 1, 0, 0, 0, 1282, 1279, 1, 0, 0, 0, 1282, 1283, 1, 0, 0, 0,
		1283, 1284, 1, 0, 0, 0, 1284, 1289, 3, 180, 90, 0, 1285, 1287, 3, 134,
		67, 0, 1286, 1288, 3, 136, 68, 0, 1287, 1286, 1, 0, 0, 0, 1287, 1288, 1,
		0, 0, 0, 1288, 1290, 1, 0, 0, 0, 1289, 1285, 1, 0, 0, 0, 1289, 1290, 1,
		0, 0, 0, 1290, 1297, 1, 0, 0, 0, 1291, 1293, 5, 79, 0, 0, 1292, 1294, 5,
		81, 0, 0, 1293, 1292, 1, 0, 0, 0, 1293, 1294, 1, 0, 0, 0, 1294, 1295, 1,
		0, 0, 0, 1295, 1296, 5, 80, 0, 0, 1296, 1298, 3, 176, 88, 0, 1297, 1291,
		1, 0, 0, 0, 1297, 1298, 1, 0, 0, 0, 1298, 1301, 1, 0, 0, 0, 1299, 1300,
		5, 44, 0, 0, 1300, 1302, 3, 182, 91, 0, 1301, 1299, 1, 0, 0, 0, 1301, 1302,
		1, 0, 0, 0, 1302, 133, 1, 0, 0, 0, 1303, 1304, 5, 5, 0, 0, 1304, 1309,
		3, 162, 81, 0, 1305, 1306, 5, 4, 0, 0, 1306, 1308, 3, 162, 81, 0, 1307,
		1305, 1, 0, 0, 0, 1308, 1311, 1, 0, 0, 0, 1309, 1307, 1, 0, 0, 0, 1309,
		1310, 1, 0, 0, 0, 1310, 1312, 1, 0, 0, 0, 1311, 1309, 1, 0, 0, 0, 1312,
		1313, 5, 6, 0, 0, 1313, 135, 1, 0, 0, 0, 1314, 1315, 5, 67, 0, 0, 1315,
		1318, 3, 138, 69, 0, 1316, 1317, 5, 4, 0, 0, 1317, 1319, 3, 138, 69, 0,
		1318, 1316, 1, 0, 0, 0, 1318, 1319, 1, 0, 0, 0, 1319, 137, 1, 0, 0, 0,
		1320, 1321, 5, 5, 0, 0, 1321, 1326, 3, 64, 32, 0, 1322, 1323, 5, 4, 0,
		0, 1323, 1325, 3, 64, 32, 0, 1324, 1322, 1, 0, 0, 0, 1325, 1328, 1, 0,
		0, 0, 1326, 1324, 1, 0, 0, 0, 1326, 1327, 1, 0, 0, 0, 1327, 1329, 1, 0,
		0, 0, 1328, 1326, 1, 0, 0, 0, 1329, 1330, 5, 6, 0, 0, 1330, 139, 1, 0,
		0, 0, 1331, 1332, 7, 12, 0, 0, 1332, 1337, 3, 178, 89, 0, 1333, 1334, 5,
		4, 0, 0, 1334, 1336, 3, 178, 89, 0, 1335, 1333, 1, 0, 0, 0, 1336, 1339,
		1, 0, 0, 0, 1337, 1335, 1, 0, 0, 0, 1337, 1338, 1, 0, 0, 0, 1338, 1341,
		1, 0, 0, 0, 1339, 1337, 1, 0, 0, 0, 1340, 1342, 3, 90, 45, 0, 1341, 1340,
		1, 0, 0, 0, 1341, 1342, 1, 0, 0, 0, 1342, 1352, 1, 0, 0, 0, 1343, 1344,
		5, 140, 0, 0, 1344, 1349, 3, 142, 71, 0, 1345, 1346, 5, 4, 0, 0, 1346,
		1348, 3, 142, 71, 0, 1347, 1345, 1, 0, 0, 0, 1348, 1351, 1, 0, 0, 0, 1349,
		1347, 1, 0, 0, 0, 1349, 1350, 1, 0, 0, 0, 1350, 1353, 1, 0, 0, 0, 1351,
		1349, 1, 0, 0, 0, 1352, 1343, 1, 0, 0, 0, 1352, 1353, 1, 0, 0, 0, 1353,
		1375, 1, 0, 0, 0, 1354, 1355, 5, 19, 0, 0, 1355, 1376, 3, 24, 12, 0, 1356,
		1357, 5, 47, 0, 0, 1357, 1358, 5, 139, 0, 0, 1358, 1376, 3, 184, 92, 0,
		1359, 1360, 5, 47, 0, 0, 1360, 1361, 5, 68, 0, 0, 1361, 1362, 5, 181, 0,
		0, 1362, 1376, 3, 184, 92, 0, 1363, 1364, 5, 47, 0, 0, 1364, 1365, 5, 5,
		0, 0, 1365, 1370, 3, 184, 92, 0, 1366, 1367, 5, 4, 0, 0, 1367, 1369, 3,
		184, 92, 0, 1368, 1366, 1, 0, 0, 0, 1369, 1372, 1, 0, 0, 0, 1370, 1368,
		1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371, 1373, 1, 0, 0, 0, 1372, 1370,
		1, 0, 0, 0, 1373, 1374, 5, 6, 0, 0, 1374, 1376, 1, 0, 0, 0, 1375, 1354,
		1, 0, 0, 0, 1375, 1356, 1, 0, 0, 0, 1375, 1359, 1, 0, 0, 0, 1375, 1363,
		1, 0, 0, 0, 1376, 1379, 1, 0, 0, 0, 1377, 1378, 5, 44, 0, 0, 1378, 1380,
		3, 182, 91, 0, 1379, 1377, 1, 0, 0, 0, 1379, 1380, 1, 0, 0, 0, 1380, 141,
		1, 0, 0, 0, 1381, 1382, 3, 176, 88, 0, 1382, 1383, 5, 181, 0, 0, 1383,
		1384, 3, 64, 32, 0, 1384, 1400, 1, 0, 0, 0, 1385, 1386, 7, 13, 0, 0, 1386,
		1387, 5, 5, 0, 0, 1387, 1388, 3, 176, 88, 0, 1388, 1389, 5, 4, 0, 0, 1389,
		1394, 3, 64, 32, 0, 1390, 1391, 5, 4, 0, 0, 1391, 1393, 3, 64, 32, 0, 1392,
		1390, 1, 0, 0, 0, 1393, 1396, 1, 0, 0, 0, 1394, 1392, 1, 0, 0, 0, 1394,
		1395, 1, 0, 0, 0, 1395, 1397, 1, 0, 0, 0, 1396, 1394, 1, 0, 0, 0, 1397,
		1398, 5, 6, 0, 0, 1398, 1400, 1, 0, 0, 0, 1399, 1381, 1, 0, 0, 0, 1399,
		1385, 1, 0, 0, 0, 1400, 1432, 1, 0, 0, 0, 1401, 1402, 5, 144, 0, 0, 1402,
		1403, 7, 13, 0, 0, 1403, 1404, 5, 5, 0, 0, 1404, 1405, 3, 176, 88, 0, 1405,
		1406, 5, 4, 0, 0, 1406, 1411, 3, 64, 32, 0, 1407, 1408, 5, 4, 0, 0, 1408,
		1410, 3, 64, 32, 0, 1409, 1407, 1, 0, 0, 0, 1410, 1413, 1, 0, 0, 0, 1411,
		1409, 1, 0, 0, 0, 1411, 1412, 1, 0, 0, 0, 1412, 1414, 1, 0, 0, 0, 1413,
		1411, 1, 0, 0, 0, 1414, 1415, 5, 6, 0, 0, 1415, 1432, 1, 0, 0, 0, 1416,
		1417, 5, 13, 0, 0, 1417, 1418, 7, 13, 0, 0, 1418, 1419, 5, 5, 0, 0, 1419,
		1420, 3, 176, 88, 0, 1420, 1421, 5, 4, 0, 0, 1421, 1426, 3, 64, 32, 0,
		1422, 1423, 5, 4, 0, 0, 1423, 1425, 3, 64, 32, 0, 1424, 1422, 1, 0, 0,
		0, 1425, 1428, 1, 0, 0, 0, 1426, 1424, 1, 0, 0, 0, 1426, 1427, 1, 0, 0,
		0, 1427, 1429, 1, 0, 0, 0, 1428, 1426, 1, 0, 0, 0, 1429, 1430, 5, 6, 0,
		0, 1430, 1432, 1, 0, 0, 0, 1431, 1399, 1, 0, 0, 0, 1431, 1401, 1, 0, 0,
		0, 1431, 1416, 1, 0, 0, 0, 1432, 143, 1, 0, 0, 0, 1433, 1434, 7, 14, 0,
		0, 1434, 1439, 3, 184, 92, 0, 1435, 1436, 5, 4, 0, 0, 1436, 1438, 3, 184,
		92, 0, 1437, 1435, 1, 0, 0, 0, 1438, 1441, 1, 0, 0, 0, 1439, 1437, 1, 0,
		0, 0, 1439, 1440, 1, 0, 0, 0, 1440, 1443, 1, 0, 0, 0, 1441, 1439, 1, 0,
		0, 0, 1442, 1444, 3, 90, 45, 0, 1443, 1442, 1, 0, 0, 0, 1443, 1444, 1,
		0, 0, 0, 1444, 1459, 1, 0, 0, 0, 1445, 1446, 5, 140, 0, 0, 1446, 1447,
		3, 176, 88, 0, 1447, 1448, 5, 181, 0, 0, 1448, 1456, 3, 64, 32, 0, 1449,
		1450, 5, 4, 0, 0, 1450, 1451, 3, 176, 88, 0, 1451, 1452, 5, 181, 0, 0,
		1452, 1453, 3, 64, 32, 0, 1453, 1455, 1, 0, 0, 0, 1454, 1449, 1, 0, 0,
		0, 1455, 1458, 1, 0, 0, 0, 1456, 1454, 1, 0, 0, 0, 1456, 1457, 1, 0, 0,
		0, 1457, 1460, 1, 0, 0, 0, 1458, 1456, 1, 0, 0, 0, 1459, 1445, 1, 0, 0,
		0, 1459, 1460, 1, 0, 0, 0, 1460, 1463, 1, 0, 0, 0, 1461, 1462, 5, 44, 0,
		0, 1462, 1464, 3, 182, 91, 0, 1463, 1461, 1, 0, 0, 0, 1463, 1464, 1, 0,
		0, 0, 1464, 145, 1, 0, 0, 0, 1465, 1466, 5, 147, 0, 0, 1466, 1467, 5, 60,
		0, 0, 1467, 1472, 3, 178, 89, 0, 1468, 1469, 5, 4, 0, 0, 1469, 1471, 3,
		178, 89, 0, 1470, 1468, 1, 0, 0, 0, 1471, 1474, 1, 0, 0, 0, 1472, 1470,
		1, 0, 0, 0, 1472, 1473, 1, 0, 0, 0, 1473, 1490, 1, 0, 0, 0, 1474, 1472,
		1, 0, 0, 0, 1475, 1476, 5, 19, 0, 0, 1476, 1491, 3, 24, 12, 0, 1477, 1478,
		5, 47, 0, 0, 1478, 1479, 5, 139, 0, 0, 1479, 1491, 3, 184, 92, 0, 1480,
		1481, 5, 47, 0, 0, 1481, 1482, 5, 68, 0, 0, 1482, 1483, 5, 181, 0, 0, 1483,
		1491, 3, 184, 92, 0, 1484, 1485, 5, 47, 0, 0, 1485, 1486, 5, 138, 0, 0,
		1486, 1487, 5, 5, 0, 0, 1487, 1488, 3, 184, 92, 0, 1488, 1489, 5, 6, 0,
		0, 1489, 1491, 1, 0, 0, 0, 1490, 1475, 1, 0, 0, 0, 1490, 1477, 1, 0, 0,
		0, 1490, 1480, 1, 0, 0, 0, 1490, 1484, 1, 0, 0, 0, 1491, 1494, 1, 0, 0,
		0, 1492, 1493, 5, 44, 0, 0, 1493, 1495, 3, 182, 91, 0, 1494, 1492, 1, 0,
		0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 147, 1, 0, 0, 0, 1496, 1498, 7, 15,
		0, 0, 1497, 1499, 5, 52, 0, 0, 1498, 1497, 1, 0, 0, 0, 1498, 1499, 1, 0,
		0, 0, 1499, 1500, 1, 0, 0, 0, 1500, 1505, 3, 178, 89, 0, 1501, 1502, 5,
		4, 0, 0, 1502, 1504, 3, 178, 89, 0, 1503, 1501, 1, 0, 0, 0, 1504, 1507,
		1, 0, 0, 0, 1505, 1503, 1, 0, 0, 0, 1505, 1506, 1, 0, 0, 0, 1506, 149,
		1, 0, 0, 0, 1507, 1505, 1, 0, 0, 0, 1508, 1509, 5, 144, 0, 0, 1509, 1510,
		5, 87, 0, 0, 1510, 1511, 3, 178, 89, 0, 1511, 1512, 5, 59, 0, 0, 1512,
		1517, 3, 178, 89, 0, 1513, 1514, 5, 4, 0, 0, 1514, 1516, 3, 178, 89, 0,
		1515, 1513, 1, 0, 0, 0, 1516, 1519, 1, 0, 0, 0, 1517, 1515, 1, 0, 0, 0,
		1517, 1518, 1, 0, 0, 0, 1518, 1533, 1, 0, 0, 0, 1519, 1517, 1, 0, 0, 0,
		1520, 1521, 5, 147, 0, 0, 1521, 1522, 5, 87, 0, 0, 1522, 1523, 3, 178,
		89, 0, 1523, 1524, 5, 60, 0, 0, 1524, 1529, 3, 178, 89, 0, 1525, 1526,
		5, 4, 0, 0, 1526, 1528, 3, 178, 89, 0, 1527, 1525, 1, 0, 0, 0, 1528, 1531,
		1, 0, 0, 0, 1529, 1527, 1, 0, 0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1533,
		1, 0, 0, 0, 1531, 1529, 1, 0, 0, 0, 1532, 1508, 1, 0, 0, 0, 1532, 1520,
		1, 0, 0, 0, 1533, 151, 1, 0, 0, 0, 1534, 1535, 5, 88, 0, 0, 1535, 1540,
		3, 178, 89, 0, 1536, 1537, 5, 4, 0, 0, 1537, 1539, 3, 178, 89, 0, 1538,
		1536, 1, 0, 0, 0, 1539, 1542, 1, 0, 0, 0, 1540, 1538, 1, 0, 0, 0, 1540,
		1541, 1, 0, 0, 0, 1541, 1543, 1, 0, 0, 0, 1542, 1540, 1, 0, 0, 0, 1543,
		1544, 5, 140, 0, 0, 1544, 1549, 3, 62, 31, 0, 1545, 1546, 5, 4, 0, 0, 1546,
		1548, 3, 62, 31, 0, 1547, 1545, 1, 0, 0, 0, 1548, 1551, 1, 0, 0, 0, 1549,
		1547, 1, 0, 0, 0, 1549, 1550, 1, 0, 0, 0, 1550, 153, 1, 0, 0, 0, 1551,
		1549, 1, 0, 0, 0, 1552, 1553, 5, 45, 0, 0, 1553, 1555, 3, 184, 92, 0, 1554,
		1552, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1556, 1, 0, 0, 0, 1556,
		1557, 5, 35, 0, 0, 1557, 1562, 5, 189, 0, 0, 1558, 1559, 5, 9, 0, 0, 1559,
		1561, 5, 189, 0, 0, 1560, 1558, 1, 0, 0, 0, 1561, 1564, 1, 0, 0, 0, 1562,
		1560, 1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563, 1567, 1, 0, 0, 0, 1564,
		1562, 1, 0, 0, 0, 1565, 1566, 5, 44, 0, 0, 1566, 1568, 3, 182, 91, 0, 1567,
		1565, 1, 0, 0, 0, 1567, 1568, 1, 0, 0, 0, 1568, 1570, 1, 0, 0, 0, 1569,
		1571, 3, 72, 36, 0, 1570, 1569, 1, 0, 0, 0, 1570, 1571, 1, 0, 0, 0, 1571,
		155, 1, 0, 0, 0, 1572, 1588, 7, 16, 0, 0, 1573, 1574, 5, 2, 0, 0, 1574,
		1575, 5, 39, 0, 0, 1575, 1576, 5, 181, 0, 0, 1576, 1580, 5, 189, 0, 0,
		1577, 1578, 5, 41, 0, 0, 1578, 1579, 5, 181, 0, 0, 1579, 1581, 5, 189,
		0, 0, 1580, 1577, 1, 0, 0, 0, 1580, 1581, 1, 0, 0, 0, 1581, 1585, 1, 0,
		0, 0, 1582, 1583, 5, 40, 0, 0, 1583, 1584, 5, 181, 0, 0, 1584, 1586, 5,
		189, 0, 0, 1585, 1582, 1, 0, 0, 0, 1585, 1586, 1, 0, 0, 0, 1586, 1587,
		1, 0, 0, 0, 1587, 1589, 5, 3, 0, 0, 1588, 1573, 1, 0, 0, 0, 1588, 1589,
		1, 0, 0, 0, 1589, 1590, 1, 0, 0, 0, 1590, 1595, 3, 158, 79, 0, 1591, 1592,
		5, 9, 0, 0, 1592, 1594, 3, 158, 79, 0, 1593, 1591, 1, 0, 0, 0, 1594, 1597,
		1, 0, 0, 0, 1595, 1593, 1, 0, 0, 0, 1595, 1596, 1, 0, 0, 0, 1596, 157,
		1, 0, 0, 0, 1597, 1595, 1, 0, 0, 0, 1598, 1601, 5, 189, 0, 0, 1599, 1600,
		5, 44, 0, 0, 1600, 1602, 3, 182, 91, 0, 1601, 1599, 1, 0, 0, 0, 1601, 1602,
		1, 0, 0, 0, 1602, 1604, 1, 0, 0, 0, 1603, 1605, 3, 72, 36, 0, 1604, 1603,
		1, 0, 0, 0, 1604, 1605, 1, 0, 0, 0, 1605, 159, 1, 0, 0, 0, 1606, 1608,
		5, 164, 0, 0, 1607, 1609, 5, 55, 0, 0, 1608, 1607, 1, 0, 0, 0, 1608, 1609,
		1, 0, 0, 0, 1609, 1627, 1, 0, 0, 0, 1610, 1611, 5, 163, 0, 0, 1611, 1613,
		5, 5, 0, 0, 1612, 1614, 3, 162, 81, 0, 1613, 1612, 1, 0, 0, 0, 1613, 1614,
		1, 0, 0, 0, 1614, 1619, 1, 0, 0, 0, 1615, 1616, 5, 4, 0, 0, 1616, 1618,
		3, 162, 81, 0, 1617, 1615, 1, 0, 0, 0, 1618, 1621, 1, 0, 0, 0, 1619, 1617,
		1, 0, 0, 0, 1619, 1620, 1, 0, 0, 0, 1620, 1622, 1, 0, 0, 0, 1621, 1619,
		1, 0, 0, 0, 1622, 1628, 5, 6, 0, 0, 1623, 1625, 5, 72, 0, 0, 1624, 1626,
		7, 13, 0, 0, 1625, 1624, 1, 0, 0, 0, 1625, 1626, 1, 0, 0, 0, 1626, 1628,
		1, 0, 0, 0, 1627, 1610, 1, 0, 0, 0, 1627, 1623, 1, 0, 0, 0, 1628, 1629,
		1, 0, 0, 0, 1629, 1631, 5, 60, 0, 0, 1630, 1632, 5, 162, 0, 0, 1631, 1630,
		1, 0, 0, 0, 1631, 1632, 1, 0, 0, 0, 1632, 1633, 1, 0, 0, 0, 1633, 1637,
		3, 184, 92, 0, 1634, 1635, 5, 166, 0, 0, 1635, 1636, 5, 47, 0, 0, 1636,
		1638, 5, 189, 0, 0, 1637, 1634, 1, 0, 0, 0, 1637, 1638, 1, 0, 0, 0, 1638,
		1645, 1, 0, 0, 0, 1639, 1642, 5, 30, 0, 0, 1640, 1641, 5, 187, 0, 0, 1641,
		1643, 5, 4, 0, 0, 1642, 1640, 1, 0, 0, 0, 1642, 1643, 1, 0, 0, 0, 1643,
		1644, 1, 0, 0, 0, 1644, 1646, 5, 187, 0, 0, 1645, 1639, 1, 0, 0, 0, 1645,
		1646, 1, 0, 0, 0, 1646, 1649, 1, 0, 0, 0, 1647, 1648, 5, 44, 0, 0, 1648,
		1650, 3, 182, 91, 0, 1649, 1647, 1, 0, 0, 0, 1649, 1650, 1, 0, 0, 0, 1650,
		161, 1, 0, 0, 0, 1651, 1653, 3, 176, 88, 0, 1652, 1654, 3, 170, 85, 0,
		1653, 1652, 1, 0, 0, 0, 1653, 1654, 1, 0, 0, 0, 1654, 163, 1, 0, 0, 0,
		1655, 1656, 5, 167, 0, 0, 1656, 1663, 5, 189, 0, 0, 1657, 1658, 5, 47,
		0, 0, 1658, 1661, 3, 184, 92, 0, 1659, 1660, 5, 4, 0, 0, 1660, 1662, 3,
		184, 92, 0, 1661, 1659, 1, 0, 0, 0, 1661, 1662, 1, 0, 0, 0, 1662, 1664,
		1, 0, 0, 0, 1663, 1657, 1, 0, 0, 0, 1663, 1664, 1, 0, 0, 0, 1664, 165,
		1, 0, 0, 0, 1665, 1666, 5, 168, 0, 0, 1666, 1667, 3, 168, 84, 0, 1667,
		1668, 3, 184, 92, 0, 1668, 1669, 5, 169, 0, 0, 1669, 1670, 5, 5, 0, 0,
		1670, 1675, 3, 184, 92, 0, 1671, 1672, 5, 4, 0, 0, 1672, 1674, 3, 184,
		92, 0, 1673, 1671, 1, 0, 0, 0, 1674, 1677, 1, 0, 0, 0, 1675, 1673, 1, 0,
		0, 0, 1675, 1676, 1, 0, 0, 0, 1676, 1678, 1, 0, 0, 0, 1677, 1675, 1, 0,
		0, 0, 1678, 1679, 5, 6, 0, 0, 1679, 167, 1, 0, 0, 0, 1680, 1681, 7, 17,
		0, 0, 1681, 169, 1, 0, 0, 0, 1682, 1683, 7, 18, 0, 0, 1683, 171, 1, 0,
		0, 0, 1684, 1685, 7, 19, 0, 0, 1685, 173, 1, 0, 0, 0, 1686, 1691, 3, 74,
		37, 0, 1687, 1688, 7, 20, 0, 0, 1688, 1690, 3, 74, 37, 0, 1689, 1687, 1,
		0, 0, 0, 1690, 1693, 1, 0, 0, 0, 1691, 1689, 1, 0, 0, 0, 1691, 1692, 1,
		0, 0, 0, 1692, 175, 1, 0, 0, 0, 1693, 1691, 1, 0, 0, 0, 1694, 1699, 3,
		182, 91, 0, 1695, 1696, 7, 21, 0, 0, 1696, 1698, 3, 182, 91, 0, 1697, 1695,
		1, 0, 0, 0, 1698, 1701, 1, 0, 0, 0, 1699, 1697, 1, 0, 0, 0, 1699, 1700,
		1, 0, 0, 0, 1700, 1704, 1, 0, 0, 0, 1701, 1699, 1, 0, 0, 0, 1702, 1704,
		5, 176, 0, 0, 1703, 1694, 1, 0, 0, 0, 1703, 1702, 1, 0, 0, 0, 1704, 177,
		1, 0, 0, 0, 1705, 1708, 3, 180, 90, 0, 1706, 1707, 5, 180, 0, 0, 1707,
		1709, 3, 182, 91, 0, 1708, 1706, 1, 0, 0, 0, 1708, 1709, 1, 0, 0, 0, 1709,
		179, 1, 0, 0, 0, 1710, 1712, 5, 190, 0, 0, 1711, 1713, 5, 176, 0, 0, 1712,
		1711, 1, 0, 0, 0, 1712, 1713, 1, 0, 0, 0, 1713, 1716, 1, 0, 0, 0, 1714,
		1716, 5, 189, 0, 0, 1715, 1710, 1, 0, 0, 0, 1715, 1714, 1, 0, 0, 0, 1716,
		181, 1, 0, 0, 0, 1717, 1720, 5, 190, 0, 0, 1718, 1720, 3, 190, 95, 0, 1719,
		1717, 1, 0, 0, 0, 1719, 1718, 1, 0, 0, 0, 1720, 183, 1, 0, 0, 0, 1721,
		1722, 7, 22, 0, 0, 1722, 185, 1, 0, 0, 0, 1723, 1724, 7, 23, 0, 0, 1724,
		187, 1, 0, 0, 0, 1725, 1726, 7, 24, 0, 0, 1726, 189, 1, 0, 0, 0, 1727,
		1728, 7, 25, 0, 0, 1728, 191, 1, 0, 0, 0, 239, 197, 216, 220, 227, 234,
		236, 239, 243, 248, 255, 263, 269, 271, 274, 277, 286, 289, 293, 298, 302,
		304, 311, 314, 316, 318, 320, 324, 327, 333, 346, 354, 365, 370, 379, 397,
		403, 407, 410, 414, 418, 426, 430, 432, 435, 440, 446, 454, 456, 460, 466,
		471, 478, 488, 495, 497, 507, 517, 534, 540, 547, 562, 572, 574, 583, 593,
		599, 607, 609, 616, 630, 638, 645, 648, 654, 657, 660, 664, 672, 677, 686,
		691, 693, 699, 701, 707, 711, 718, 723, 726, 733, 739, 742, 746, 750, 753,
		757, 768, 777, 780, 783, 792, 797, 800, 816, 824, 829, 832, 841, 846, 850,
		853, 862, 865, 874, 886, 904, 906, 908, 924, 927, 938, 947, 953, 961, 964,
		970, 981, 990, 997, 1005, 1012, 1018, 1025, 1027, 1037, 1044, 1050, 1056,
		1063, 1065, 1091, 1104, 1112, 1114, 1127, 1138, 1143, 1148, 1152, 1155,
		1166, 1177, 1187, 1189, 1197, 1202, 1206, 1209, 1212, 1218, 1231, 1234,
		1238, 1245, 1248, 1250, 1253, 1261, 1264, 1268, 1272, 1275, 1282, 1287,
		1289, 1293, 1297, 1301, 1309, 1318, 1326, 1337, 1341, 1349, 1352, 1370,
		1375, 1379, 1394, 1399, 1411, 1426, 1431, 1439, 1443, 1456, 1459, 1463,
		1472, 1490, 1494, 1498, 1505, 1517, 1529, 1532, 1540, 1549, 1554, 1562,
		1567, 1570, 1580, 1585, 1588, 1595, 1601, 1604, 1608, 1613, 1619, 1625,
		1627, 1631, 1637, 1642, 1645, 1649, 1653, 1661, 1663, 1675, 1691, 1699,
		1703, 1708, 1712, 1715, 1719,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ElasticSQLParserInit initializes any static state used to implement ElasticSQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewElasticSQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func ElasticSQLParserInit() {
	staticData := &ElasticSQLParserStaticData
	staticData.once.Do(elasticsqlParserInit)
}

// NewElasticSQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewElasticSQLParser(input antlr.TokenStream) *ElasticSQLParser {
	ElasticSQLParserInit()
	this := new(ElasticSQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ElasticSQLParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "ElasticSQL.g4"

	return this
}

// ElasticSQLParser tokens.
const (
	ElasticSQLParserEOF                 = antlr.TokenEOF
	ElasticSQLParserT__0                = 1
	ElasticSQLParserT__1                = 2
	ElasticSQLParserT__2                = 3
	ElasticSQLParserT__3                = 4
	ElasticSQLParserT__4                = 5
	ElasticSQLParserT__5                = 6
	ElasticSQLParserT__6                = 7
	ElasticSQLParserT__7                = 8
	ElasticSQLParserT__8                = 9
	ElasticSQLParserT__9                = 10
	ElasticSQLParserT__10               = 11
	ElasticSQLParserT__11               = 12
	ElasticSQLParserREMOVE              = 13
	ElasticSQLParserSELECT              = 14
	ElasticSQLParserSCROLL              = 15
	ElasticSQLParserHIGHLIGHT           = 16
	ElasticSQLParserSCROLL_ID           = 17
	ElasticSQLParserINNER_HIT           = 18
	ElasticSQLParserWHERE               = 19
	ElasticSQLParserCUSTOM_SCORE        = 20
	ElasticSQLParserRESCORE             = 21
	ElasticSQLParserWINDOWS             = 22
	ElasticSQLParserCOLLAPSE            = 23
	ElasticSQLParserSCORE               = 24
	ElasticSQLParserMEM_SORT            = 25
	ElasticSQLParserKEEP                = 26
	ElasticSQLParserWEIGHT              = 27
	ElasticSQLParserEXPLAIN             = 28
	ElasticSQLParserWHERES              = 29
	ElasticSQLParserLIMIT               = 30
	ElasticSQLParserTRACK_HIT           = 31
	ElasticSQLParserOFFSET              = 32
	ElasticSQLParserSQL                 = 33
	ElasticSQLParserSTRUCT              = 34
	ElasticSQLParserHQL                 = 35
	ElasticSQLParserCK                  = 36
	ElasticSQLParserPQL                 = 37
	ElasticSQLParserMQL                 = 38
	ElasticSQLParserURL                 = 39
	ElasticSQLParserPASSWORD            = 40
	ElasticSQLParserUSER                = 41
	ElasticSQLParserWITH                = 42
	ElasticSQLParserAS                  = 43
	ElasticSQLParserMAP                 = 44
	ElasticSQLParserUSING               = 45
	ElasticSQLParserGROUP               = 46
	ElasticSQLParserBY                  = 47
	ElasticSQLParserORDER               = 48
	ElasticSQLParserASC                 = 49
	ElasticSQLParserDESC                = 50
	ElasticSQLParserDESCRIBE            = 51
	ElasticSQLParserTEMPLATE            = 52
	ElasticSQLParserBETWEEN             = 53
	ElasticSQLParserOR                  = 54
	ElasticSQLParserALL                 = 55
	ElasticSQLParserAND                 = 56
	ElasticSQLParserNOT                 = 57
	ElasticSQLParserINTO                = 58
	ElasticSQLParserTO                  = 59
	ElasticSQLParserFROM                = 60
	ElasticSQLParserHAVING              = 61
	ElasticSQLParserEXCLUDE             = 62
	ElasticSQLParserINCLUDE             = 63
	ElasticSQLParserDOC_COUNT           = 64
	ElasticSQLParserTOP                 = 65
	ElasticSQLParserINSERT              = 66
	ElasticSQLParserVALUES              = 67
	ElasticSQLParserID                  = 68
	ElasticSQLParserSLICE               = 69
	ElasticSQLParserEXPORT              = 70
	ElasticSQLParserHEADER              = 71
	ElasticSQLParserJSON                = 72
	ElasticSQLParserCSV                 = 73
	ElasticSQLParserEXCEL               = 74
	ElasticSQLParserSEP                 = 75
	ElasticSQLParserSCRIPT              = 76
	ElasticSQLParserLANG                = 77
	ElasticSQLParserRETURN              = 78
	ElasticSQLParserON                  = 79
	ElasticSQLParserPK                  = 80
	ElasticSQLParserUUID                = 81
	ElasticSQLParserMEM                 = 82
	ElasticSQLParserRIGHT               = 83
	ElasticSQLParserLEFT                = 84
	ElasticSQLParserJOIN                = 85
	ElasticSQLParserAGG                 = 86
	ElasticSQLParserALIAS               = 87
	ElasticSQLParserALTER               = 88
	ElasticSQLParserRLIKE               = 89
	ElasticSQLParserLIKE                = 90
	ElasticSQLParserNOT_LIKE            = 91
	ElasticSQLParserSTARTS_WITH         = 92
	ElasticSQLParserIN                  = 93
	ElasticSQLParserOUT                 = 94
	ElasticSQLParserHAS_ANY             = 95
	ElasticSQLParserHAS_ALL             = 96
	ElasticSQLParserEXIST               = 97
	ElasticSQLParserMISS                = 98
	ElasticSQLParserQUERY_STRING        = 99
	ElasticSQLParserMATCH               = 100
	ElasticSQLParserMULTI_MATCH         = 101
	ElasticSQLParserMATCH_PHRASE_PREFIX = 102
	ElasticSQLParserMATCH_PHRASE        = 103
	ElasticSQLParserKNN                 = 104
	ElasticSQLParserLOCAL_FILE          = 105
	ElasticSQLParserHAS_CHILD           = 106
	ElasticSQLParserHAS_PARENT          = 107
	ElasticSQLParserCOUNT               = 108
	ElasticSQLParserMAX                 = 109
	ElasticSQLParserMIN                 = 110
	ElasticSQLParserAVG                 = 111
	ElasticSQLParserAVG_DATE            = 112
	ElasticSQLParserSUM                 = 113
	ElasticSQLParserDISTINCT            = 114
	ElasticSQLParserVALUE_COUNT         = 115
	ElasticSQLParserPERCENTILE_RANKS    = 116
	ElasticSQLParserPERCENTILES         = 117
	ElasticSQLParserPERCENT             = 118
	ElasticSQLParserDISTINCT_PERCENT    = 119
	ElasticSQLParserTOP_HITS            = 120
	ElasticSQLParserPOST_EXPR           = 121
	ElasticSQLParserMATH                = 122
	ElasticSQLParserRANGE               = 123
	ElasticSQLParserDATE_RANGE          = 124
	ElasticSQLParserHISTOGRAM           = 125
	ElasticSQLParserDATE_HISTOGRAM      = 126
	ElasticSQLParserINTERVAL            = 127
	ElasticSQLParserFORMAT              = 128
	ElasticSQLParserKEYED               = 129
	ElasticSQLParserSIZE                = 130
	ElasticSQLParserMISSING             = 131
	ElasticSQLParserNULL                = 132
	ElasticSQLParserWHEN                = 133
	ElasticSQLParserEND                 = 134
	ElasticSQLParserTHEN                = 135
	ElasticSQLParserSAMPLE              = 136
	ElasticSQLParserSIGNIFICANT         = 137
	ElasticSQLParserIDS                 = 138
	ElasticSQLParserIDS_FILE            = 139
	ElasticSQLParserSET                 = 140
	ElasticSQLParserUPDATE              = 141
	ElasticSQLParserUPSERT              = 142
	ElasticSQLParserPUT                 = 143
	ElasticSQLParserADD                 = 144
	ElasticSQLParserBATCH_UPDATE        = 145
	ElasticSQLParserBATCH_UPSERT        = 146
	ElasticSQLParserDELETE              = 147
	ElasticSQLParserARRAY               = 148
	ElasticSQLParserFALSE               = 149
	ElasticSQLParserTRUE                = 150
	ElasticSQLParserNUMBER              = 151
	ElasticSQLParserSTRING              = 152
	ElasticSQLParserBOOLEAN_T           = 153
	ElasticSQLParserLONG_T              = 154
	ElasticSQLParserDOUBLE_T            = 155
	ElasticSQLParserINTEGER_T           = 156
	ElasticSQLParserDATETIME_T          = 157
	ElasticSQLParserTIMESTAMP_T         = 158
	ElasticSQLParserDATE_T              = 159
	ElasticSQLParserTIME_T              = 160
	ElasticSQLParserFLOAT_T             = 161
	ElasticSQLParserLOCAL               = 162
	ElasticSQLParserDATA                = 163
	ElasticSQLParserLOAD                = 164
	ElasticSQLParserLIST                = 165
	ElasticSQLParserSEPARATED           = 166
	ElasticSQLParserANALYZE             = 167
	ElasticSQLParserNLP                 = 168
	ElasticSQLParserENABLE              = 169
	ElasticSQLParserSEGMENT             = 170
	ElasticSQLParserNAME                = 171
	ElasticSQLParserORG                 = 172
	ElasticSQLParserLOC                 = 173
	ElasticSQLParserPLUS                = 174
	ElasticSQLParserMINUS               = 175
	ElasticSQLParserMUL                 = 176
	ElasticSQLParserDIV                 = 177
	ElasticSQLParserMOD                 = 178
	ElasticSQLParserPOWER               = 179
	ElasticSQLParserDOT                 = 180
	ElasticSQLParserEQ                  = 181
	ElasticSQLParserNE                  = 182
	ElasticSQLParserLT                  = 183
	ElasticSQLParserLE                  = 184
	ElasticSQLParserGT                  = 185
	ElasticSQLParserGE                  = 186
	ElasticSQLParserLONG                = 187
	ElasticSQLParserDOUBLE              = 188
	ElasticSQLParserQUOTASTR            = 189
	ElasticSQLParserIDENTIFIER          = 190
	ElasticSQLParserEXT_IDENTIFIER      = 191
	ElasticSQLParserLINE_COMMENT        = 192
	ElasticSQLParserBLOCK_COMMNET       = 193
	ElasticSQLParserWS                  = 194
)

// ElasticSQLParser rules.
const (
	ElasticSQLParserRULE_elasticSQL                  = 0
	ElasticSQLParserRULE_statement                   = 1
	ElasticSQLParserRULE_queryStatement              = 2
	ElasticSQLParserRULE_selectItem                  = 3
	ElasticSQLParserRULE_collapseExpr                = 4
	ElasticSQLParserRULE_customScoreExpr             = 5
	ElasticSQLParserRULE_rescoreExpr                 = 6
	ElasticSQLParserRULE_memSort                     = 7
	ElasticSQLParserRULE_innerHit                    = 8
	ElasticSQLParserRULE_scriptField                 = 9
	ElasticSQLParserRULE_highlight                   = 10
	ElasticSQLParserRULE_fieldAs                     = 11
	ElasticSQLParserRULE_whereExpression             = 12
	ElasticSQLParserRULE_logicalExpr                 = 13
	ElasticSQLParserRULE_comparableExpression        = 14
	ElasticSQLParserRULE_termCompare                 = 15
	ElasticSQLParserRULE_btwCompare                  = 16
	ElasticSQLParserRULE_arithmeticExpressionCompare = 17
	ElasticSQLParserRULE_arithmeticExpression        = 18
	ElasticSQLParserRULE_addition                    = 19
	ElasticSQLParserRULE_multiplyingExpression       = 20
	ElasticSQLParserRULE_multi                       = 21
	ElasticSQLParserRULE_atom                        = 22
	ElasticSQLParserRULE_functionalCompare           = 23
	ElasticSQLParserRULE_joinFunction                = 24
	ElasticSQLParserRULE_joinFunctionNames           = 25
	ElasticSQLParserRULE_scriptFunction              = 26
	ElasticSQLParserRULE_fullLevelFunction           = 27
	ElasticSQLParserRULE_fullLevelFunctionNames      = 28
	ElasticSQLParserRULE_termLevelFunction           = 29
	ElasticSQLParserRULE_termLevelFunctionNames      = 30
	ElasticSQLParserRULE_prop                        = 31
	ElasticSQLParserRULE_param                       = 32
	ElasticSQLParserRULE_param2                      = 33
	ElasticSQLParserRULE_arrayValue                  = 34
	ElasticSQLParserRULE_sortItem                    = 35
	ElasticSQLParserRULE_exportStatement             = 36
	ElasticSQLParserRULE_exportField                 = 37
	ElasticSQLParserRULE_analysisStatement           = 38
	ElasticSQLParserRULE_aggStatement                = 39
	ElasticSQLParserRULE_metricAgg                   = 40
	ElasticSQLParserRULE_metricNames                 = 41
	ElasticSQLParserRULE_metricParams                = 42
	ElasticSQLParserRULE_mkv                         = 43
	ElasticSQLParserRULE_metricParamNames            = 44
	ElasticSQLParserRULE_scriptPhrase                = 45
	ElasticSQLParserRULE_bucketAggList               = 46
	ElasticSQLParserRULE_bucketAgg                   = 47
	ElasticSQLParserRULE_bucketAggChoice             = 48
	ElasticSQLParserRULE_termsBucket                 = 49
	ElasticSQLParserRULE_havingExpr                  = 50
	ElasticSQLParserRULE_rangeBucket                 = 51
	ElasticSQLParserRULE_rangeExpr                   = 52
	ElasticSQLParserRULE_rangeUnit                   = 53
	ElasticSQLParserRULE_rangeFromTo                 = 54
	ElasticSQLParserRULE_dateRangeBucket             = 55
	ElasticSQLParserRULE_dateRangeExpr               = 56
	ElasticSQLParserRULE_dateRange                   = 57
	ElasticSQLParserRULE_dateRangeFromTo             = 58
	ElasticSQLParserRULE_histogramBucket             = 59
	ElasticSQLParserRULE_dateHistogramBucket         = 60
	ElasticSQLParserRULE_significantBucket           = 61
	ElasticSQLParserRULE_filtersBucket               = 62
	ElasticSQLParserRULE_sparkStatement              = 63
	ElasticSQLParserRULE_dataStruct                  = 64
	ElasticSQLParserRULE_joinQueryAnalysisStatement  = 65
	ElasticSQLParserRULE_insertStatement             = 66
	ElasticSQLParserRULE_fieldList                   = 67
	ElasticSQLParserRULE_valueList                   = 68
	ElasticSQLParserRULE_paramValues                 = 69
	ElasticSQLParserRULE_updateStatement             = 70
	ElasticSQLParserRULE_updateField                 = 71
	ElasticSQLParserRULE_batchUpdateStatement        = 72
	ElasticSQLParserRULE_deleteStatement             = 73
	ElasticSQLParserRULE_descStatement               = 74
	ElasticSQLParserRULE_aliasStatement              = 75
	ElasticSQLParserRULE_alterStatement              = 76
	ElasticSQLParserRULE_hive2Statement              = 77
	ElasticSQLParserRULE_jdbcStatement               = 78
	ElasticSQLParserRULE_basicSQL                    = 79
	ElasticSQLParserRULE_fileLoadStatement           = 80
	ElasticSQLParserRULE_fieldDefine                 = 81
	ElasticSQLParserRULE_analyzeStatement            = 82
	ElasticSQLParserRULE_hanLPStatement              = 83
	ElasticSQLParserRULE_nlpFunc                     = 84
	ElasticSQLParserRULE_dataType                    = 85
	ElasticSQLParserRULE_comparisonOperator          = 86
	ElasticSQLParserRULE_pathIdentifier              = 87
	ElasticSQLParserRULE_fieldIdentifier             = 88
	ElasticSQLParserRULE_indexIdentifier             = 89
	ElasticSQLParserRULE_indexName                   = 90
	ElasticSQLParserRULE_strictIdentifier            = 91
	ElasticSQLParserRULE_str                         = 92
	ElasticSQLParserRULE_number                      = 93
	ElasticSQLParserRULE_booleanValue                = 94
	ElasticSQLParserRULE_nonReserved                 = 95
)

// IElasticSQLContext is an interface to support dynamic dispatch.
type IElasticSQLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_statement returns the _statement rule contexts.
	Get_statement() IStatementContext

	// Set_statement sets the _statement rule contexts.
	Set_statement(IStatementContext)

	// GetStatements returns the statements rule context list.
	GetStatements() []IStatementContext

	// SetStatements sets the statements rule context list.
	SetStatements([]IStatementContext)

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsElasticSQLContext differentiates from other interfaces.
	IsElasticSQLContext()
}

type ElasticSQLContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_statement IStatementContext
	statements []IStatementContext
}

func NewEmptyElasticSQLContext() *ElasticSQLContext {
	var p = new(ElasticSQLContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_elasticSQL
	return p
}

func InitEmptyElasticSQLContext(p *ElasticSQLContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_elasticSQL
}

func (*ElasticSQLContext) IsElasticSQLContext() {}

func NewElasticSQLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElasticSQLContext {
	var p = new(ElasticSQLContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_elasticSQL

	return p
}

func (s *ElasticSQLContext) GetParser() antlr.Parser { return s.parser }

func (s *ElasticSQLContext) Get_statement() IStatementContext { return s._statement }

func (s *ElasticSQLContext) Set_statement(v IStatementContext) { s._statement = v }

func (s *ElasticSQLContext) GetStatements() []IStatementContext { return s.statements }

func (s *ElasticSQLContext) SetStatements(v []IStatementContext) { s.statements = v }

func (s *ElasticSQLContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *ElasticSQLContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ElasticSQLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElasticSQLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElasticSQLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterElasticSQL(s)
	}
}

func (s *ElasticSQLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitElasticSQL(s)
	}
}

func (s *ElasticSQLContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitElasticSQL(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ElasticSQL() (localctx IElasticSQLContext) {
	localctx = NewElasticSQLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ElasticSQLParserRULE_elasticSQL)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(192)

		var _x = p.Statement()

		localctx.(*ElasticSQLContext)._statement = _x
	}
	localctx.(*ElasticSQLContext).statements = append(localctx.(*ElasticSQLContext).statements, localctx.(*ElasticSQLContext)._statement)
	p.SetState(197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__0 {
		{
			p.SetState(193)
			p.Match(ElasticSQLParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(194)

			var _x = p.Statement()

			localctx.(*ElasticSQLContext)._statement = _x
		}
		localctx.(*ElasticSQLContext).statements = append(localctx.(*ElasticSQLContext).statements, localctx.(*ElasticSQLContext)._statement)

		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryStatement() IQueryStatementContext
	AnalysisStatement() IAnalysisStatementContext
	SparkStatement() ISparkStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	BatchUpdateStatement() IBatchUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	DescStatement() IDescStatementContext
	AliasStatement() IAliasStatementContext
	AlterStatement() IAlterStatementContext
	JoinQueryAnalysisStatement() IJoinQueryAnalysisStatementContext
	Hive2Statement() IHive2StatementContext
	JdbcStatement() IJdbcStatementContext
	FileLoadStatement() IFileLoadStatementContext
	AnalyzeStatement() IAnalyzeStatementContext
	HanLPStatement() IHanLPStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *StatementContext) AnalysisStatement() IAnalysisStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalysisStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalysisStatementContext)
}

func (s *StatementContext) SparkStatement() ISparkStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISparkStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISparkStatementContext)
}

func (s *StatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *StatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *StatementContext) BatchUpdateStatement() IBatchUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchUpdateStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) DescStatement() IDescStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescStatementContext)
}

func (s *StatementContext) AliasStatement() IAliasStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasStatementContext)
}

func (s *StatementContext) AlterStatement() IAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementContext)
}

func (s *StatementContext) JoinQueryAnalysisStatement() IJoinQueryAnalysisStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinQueryAnalysisStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinQueryAnalysisStatementContext)
}

func (s *StatementContext) Hive2Statement() IHive2StatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHive2StatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHive2StatementContext)
}

func (s *StatementContext) JdbcStatement() IJdbcStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJdbcStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJdbcStatementContext)
}

func (s *StatementContext) FileLoadStatement() IFileLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileLoadStatementContext)
}

func (s *StatementContext) AnalyzeStatement() IAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeStatementContext)
}

func (s *StatementContext) HanLPStatement() IHanLPStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHanLPStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHanLPStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ElasticSQLParserRULE_statement)
	p.SetState(216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(200)
			p.QueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(201)
			p.AnalysisStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(202)
			p.SparkStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(203)
			p.InsertStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(204)
			p.UpdateStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(205)
			p.BatchUpdateStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(206)
			p.DeleteStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(207)
			p.DescStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(208)
			p.AliasStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(209)
			p.AlterStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(210)
			p.JoinQueryAnalysisStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(211)
			p.Hive2Statement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(212)
			p.JdbcStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(213)
			p.FileLoadStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(214)
			p.AnalyzeStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(215)
			p.HanLPStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryStatementContext is an interface to support dynamic dispatch.
type IQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetScroll_id returns the scroll_id token.
	GetScroll_id() antlr.Token

	// GetTrack returns the track token.
	GetTrack() antlr.Token

	// GetOffset returns the offset token.
	GetOffset() antlr.Token

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// GetSliceMax returns the sliceMax token.
	GetSliceMax() antlr.Token

	// SetScroll_id sets the scroll_id token.
	SetScroll_id(antlr.Token)

	// SetTrack sets the track token.
	SetTrack(antlr.Token)

	// SetOffset sets the offset token.
	SetOffset(antlr.Token)

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// SetSliceMax sets the sliceMax token.
	SetSliceMax(antlr.Token)

	// GetFront returns the front rule contexts.
	GetFront() IStrictIdentifierContext

	// GetKeep returns the keep rule contexts.
	GetKeep() IStrContext

	// GetScore returns the score rule contexts.
	GetScore() IBooleanValueContext

	// GetMinScore returns the minScore rule contexts.
	GetMinScore() INumberContext

	// Get_selectItem returns the _selectItem rule contexts.
	Get_selectItem() ISelectItemContext

	// Get_indexIdentifier returns the _indexIdentifier rule contexts.
	Get_indexIdentifier() IIndexIdentifierContext

	// Get_sortItem returns the _sortItem rule contexts.
	Get_sortItem() ISortItemContext

	// GetSliceField returns the sliceField rule contexts.
	GetSliceField() IFieldIdentifierContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// SetFront sets the front rule contexts.
	SetFront(IStrictIdentifierContext)

	// SetKeep sets the keep rule contexts.
	SetKeep(IStrContext)

	// SetScore sets the score rule contexts.
	SetScore(IBooleanValueContext)

	// SetMinScore sets the minScore rule contexts.
	SetMinScore(INumberContext)

	// Set_selectItem sets the _selectItem rule contexts.
	Set_selectItem(ISelectItemContext)

	// Set_indexIdentifier sets the _indexIdentifier rule contexts.
	Set_indexIdentifier(IIndexIdentifierContext)

	// Set_sortItem sets the _sortItem rule contexts.
	Set_sortItem(ISortItemContext)

	// SetSliceField sets the sliceField rule contexts.
	SetSliceField(IFieldIdentifierContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// GetSelectItems returns the selectItems rule context list.
	GetSelectItems() []ISelectItemContext

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexIdentifierContext

	// GetSorts returns the sorts rule context list.
	GetSorts() []ISortItemContext

	// SetSelectItems sets the selectItems rule context list.
	SetSelectItems([]ISelectItemContext)

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexIdentifierContext)

	// SetSorts sets the sorts rule context list.
	SetSorts([]ISortItemContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	USING() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ExportStatement() IExportStatementContext
	AllStrictIdentifier() []IStrictIdentifierContext
	StrictIdentifier(i int) IStrictIdentifierContext
	BY() antlr.TerminalNode
	SCROLL_ID() antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	FROM() antlr.TerminalNode
	SCROLL() antlr.TerminalNode
	SCORE() antlr.TerminalNode
	QUOTASTR() antlr.TerminalNode
	AllIndexIdentifier() []IIndexIdentifierContext
	IndexIdentifier(i int) IIndexIdentifierContext
	Str() IStrContext
	WHERE() antlr.TerminalNode
	WhereExpression() IWhereExpressionContext
	RescoreExpr() IRescoreExprContext
	CollapseExpr() ICollapseExprContext
	ORDER() antlr.TerminalNode
	TRACK_HIT() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	SLICE() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllLONG() []antlr.TerminalNode
	LONG(i int) antlr.TerminalNode
	GE() antlr.TerminalNode
	BooleanValue() IBooleanValueContext
	Number() INumberContext
	CustomScoreExpr() ICustomScoreExprContext
	MemSort() IMemSortContext
	FieldIdentifier() IFieldIdentifierContext

	// IsQueryStatementContext differentiates from other interfaces.
	IsQueryStatementContext()
}

type QueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	front            IStrictIdentifierContext
	keep             IStrContext
	score            IBooleanValueContext
	minScore         INumberContext
	_selectItem      ISelectItemContext
	selectItems      []ISelectItemContext
	scroll_id        antlr.Token
	_indexIdentifier IIndexIdentifierContext
	indexes          []IIndexIdentifierContext
	_sortItem        ISortItemContext
	sorts            []ISortItemContext
	track            antlr.Token
	offset           antlr.Token
	limit            antlr.Token
	sliceMax         antlr.Token
	sliceField       IFieldIdentifierContext
	statName         IStrictIdentifierContext
}

func NewEmptyQueryStatementContext() *QueryStatementContext {
	var p = new(QueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_queryStatement
	return p
}

func InitEmptyQueryStatementContext(p *QueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_queryStatement
}

func (*QueryStatementContext) IsQueryStatementContext() {}

func NewQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStatementContext {
	var p = new(QueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_queryStatement

	return p
}

func (s *QueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStatementContext) GetScroll_id() antlr.Token { return s.scroll_id }

func (s *QueryStatementContext) GetTrack() antlr.Token { return s.track }

func (s *QueryStatementContext) GetOffset() antlr.Token { return s.offset }

func (s *QueryStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *QueryStatementContext) GetSliceMax() antlr.Token { return s.sliceMax }

func (s *QueryStatementContext) SetScroll_id(v antlr.Token) { s.scroll_id = v }

func (s *QueryStatementContext) SetTrack(v antlr.Token) { s.track = v }

func (s *QueryStatementContext) SetOffset(v antlr.Token) { s.offset = v }

func (s *QueryStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QueryStatementContext) SetSliceMax(v antlr.Token) { s.sliceMax = v }

func (s *QueryStatementContext) GetFront() IStrictIdentifierContext { return s.front }

func (s *QueryStatementContext) GetKeep() IStrContext { return s.keep }

func (s *QueryStatementContext) GetScore() IBooleanValueContext { return s.score }

func (s *QueryStatementContext) GetMinScore() INumberContext { return s.minScore }

func (s *QueryStatementContext) Get_selectItem() ISelectItemContext { return s._selectItem }

func (s *QueryStatementContext) Get_indexIdentifier() IIndexIdentifierContext {
	return s._indexIdentifier
}

func (s *QueryStatementContext) Get_sortItem() ISortItemContext { return s._sortItem }

func (s *QueryStatementContext) GetSliceField() IFieldIdentifierContext { return s.sliceField }

func (s *QueryStatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *QueryStatementContext) SetFront(v IStrictIdentifierContext) { s.front = v }

func (s *QueryStatementContext) SetKeep(v IStrContext) { s.keep = v }

func (s *QueryStatementContext) SetScore(v IBooleanValueContext) { s.score = v }

func (s *QueryStatementContext) SetMinScore(v INumberContext) { s.minScore = v }

func (s *QueryStatementContext) Set_selectItem(v ISelectItemContext) { s._selectItem = v }

func (s *QueryStatementContext) Set_indexIdentifier(v IIndexIdentifierContext) {
	s._indexIdentifier = v
}

func (s *QueryStatementContext) Set_sortItem(v ISortItemContext) { s._sortItem = v }

func (s *QueryStatementContext) SetSliceField(v IFieldIdentifierContext) { s.sliceField = v }

func (s *QueryStatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *QueryStatementContext) GetSelectItems() []ISelectItemContext { return s.selectItems }

func (s *QueryStatementContext) GetIndexes() []IIndexIdentifierContext { return s.indexes }

func (s *QueryStatementContext) GetSorts() []ISortItemContext { return s.sorts }

func (s *QueryStatementContext) SetSelectItems(v []ISelectItemContext) { s.selectItems = v }

func (s *QueryStatementContext) SetIndexes(v []IIndexIdentifierContext) { s.indexes = v }

func (s *QueryStatementContext) SetSorts(v []ISortItemContext) { s.sorts = v }

func (s *QueryStatementContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSELECT, 0)
}

func (s *QueryStatementContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryStatementContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QueryStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUSING, 0)
}

func (s *QueryStatementContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *QueryStatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *QueryStatementContext) AllStrictIdentifier() []IStrictIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IStrictIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrictIdentifierContext); ok {
			tst[i] = t.(IStrictIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QueryStatementContext) StrictIdentifier(i int) IStrictIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *QueryStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *QueryStatementContext) SCROLL_ID() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSCROLL_ID, 0)
}

func (s *QueryStatementContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserEQ)
}

func (s *QueryStatementContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, i)
}

func (s *QueryStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFROM, 0)
}

func (s *QueryStatementContext) SCROLL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSCROLL, 0)
}

func (s *QueryStatementContext) SCORE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSCORE, 0)
}

func (s *QueryStatementContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *QueryStatementContext) AllIndexIdentifier() []IIndexIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIndexIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexIdentifierContext); ok {
			tst[i] = t.(IIndexIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QueryStatementContext) IndexIdentifier(i int) IIndexIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexIdentifierContext)
}

func (s *QueryStatementContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *QueryStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWHERE, 0)
}

func (s *QueryStatementContext) WhereExpression() IWhereExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *QueryStatementContext) RescoreExpr() IRescoreExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRescoreExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRescoreExprContext)
}

func (s *QueryStatementContext) CollapseExpr() ICollapseExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollapseExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollapseExprContext)
}

func (s *QueryStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserORDER, 0)
}

func (s *QueryStatementContext) TRACK_HIT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTRACK_HIT, 0)
}

func (s *QueryStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIMIT, 0)
}

func (s *QueryStatementContext) SLICE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSLICE, 0)
}

func (s *QueryStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryStatementContext) AllLONG() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserLONG)
}

func (s *QueryStatementContext) LONG(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, i)
}

func (s *QueryStatementContext) GE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserGE, 0)
}

func (s *QueryStatementContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *QueryStatementContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *QueryStatementContext) CustomScoreExpr() ICustomScoreExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomScoreExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomScoreExprContext)
}

func (s *QueryStatementContext) MemSort() IMemSortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemSortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemSortContext)
}

func (s *QueryStatementContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

func (s *QueryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitQueryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) QueryStatement() (localctx IQueryStatementContext) {
	localctx = NewQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ElasticSQLParserRULE_queryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserUSING {
		{
			p.SetState(218)
			p.Match(ElasticSQLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(219)

			var _x = p.StrictIdentifier()

			localctx.(*QueryStatementContext).front = _x
		}

	}
	{
		p.SetState(222)
		p.Match(ElasticSQLParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__1 {
		{
			p.SetState(223)
			p.Match(ElasticSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserSCROLL {
			{
				p.SetState(224)
				p.Match(ElasticSQLParserSCROLL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(225)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(226)

				var _x = p.Str()

				localctx.(*QueryStatementContext).keep = _x
			}

		}
		p.SetState(236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserSCORE {
			{
				p.SetState(229)
				p.Match(ElasticSQLParserSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(234)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case ElasticSQLParserEQ:
				{
					p.SetState(230)
					p.Match(ElasticSQLParserEQ)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(231)

					var _x = p.BooleanValue()

					localctx.(*QueryStatementContext).score = _x
				}

			case ElasticSQLParserGE:
				{
					p.SetState(232)
					p.Match(ElasticSQLParserGE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(233)

					var _x = p.Number()

					localctx.(*QueryStatementContext).minScore = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		{
			p.SetState(238)
			p.Match(ElasticSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(241)

		var _x = p.SelectItem()

		localctx.(*QueryStatementContext)._selectItem = _x
	}
	localctx.(*QueryStatementContext).selectItems = append(localctx.(*QueryStatementContext).selectItems, localctx.(*QueryStatementContext)._selectItem)
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3562272993694121936) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-513428087574497293) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&1116914692957083861) != 0) {
		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserT__3 {
			{
				p.SetState(242)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(245)

			var _x = p.SelectItem()

			localctx.(*QueryStatementContext)._selectItem = _x
		}
		localctx.(*QueryStatementContext).selectItems = append(localctx.(*QueryStatementContext).selectItems, localctx.(*QueryStatementContext)._selectItem)

		p.SetState(250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.SetState(255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserBY {
			{
				p.SetState(251)
				p.Match(ElasticSQLParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(252)
				p.Match(ElasticSQLParserSCROLL_ID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(253)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(254)

				var _m = p.Match(ElasticSQLParserQUOTASTR)

				localctx.(*QueryStatementContext).scroll_id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.SetState(318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserFROM {
			{
				p.SetState(257)
				p.Match(ElasticSQLParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(258)

				var _x = p.IndexIdentifier()

				localctx.(*QueryStatementContext)._indexIdentifier = _x
			}
			localctx.(*QueryStatementContext).indexes = append(localctx.(*QueryStatementContext).indexes, localctx.(*QueryStatementContext)._indexIdentifier)
			p.SetState(263)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ElasticSQLParserT__3 {
				{
					p.SetState(259)
					p.Match(ElasticSQLParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(260)

					var _x = p.IndexIdentifier()

					localctx.(*QueryStatementContext)._indexIdentifier = _x
				}
				localctx.(*QueryStatementContext).indexes = append(localctx.(*QueryStatementContext).indexes, localctx.(*QueryStatementContext)._indexIdentifier)

				p.SetState(265)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(271)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserWHERE {
				{
					p.SetState(266)
					p.Match(ElasticSQLParserWHERE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(267)
					p.WhereExpression()
				}
				p.SetState(269)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == ElasticSQLParserCUSTOM_SCORE {
					{
						p.SetState(268)
						p.CustomScoreExpr()
					}

				}

			}
			p.SetState(274)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserRESCORE {
				{
					p.SetState(273)
					p.RescoreExpr()
				}

			}
			p.SetState(277)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserCOLLAPSE {
				{
					p.SetState(276)
					p.CollapseExpr()
				}

			}
			p.SetState(289)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserORDER {
				{
					p.SetState(279)
					p.Match(ElasticSQLParserORDER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(280)
					p.Match(ElasticSQLParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(281)

					var _x = p.SortItem()

					localctx.(*QueryStatementContext)._sortItem = _x
				}
				localctx.(*QueryStatementContext).sorts = append(localctx.(*QueryStatementContext).sorts, localctx.(*QueryStatementContext)._sortItem)
				p.SetState(286)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ElasticSQLParserT__3 {
					{
						p.SetState(282)
						p.Match(ElasticSQLParserT__3)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(283)

						var _x = p.SortItem()

						localctx.(*QueryStatementContext)._sortItem = _x
					}
					localctx.(*QueryStatementContext).sorts = append(localctx.(*QueryStatementContext).sorts, localctx.(*QueryStatementContext)._sortItem)

					p.SetState(288)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			}
			p.SetState(293)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserTRACK_HIT {
				{
					p.SetState(291)
					p.Match(ElasticSQLParserTRACK_HIT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(292)

					var _m = p.Match(ElasticSQLParserLONG)

					localctx.(*QueryStatementContext).track = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(304)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserLIMIT {
				{
					p.SetState(295)
					p.Match(ElasticSQLParserLIMIT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(298)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(296)

						var _m = p.Match(ElasticSQLParserLONG)

						localctx.(*QueryStatementContext).offset = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(297)
						p.Match(ElasticSQLParserT__3)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				{
					p.SetState(300)

					var _m = p.Match(ElasticSQLParserLONG)

					localctx.(*QueryStatementContext).limit = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(302)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == ElasticSQLParserMEM_SORT {
					{
						p.SetState(301)
						p.MemSort()
					}

				}

			}
			p.SetState(316)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserSLICE {
				{
					p.SetState(306)
					p.Match(ElasticSQLParserSLICE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(314)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == ElasticSQLParserT__4 {
					{
						p.SetState(307)
						p.Match(ElasticSQLParserT__4)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(308)

						var _m = p.Match(ElasticSQLParserLONG)

						localctx.(*QueryStatementContext).sliceMax = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(311)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == ElasticSQLParserT__3 {
						{
							p.SetState(309)
							p.Match(ElasticSQLParserT__3)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(310)

							var _x = p.FieldIdentifier()

							localctx.(*QueryStatementContext).sliceField = _x
						}

					}
					{
						p.SetState(313)
						p.Match(ElasticSQLParserT__5)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(322)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(323)

			var _x = p.StrictIdentifier()

			localctx.(*QueryStatementContext).statName = _x
		}

	}
	p.SetState(327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserEXPORT {
		{
			p.SetState(326)
			p.ExportStatement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext
	Highlight() IHighlightContext
	ScriptField() IScriptFieldContext
	InnerHit() IInnerHitContext

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *SelectItemContext) Highlight() IHighlightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHighlightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHighlightContext)
}

func (s *SelectItemContext) ScriptField() IScriptFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptFieldContext)
}

func (s *SelectItemContext) InnerHit() IInnerHitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerHitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerHitContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterSelectItem(s)
	}
}

func (s *SelectItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitSelectItem(s)
	}
}

func (s *SelectItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitSelectItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ElasticSQLParserRULE_selectItem)
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(329)
			p.FieldIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(330)
			p.Highlight()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(331)
			p.ScriptField()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(332)
			p.InnerHit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollapseExprContext is an interface to support dynamic dispatch.
type ICollapseExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// Getter signatures
	COLLAPSE() antlr.TerminalNode
	BY() antlr.TerminalNode
	FieldIdentifier() IFieldIdentifierContext

	// IsCollapseExprContext differentiates from other interfaces.
	IsCollapseExprContext()
}

type CollapseExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	field  IFieldIdentifierContext
}

func NewEmptyCollapseExprContext() *CollapseExprContext {
	var p = new(CollapseExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_collapseExpr
	return p
}

func InitEmptyCollapseExprContext(p *CollapseExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_collapseExpr
}

func (*CollapseExprContext) IsCollapseExprContext() {}

func NewCollapseExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollapseExprContext {
	var p = new(CollapseExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_collapseExpr

	return p
}

func (s *CollapseExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CollapseExprContext) GetField() IFieldIdentifierContext { return s.field }

func (s *CollapseExprContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *CollapseExprContext) COLLAPSE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCOLLAPSE, 0)
}

func (s *CollapseExprContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *CollapseExprContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *CollapseExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollapseExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollapseExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterCollapseExpr(s)
	}
}

func (s *CollapseExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitCollapseExpr(s)
	}
}

func (s *CollapseExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitCollapseExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) CollapseExpr() (localctx ICollapseExprContext) {
	localctx = NewCollapseExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ElasticSQLParserRULE_collapseExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)
		p.Match(ElasticSQLParserCOLLAPSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(336)
		p.Match(ElasticSQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(337)

		var _x = p.FieldIdentifier()

		localctx.(*CollapseExprContext).field = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICustomScoreExprContext is an interface to support dynamic dispatch.
type ICustomScoreExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CUSTOM_SCORE() antlr.TerminalNode
	ScriptPhrase() IScriptPhraseContext

	// IsCustomScoreExprContext differentiates from other interfaces.
	IsCustomScoreExprContext()
}

type CustomScoreExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomScoreExprContext() *CustomScoreExprContext {
	var p = new(CustomScoreExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_customScoreExpr
	return p
}

func InitEmptyCustomScoreExprContext(p *CustomScoreExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_customScoreExpr
}

func (*CustomScoreExprContext) IsCustomScoreExprContext() {}

func NewCustomScoreExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomScoreExprContext {
	var p = new(CustomScoreExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_customScoreExpr

	return p
}

func (s *CustomScoreExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomScoreExprContext) CUSTOM_SCORE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCUSTOM_SCORE, 0)
}

func (s *CustomScoreExprContext) ScriptPhrase() IScriptPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptPhraseContext)
}

func (s *CustomScoreExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomScoreExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomScoreExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterCustomScoreExpr(s)
	}
}

func (s *CustomScoreExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitCustomScoreExpr(s)
	}
}

func (s *CustomScoreExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitCustomScoreExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) CustomScoreExpr() (localctx ICustomScoreExprContext) {
	localctx = NewCustomScoreExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ElasticSQLParserRULE_customScoreExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(339)
		p.Match(ElasticSQLParserCUSTOM_SCORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(340)
		p.ScriptPhrase()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRescoreExprContext is an interface to support dynamic dispatch.
type IRescoreExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWin returns the win token.
	GetWin() antlr.Token

	// GetPre returns the pre token.
	GetPre() antlr.Token

	// GetSec returns the sec token.
	GetSec() antlr.Token

	// SetWin sets the win token.
	SetWin(antlr.Token)

	// SetPre sets the pre token.
	SetPre(antlr.Token)

	// SetSec sets the sec token.
	SetSec(antlr.Token)

	// Getter signatures
	RESCORE() antlr.TerminalNode
	WhereExpression() IWhereExpressionContext
	WINDOWS() antlr.TerminalNode
	EQ() antlr.TerminalNode
	WEIGHT() antlr.TerminalNode
	LONG() antlr.TerminalNode
	AllDOUBLE() []antlr.TerminalNode
	DOUBLE(i int) antlr.TerminalNode

	// IsRescoreExprContext differentiates from other interfaces.
	IsRescoreExprContext()
}

type RescoreExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	win    antlr.Token
	pre    antlr.Token
	sec    antlr.Token
}

func NewEmptyRescoreExprContext() *RescoreExprContext {
	var p = new(RescoreExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rescoreExpr
	return p
}

func InitEmptyRescoreExprContext(p *RescoreExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rescoreExpr
}

func (*RescoreExprContext) IsRescoreExprContext() {}

func NewRescoreExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RescoreExprContext {
	var p = new(RescoreExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_rescoreExpr

	return p
}

func (s *RescoreExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RescoreExprContext) GetWin() antlr.Token { return s.win }

func (s *RescoreExprContext) GetPre() antlr.Token { return s.pre }

func (s *RescoreExprContext) GetSec() antlr.Token { return s.sec }

func (s *RescoreExprContext) SetWin(v antlr.Token) { s.win = v }

func (s *RescoreExprContext) SetPre(v antlr.Token) { s.pre = v }

func (s *RescoreExprContext) SetSec(v antlr.Token) { s.sec = v }

func (s *RescoreExprContext) RESCORE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRESCORE, 0)
}

func (s *RescoreExprContext) WhereExpression() IWhereExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *RescoreExprContext) WINDOWS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWINDOWS, 0)
}

func (s *RescoreExprContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *RescoreExprContext) WEIGHT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWEIGHT, 0)
}

func (s *RescoreExprContext) LONG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, 0)
}

func (s *RescoreExprContext) AllDOUBLE() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserDOUBLE)
}

func (s *RescoreExprContext) DOUBLE(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOUBLE, i)
}

func (s *RescoreExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RescoreExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RescoreExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterRescoreExpr(s)
	}
}

func (s *RescoreExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitRescoreExpr(s)
	}
}

func (s *RescoreExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitRescoreExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) RescoreExpr() (localctx IRescoreExprContext) {
	localctx = NewRescoreExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ElasticSQLParserRULE_rescoreExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(342)
		p.Match(ElasticSQLParserRESCORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(343)
			p.Match(ElasticSQLParserWINDOWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(344)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(345)

			var _m = p.Match(ElasticSQLParserLONG)

			localctx.(*RescoreExprContext).win = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserWEIGHT {
		{
			p.SetState(348)
			p.Match(ElasticSQLParserWEIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(349)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(350)

			var _m = p.Match(ElasticSQLParserDOUBLE)

			localctx.(*RescoreExprContext).pre = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(351)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(352)

			var _m = p.Match(ElasticSQLParserDOUBLE)

			localctx.(*RescoreExprContext).sec = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(353)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(356)
		p.WhereExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemSortContext is an interface to support dynamic dispatch.
type IMemSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSize returns the size token.
	GetSize() antlr.Token

	// SetSize sets the size token.
	SetSize(antlr.Token)

	// Get_sortItem returns the _sortItem rule contexts.
	Get_sortItem() ISortItemContext

	// Set_sortItem sets the _sortItem rule contexts.
	Set_sortItem(ISortItemContext)

	// GetSorts returns the sorts rule context list.
	GetSorts() []ISortItemContext

	// SetSorts sets the sorts rule context list.
	SetSorts([]ISortItemContext)

	// Getter signatures
	MEM_SORT() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	KEEP() antlr.TerminalNode
	LONG() antlr.TerminalNode

	// IsMemSortContext differentiates from other interfaces.
	IsMemSortContext()
}

type MemSortContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	_sortItem ISortItemContext
	sorts     []ISortItemContext
	size      antlr.Token
}

func NewEmptyMemSortContext() *MemSortContext {
	var p = new(MemSortContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_memSort
	return p
}

func InitEmptyMemSortContext(p *MemSortContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_memSort
}

func (*MemSortContext) IsMemSortContext() {}

func NewMemSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemSortContext {
	var p = new(MemSortContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_memSort

	return p
}

func (s *MemSortContext) GetParser() antlr.Parser { return s.parser }

func (s *MemSortContext) GetSize() antlr.Token { return s.size }

func (s *MemSortContext) SetSize(v antlr.Token) { s.size = v }

func (s *MemSortContext) Get_sortItem() ISortItemContext { return s._sortItem }

func (s *MemSortContext) Set_sortItem(v ISortItemContext) { s._sortItem = v }

func (s *MemSortContext) GetSorts() []ISortItemContext { return s.sorts }

func (s *MemSortContext) SetSorts(v []ISortItemContext) { s.sorts = v }

func (s *MemSortContext) MEM_SORT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMEM_SORT, 0)
}

func (s *MemSortContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *MemSortContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *MemSortContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *MemSortContext) KEEP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserKEEP, 0)
}

func (s *MemSortContext) LONG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, 0)
}

func (s *MemSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterMemSort(s)
	}
}

func (s *MemSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitMemSort(s)
	}
}

func (s *MemSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitMemSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) MemSort() (localctx IMemSortContext) {
	localctx = NewMemSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ElasticSQLParserRULE_memSort)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(358)
		p.Match(ElasticSQLParserMEM_SORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(359)
		p.Match(ElasticSQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(360)

		var _x = p.SortItem()

		localctx.(*MemSortContext)._sortItem = _x
	}
	localctx.(*MemSortContext).sorts = append(localctx.(*MemSortContext).sorts, localctx.(*MemSortContext)._sortItem)
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(361)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(362)

			var _x = p.SortItem()

			localctx.(*MemSortContext)._sortItem = _x
		}
		localctx.(*MemSortContext).sorts = append(localctx.(*MemSortContext).sorts, localctx.(*MemSortContext)._sortItem)

		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserKEEP {
		{
			p.SetState(368)
			p.Match(ElasticSQLParserKEEP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(369)

			var _m = p.Match(ElasticSQLParserLONG)

			localctx.(*MemSortContext).size = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInnerHitContext is an interface to support dynamic dispatch.
type IInnerHitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_prop returns the _prop rule contexts.
	Get_prop() IPropContext

	// GetAs returns the as rule contexts.
	GetAs() IStrictIdentifierContext

	// Set_prop sets the _prop rule contexts.
	Set_prop(IPropContext)

	// SetAs sets the as rule contexts.
	SetAs(IStrictIdentifierContext)

	// GetProps returns the props rule context list.
	GetProps() []IPropContext

	// SetProps sets the props rule context list.
	SetProps([]IPropContext)

	// Getter signatures
	INNER_HIT() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllProp() []IPropContext
	Prop(i int) IPropContext
	StrictIdentifier() IStrictIdentifierContext

	// IsInnerHitContext differentiates from other interfaces.
	IsInnerHitContext()
}

type InnerHitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_prop  IPropContext
	props  []IPropContext
	as     IStrictIdentifierContext
}

func NewEmptyInnerHitContext() *InnerHitContext {
	var p = new(InnerHitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_innerHit
	return p
}

func InitEmptyInnerHitContext(p *InnerHitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_innerHit
}

func (*InnerHitContext) IsInnerHitContext() {}

func NewInnerHitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerHitContext {
	var p = new(InnerHitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_innerHit

	return p
}

func (s *InnerHitContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerHitContext) Get_prop() IPropContext { return s._prop }

func (s *InnerHitContext) GetAs() IStrictIdentifierContext { return s.as }

func (s *InnerHitContext) Set_prop(v IPropContext) { s._prop = v }

func (s *InnerHitContext) SetAs(v IStrictIdentifierContext) { s.as = v }

func (s *InnerHitContext) GetProps() []IPropContext { return s.props }

func (s *InnerHitContext) SetProps(v []IPropContext) { s.props = v }

func (s *InnerHitContext) INNER_HIT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINNER_HIT, 0)
}

func (s *InnerHitContext) AS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAS, 0)
}

func (s *InnerHitContext) AllProp() []IPropContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropContext); ok {
			len++
		}
	}

	tst := make([]IPropContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropContext); ok {
			tst[i] = t.(IPropContext)
			i++
		}
	}

	return tst
}

func (s *InnerHitContext) Prop(i int) IPropContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropContext)
}

func (s *InnerHitContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *InnerHitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerHitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerHitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterInnerHit(s)
	}
}

func (s *InnerHitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitInnerHit(s)
	}
}

func (s *InnerHitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitInnerHit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) InnerHit() (localctx IInnerHitContext) {
	localctx = NewInnerHitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ElasticSQLParserRULE_innerHit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Match(ElasticSQLParserINNER_HIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(373)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(374)

		var _x = p.Prop()

		localctx.(*InnerHitContext)._prop = _x
	}
	localctx.(*InnerHitContext).props = append(localctx.(*InnerHitContext).props, localctx.(*InnerHitContext)._prop)
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(375)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(376)

			var _x = p.Prop()

			localctx.(*InnerHitContext)._prop = _x
		}
		localctx.(*InnerHitContext).props = append(localctx.(*InnerHitContext).props, localctx.(*InnerHitContext)._prop)

		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(382)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(383)
		p.Match(ElasticSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(384)

		var _x = p.StrictIdentifier()

		localctx.(*InnerHitContext).as = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScriptFieldContext is an interface to support dynamic dispatch.
type IScriptFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetScript returns the script rule contexts.
	GetScript() IScriptPhraseContext

	// GetAs returns the as rule contexts.
	GetAs() IStrictIdentifierContext

	// SetScript sets the script rule contexts.
	SetScript(IScriptPhraseContext)

	// SetAs sets the as rule contexts.
	SetAs(IStrictIdentifierContext)

	// Getter signatures
	AS() antlr.TerminalNode
	ScriptPhrase() IScriptPhraseContext
	StrictIdentifier() IStrictIdentifierContext

	// IsScriptFieldContext differentiates from other interfaces.
	IsScriptFieldContext()
}

type ScriptFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	script IScriptPhraseContext
	as     IStrictIdentifierContext
}

func NewEmptyScriptFieldContext() *ScriptFieldContext {
	var p = new(ScriptFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_scriptField
	return p
}

func InitEmptyScriptFieldContext(p *ScriptFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_scriptField
}

func (*ScriptFieldContext) IsScriptFieldContext() {}

func NewScriptFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptFieldContext {
	var p = new(ScriptFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_scriptField

	return p
}

func (s *ScriptFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptFieldContext) GetScript() IScriptPhraseContext { return s.script }

func (s *ScriptFieldContext) GetAs() IStrictIdentifierContext { return s.as }

func (s *ScriptFieldContext) SetScript(v IScriptPhraseContext) { s.script = v }

func (s *ScriptFieldContext) SetAs(v IStrictIdentifierContext) { s.as = v }

func (s *ScriptFieldContext) AS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAS, 0)
}

func (s *ScriptFieldContext) ScriptPhrase() IScriptPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptPhraseContext)
}

func (s *ScriptFieldContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *ScriptFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterScriptField(s)
	}
}

func (s *ScriptFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitScriptField(s)
	}
}

func (s *ScriptFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitScriptField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ScriptField() (localctx IScriptFieldContext) {
	localctx = NewScriptFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ElasticSQLParserRULE_scriptField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)

		var _x = p.ScriptPhrase()

		localctx.(*ScriptFieldContext).script = _x
	}
	{
		p.SetState(387)
		p.Match(ElasticSQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(388)

		var _x = p.StrictIdentifier()

		localctx.(*ScriptFieldContext).as = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHighlightContext is an interface to support dynamic dispatch.
type IHighlightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTag returns the tag token.
	GetTag() antlr.Token

	// SetTag sets the tag token.
	SetTag(antlr.Token)

	// Getter signatures
	HIGHLIGHT() antlr.TerminalNode
	AllFieldAs() []IFieldAsContext
	FieldAs(i int) IFieldAsContext
	BY() antlr.TerminalNode
	QUOTASTR() antlr.TerminalNode

	// IsHighlightContext differentiates from other interfaces.
	IsHighlightContext()
}

type HighlightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tag    antlr.Token
}

func NewEmptyHighlightContext() *HighlightContext {
	var p = new(HighlightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_highlight
	return p
}

func InitEmptyHighlightContext(p *HighlightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_highlight
}

func (*HighlightContext) IsHighlightContext() {}

func NewHighlightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HighlightContext {
	var p = new(HighlightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_highlight

	return p
}

func (s *HighlightContext) GetParser() antlr.Parser { return s.parser }

func (s *HighlightContext) GetTag() antlr.Token { return s.tag }

func (s *HighlightContext) SetTag(v antlr.Token) { s.tag = v }

func (s *HighlightContext) HIGHLIGHT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHIGHLIGHT, 0)
}

func (s *HighlightContext) AllFieldAs() []IFieldAsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldAsContext); ok {
			len++
		}
	}

	tst := make([]IFieldAsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldAsContext); ok {
			tst[i] = t.(IFieldAsContext)
			i++
		}
	}

	return tst
}

func (s *HighlightContext) FieldAs(i int) IFieldAsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldAsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldAsContext)
}

func (s *HighlightContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *HighlightContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *HighlightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HighlightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HighlightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterHighlight(s)
	}
}

func (s *HighlightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitHighlight(s)
	}
}

func (s *HighlightContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitHighlight(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Highlight() (localctx IHighlightContext) {
	localctx = NewHighlightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ElasticSQLParserRULE_highlight)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(390)
		p.Match(ElasticSQLParserHIGHLIGHT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(391)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(392)
		p.FieldAs()
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(393)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(394)
			p.FieldAs()
		}

		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(400)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(403)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(401)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(402)

			var _m = p.Match(ElasticSQLParserQUOTASTR)

			localctx.(*HighlightContext).tag = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldAsContext is an interface to support dynamic dispatch.
type IFieldAsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTag returns the tag token.
	GetTag() antlr.Token

	// SetTag sets the tag token.
	SetTag(antlr.Token)

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetAs returns the as rule contexts.
	GetAs() IStrictIdentifierContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetAs sets the as rule contexts.
	SetAs(IStrictIdentifierContext)

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext
	BY() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext
	QUOTASTR() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsFieldAsContext differentiates from other interfaces.
	IsFieldAsContext()
}

type FieldAsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	field  IFieldIdentifierContext
	as     IStrictIdentifierContext
	tag    antlr.Token
}

func NewEmptyFieldAsContext() *FieldAsContext {
	var p = new(FieldAsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fieldAs
	return p
}

func InitEmptyFieldAsContext(p *FieldAsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fieldAs
}

func (*FieldAsContext) IsFieldAsContext() {}

func NewFieldAsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldAsContext {
	var p = new(FieldAsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_fieldAs

	return p
}

func (s *FieldAsContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldAsContext) GetTag() antlr.Token { return s.tag }

func (s *FieldAsContext) SetTag(v antlr.Token) { s.tag = v }

func (s *FieldAsContext) GetField() IFieldIdentifierContext { return s.field }

func (s *FieldAsContext) GetAs() IStrictIdentifierContext { return s.as }

func (s *FieldAsContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *FieldAsContext) SetAs(v IStrictIdentifierContext) { s.as = v }

func (s *FieldAsContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *FieldAsContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *FieldAsContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *FieldAsContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *FieldAsContext) AS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAS, 0)
}

func (s *FieldAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldAsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterFieldAs(s)
	}
}

func (s *FieldAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitFieldAs(s)
	}
}

func (s *FieldAsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitFieldAs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) FieldAs() (localctx IFieldAsContext) {
	localctx = NewFieldAsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ElasticSQLParserRULE_fieldAs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)

		var _x = p.FieldIdentifier()

		localctx.(*FieldAsContext).field = _x
	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3562264197601165312) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-513428087574497293) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&288234769334409429) != 0) {
		p.SetState(407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserAS {
			{
				p.SetState(406)
				p.Match(ElasticSQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(409)

			var _x = p.StrictIdentifier()

			localctx.(*FieldAsContext).as = _x
		}

	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserBY {
		{
			p.SetState(412)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(413)

			var _m = p.Match(ElasticSQLParserQUOTASTR)

			localctx.(*FieldAsContext).tag = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereExpressionContext is an interface to support dynamic dispatch.
type IWhereExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetScore returns the score rule contexts.
	GetScore() IBooleanValueContext

	// SetScore sets the score rule contexts.
	SetScore(IBooleanValueContext)

	// Getter signatures
	ALL() antlr.TerminalNode
	LogicalExpr() ILogicalExprContext
	SCORE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	BooleanValue() IBooleanValueContext
	AND() antlr.TerminalNode

	// IsWhereExpressionContext differentiates from other interfaces.
	IsWhereExpressionContext()
}

type WhereExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	score  IBooleanValueContext
}

func NewEmptyWhereExpressionContext() *WhereExpressionContext {
	var p = new(WhereExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_whereExpression
	return p
}

func InitEmptyWhereExpressionContext(p *WhereExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_whereExpression
}

func (*WhereExpressionContext) IsWhereExpressionContext() {}

func NewWhereExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereExpressionContext {
	var p = new(WhereExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_whereExpression

	return p
}

func (s *WhereExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereExpressionContext) GetScore() IBooleanValueContext { return s.score }

func (s *WhereExpressionContext) SetScore(v IBooleanValueContext) { s.score = v }

func (s *WhereExpressionContext) ALL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserALL, 0)
}

func (s *WhereExpressionContext) LogicalExpr() ILogicalExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExprContext)
}

func (s *WhereExpressionContext) SCORE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSCORE, 0)
}

func (s *WhereExpressionContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *WhereExpressionContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXPLAIN, 0)
}

func (s *WhereExpressionContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *WhereExpressionContext) AND() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAND, 0)
}

func (s *WhereExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterWhereExpression(s)
	}
}

func (s *WhereExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitWhereExpression(s)
	}
}

func (s *WhereExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitWhereExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) WhereExpression() (localctx IWhereExpressionContext) {
	localctx = NewWhereExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ElasticSQLParserRULE_whereExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__1 {
		{
			p.SetState(416)
			p.Match(ElasticSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserEXPLAIN {
			{
				p.SetState(417)
				p.Match(ElasticSQLParserEXPLAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(420)
			p.Match(ElasticSQLParserSCORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(421)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(422)

			var _x = p.BooleanValue()

			localctx.(*WhereExpressionContext).score = _x
		}

		{
			p.SetState(424)
			p.Match(ElasticSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(432)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(428)
			p.Match(ElasticSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserAND {
			{
				p.SetState(429)
				p.Match(ElasticSQLParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(434)
			p.logicalExpr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalExprContext is an interface to support dynamic dispatch.
type ILogicalExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNot returns the not token.
	GetNot() antlr.Token

	// GetOperator returns the operator token.
	GetOperator() antlr.Token

	// SetNot sets the not token.
	SetNot(antlr.Token)

	// SetOperator sets the operator token.
	SetOperator(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalExprContext

	// GetInner returns the inner rule contexts.
	GetInner() ILogicalExprContext

	// GetRight returns the right rule contexts.
	GetRight() ILogicalExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalExprContext)

	// SetInner sets the inner rule contexts.
	SetInner(ILogicalExprContext)

	// SetRight sets the right rule contexts.
	SetRight(ILogicalExprContext)

	// Getter signatures
	ComparableExpression() IComparableExpressionContext
	AllLogicalExpr() []ILogicalExprContext
	LogicalExpr(i int) ILogicalExprContext
	NOT() antlr.TerminalNode
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsLogicalExprContext differentiates from other interfaces.
	IsLogicalExprContext()
}

type LogicalExprContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	left     ILogicalExprContext
	not      antlr.Token
	inner    ILogicalExprContext
	operator antlr.Token
	right    ILogicalExprContext
}

func NewEmptyLogicalExprContext() *LogicalExprContext {
	var p = new(LogicalExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_logicalExpr
	return p
}

func InitEmptyLogicalExprContext(p *LogicalExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_logicalExpr
}

func (*LogicalExprContext) IsLogicalExprContext() {}

func NewLogicalExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalExprContext {
	var p = new(LogicalExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_logicalExpr

	return p
}

func (s *LogicalExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalExprContext) GetNot() antlr.Token { return s.not }

func (s *LogicalExprContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalExprContext) SetNot(v antlr.Token) { s.not = v }

func (s *LogicalExprContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalExprContext) GetLeft() ILogicalExprContext { return s.left }

func (s *LogicalExprContext) GetInner() ILogicalExprContext { return s.inner }

func (s *LogicalExprContext) GetRight() ILogicalExprContext { return s.right }

func (s *LogicalExprContext) SetLeft(v ILogicalExprContext) { s.left = v }

func (s *LogicalExprContext) SetInner(v ILogicalExprContext) { s.inner = v }

func (s *LogicalExprContext) SetRight(v ILogicalExprContext) { s.right = v }

func (s *LogicalExprContext) ComparableExpression() IComparableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparableExpressionContext)
}

func (s *LogicalExprContext) AllLogicalExpr() []ILogicalExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogicalExprContext); ok {
			len++
		}
	}

	tst := make([]ILogicalExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogicalExprContext); ok {
			tst[i] = t.(ILogicalExprContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExprContext) LogicalExpr(i int) ILogicalExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExprContext)
}

func (s *LogicalExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNOT, 0)
}

func (s *LogicalExprContext) AND() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAND, 0)
}

func (s *LogicalExprContext) OR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserOR, 0)
}

func (s *LogicalExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterLogicalExpr(s)
	}
}

func (s *LogicalExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitLogicalExpr(s)
	}
}

func (s *LogicalExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitLogicalExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) LogicalExpr() (localctx ILogicalExprContext) {
	return p.logicalExpr(0)
}

func (p *ElasticSQLParser) logicalExpr(_p int) (localctx ILogicalExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogicalExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogicalExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 26
	p.EnterRecursionRule(localctx, 26, ElasticSQLParserRULE_logicalExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(438)
			p.ComparableExpression()
		}

	case 2:
		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserNOT {
			{
				p.SetState(439)

				var _m = p.Match(ElasticSQLParserNOT)

				localctx.(*LogicalExprContext).not = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(442)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(443)

			var _x = p.logicalExpr(0)

			localctx.(*LogicalExprContext).inner = _x
		}
		{
			p.SetState(444)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(454)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalExprContext(p, _parentctx, _parentState)
				localctx.(*LogicalExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ElasticSQLParserRULE_logicalExpr)
				p.SetState(448)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(449)

					var _m = p.Match(ElasticSQLParserAND)

					localctx.(*LogicalExprContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(450)

					var _x = p.logicalExpr(3)

					localctx.(*LogicalExprContext).right = _x
				}

			case 2:
				localctx = NewLogicalExprContext(p, _parentctx, _parentState)
				localctx.(*LogicalExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ElasticSQLParserRULE_logicalExpr)
				p.SetState(451)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(452)

					var _m = p.Match(ElasticSQLParserOR)

					localctx.(*LogicalExprContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(453)

					var _x = p.logicalExpr(2)

					localctx.(*LogicalExprContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparableExpressionContext is an interface to support dynamic dispatch.
type IComparableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNot returns the not token.
	GetNot() antlr.Token

	// SetNot sets the not token.
	SetNot(antlr.Token)

	// GetTCmp returns the tCmp rule contexts.
	GetTCmp() ITermCompareContext

	// GetBtwCmp returns the btwCmp rule contexts.
	GetBtwCmp() IBtwCompareContext

	// GetFuncCmp returns the funcCmp rule contexts.
	GetFuncCmp() IFunctionalCompareContext

	// GetMathCmp returns the mathCmp rule contexts.
	GetMathCmp() IArithmeticExpressionCompareContext

	// SetTCmp sets the tCmp rule contexts.
	SetTCmp(ITermCompareContext)

	// SetBtwCmp sets the btwCmp rule contexts.
	SetBtwCmp(IBtwCompareContext)

	// SetFuncCmp sets the funcCmp rule contexts.
	SetFuncCmp(IFunctionalCompareContext)

	// SetMathCmp sets the mathCmp rule contexts.
	SetMathCmp(IArithmeticExpressionCompareContext)

	// Getter signatures
	TermCompare() ITermCompareContext
	BtwCompare() IBtwCompareContext
	FunctionalCompare() IFunctionalCompareContext
	ArithmeticExpressionCompare() IArithmeticExpressionCompareContext
	NOT() antlr.TerminalNode

	// IsComparableExpressionContext differentiates from other interfaces.
	IsComparableExpressionContext()
}

type ComparableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	not     antlr.Token
	tCmp    ITermCompareContext
	btwCmp  IBtwCompareContext
	funcCmp IFunctionalCompareContext
	mathCmp IArithmeticExpressionCompareContext
}

func NewEmptyComparableExpressionContext() *ComparableExpressionContext {
	var p = new(ComparableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_comparableExpression
	return p
}

func InitEmptyComparableExpressionContext(p *ComparableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_comparableExpression
}

func (*ComparableExpressionContext) IsComparableExpressionContext() {}

func NewComparableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparableExpressionContext {
	var p = new(ComparableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_comparableExpression

	return p
}

func (s *ComparableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparableExpressionContext) GetNot() antlr.Token { return s.not }

func (s *ComparableExpressionContext) SetNot(v antlr.Token) { s.not = v }

func (s *ComparableExpressionContext) GetTCmp() ITermCompareContext { return s.tCmp }

func (s *ComparableExpressionContext) GetBtwCmp() IBtwCompareContext { return s.btwCmp }

func (s *ComparableExpressionContext) GetFuncCmp() IFunctionalCompareContext { return s.funcCmp }

func (s *ComparableExpressionContext) GetMathCmp() IArithmeticExpressionCompareContext {
	return s.mathCmp
}

func (s *ComparableExpressionContext) SetTCmp(v ITermCompareContext) { s.tCmp = v }

func (s *ComparableExpressionContext) SetBtwCmp(v IBtwCompareContext) { s.btwCmp = v }

func (s *ComparableExpressionContext) SetFuncCmp(v IFunctionalCompareContext) { s.funcCmp = v }

func (s *ComparableExpressionContext) SetMathCmp(v IArithmeticExpressionCompareContext) {
	s.mathCmp = v
}

func (s *ComparableExpressionContext) TermCompare() ITermCompareContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermCompareContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermCompareContext)
}

func (s *ComparableExpressionContext) BtwCompare() IBtwCompareContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBtwCompareContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBtwCompareContext)
}

func (s *ComparableExpressionContext) FunctionalCompare() IFunctionalCompareContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionalCompareContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionalCompareContext)
}

func (s *ComparableExpressionContext) ArithmeticExpressionCompare() IArithmeticExpressionCompareContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionCompareContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionCompareContext)
}

func (s *ComparableExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNOT, 0)
}

func (s *ComparableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterComparableExpression(s)
	}
}

func (s *ComparableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitComparableExpression(s)
	}
}

func (s *ComparableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitComparableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ComparableExpression() (localctx IComparableExpressionContext) {
	localctx = NewComparableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ElasticSQLParserRULE_comparableExpression)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(460)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(459)

			var _m = p.Match(ElasticSQLParserNOT)

			localctx.(*ComparableExpressionContext).not = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(462)

			var _x = p.TermCompare()

			localctx.(*ComparableExpressionContext).tCmp = _x
		}

	case 2:
		{
			p.SetState(463)

			var _x = p.BtwCompare()

			localctx.(*ComparableExpressionContext).btwCmp = _x
		}

	case 3:
		{
			p.SetState(464)

			var _x = p.FunctionalCompare()

			localctx.(*ComparableExpressionContext).funcCmp = _x
		}

	case 4:
		{
			p.SetState(465)

			var _x = p.ArithmeticExpressionCompare()

			localctx.(*ComparableExpressionContext).mathCmp = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermCompareContext is an interface to support dynamic dispatch.
type ITermCompareContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetBoost returns the boost rule contexts.
	GetBoost() INumberContext

	// GetOperator returns the operator rule contexts.
	GetOperator() IComparisonOperatorContext

	// GetValue returns the value rule contexts.
	GetValue() IParamContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetBoost sets the boost rule contexts.
	SetBoost(INumberContext)

	// SetOperator sets the operator rule contexts.
	SetOperator(IComparisonOperatorContext)

	// SetValue sets the value rule contexts.
	SetValue(IParamContext)

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext
	ComparisonOperator() IComparisonOperatorContext
	Param() IParamContext
	POWER() antlr.TerminalNode
	Number() INumberContext

	// IsTermCompareContext differentiates from other interfaces.
	IsTermCompareContext()
}

type TermCompareContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	field    IFieldIdentifierContext
	boost    INumberContext
	operator IComparisonOperatorContext
	value    IParamContext
}

func NewEmptyTermCompareContext() *TermCompareContext {
	var p = new(TermCompareContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_termCompare
	return p
}

func InitEmptyTermCompareContext(p *TermCompareContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_termCompare
}

func (*TermCompareContext) IsTermCompareContext() {}

func NewTermCompareContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermCompareContext {
	var p = new(TermCompareContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_termCompare

	return p
}

func (s *TermCompareContext) GetParser() antlr.Parser { return s.parser }

func (s *TermCompareContext) GetField() IFieldIdentifierContext { return s.field }

func (s *TermCompareContext) GetBoost() INumberContext { return s.boost }

func (s *TermCompareContext) GetOperator() IComparisonOperatorContext { return s.operator }

func (s *TermCompareContext) GetValue() IParamContext { return s.value }

func (s *TermCompareContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *TermCompareContext) SetBoost(v INumberContext) { s.boost = v }

func (s *TermCompareContext) SetOperator(v IComparisonOperatorContext) { s.operator = v }

func (s *TermCompareContext) SetValue(v IParamContext) { s.value = v }

func (s *TermCompareContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *TermCompareContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *TermCompareContext) Param() IParamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *TermCompareContext) POWER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPOWER, 0)
}

func (s *TermCompareContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *TermCompareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermCompareContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermCompareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterTermCompare(s)
	}
}

func (s *TermCompareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitTermCompare(s)
	}
}

func (s *TermCompareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitTermCompare(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) TermCompare() (localctx ITermCompareContext) {
	localctx = NewTermCompareContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ElasticSQLParserRULE_termCompare)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(468)

		var _x = p.FieldIdentifier()

		localctx.(*TermCompareContext).field = _x
	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserPOWER {
		{
			p.SetState(469)
			p.Match(ElasticSQLParserPOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(470)

			var _x = p.Number()

			localctx.(*TermCompareContext).boost = _x
		}

	}
	{
		p.SetState(473)

		var _x = p.ComparisonOperator()

		localctx.(*TermCompareContext).operator = _x
	}
	{
		p.SetState(474)

		var _x = p.Param()

		localctx.(*TermCompareContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBtwCompareContext is an interface to support dynamic dispatch.
type IBtwCompareContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNot returns the not token.
	GetNot() antlr.Token

	// GetGte returns the gte token.
	GetGte() antlr.Token

	// GetLte returns the lte token.
	GetLte() antlr.Token

	// GetGt returns the gt token.
	GetGt() antlr.Token

	// GetLt returns the lt token.
	GetLt() antlr.Token

	// SetNot sets the not token.
	SetNot(antlr.Token)

	// SetGte sets the gte token.
	SetGte(antlr.Token)

	// SetLte sets the lte token.
	SetLte(antlr.Token)

	// SetGt sets the gt token.
	SetGt(antlr.Token)

	// SetLt sets the lt token.
	SetLt(antlr.Token)

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetA returns the a rule contexts.
	GetA() IParamContext

	// GetB returns the b rule contexts.
	GetB() IParamContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetA sets the a rule contexts.
	SetA(IParamContext)

	// SetB sets the b rule contexts.
	SetB(IParamContext)

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext
	NOT() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AllParam() []IParamContext
	Param(i int) IParamContext
	AND() antlr.TerminalNode

	// IsBtwCompareContext differentiates from other interfaces.
	IsBtwCompareContext()
}

type BtwCompareContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	field  IFieldIdentifierContext
	not    antlr.Token
	gte    antlr.Token
	a      IParamContext
	lte    antlr.Token
	b      IParamContext
	gt     antlr.Token
	lt     antlr.Token
}

func NewEmptyBtwCompareContext() *BtwCompareContext {
	var p = new(BtwCompareContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_btwCompare
	return p
}

func InitEmptyBtwCompareContext(p *BtwCompareContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_btwCompare
}

func (*BtwCompareContext) IsBtwCompareContext() {}

func NewBtwCompareContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BtwCompareContext {
	var p = new(BtwCompareContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_btwCompare

	return p
}

func (s *BtwCompareContext) GetParser() antlr.Parser { return s.parser }

func (s *BtwCompareContext) GetNot() antlr.Token { return s.not }

func (s *BtwCompareContext) GetGte() antlr.Token { return s.gte }

func (s *BtwCompareContext) GetLte() antlr.Token { return s.lte }

func (s *BtwCompareContext) GetGt() antlr.Token { return s.gt }

func (s *BtwCompareContext) GetLt() antlr.Token { return s.lt }

func (s *BtwCompareContext) SetNot(v antlr.Token) { s.not = v }

func (s *BtwCompareContext) SetGte(v antlr.Token) { s.gte = v }

func (s *BtwCompareContext) SetLte(v antlr.Token) { s.lte = v }

func (s *BtwCompareContext) SetGt(v antlr.Token) { s.gt = v }

func (s *BtwCompareContext) SetLt(v antlr.Token) { s.lt = v }

func (s *BtwCompareContext) GetField() IFieldIdentifierContext { return s.field }

func (s *BtwCompareContext) GetA() IParamContext { return s.a }

func (s *BtwCompareContext) GetB() IParamContext { return s.b }

func (s *BtwCompareContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *BtwCompareContext) SetA(v IParamContext) { s.a = v }

func (s *BtwCompareContext) SetB(v IParamContext) { s.b = v }

func (s *BtwCompareContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *BtwCompareContext) NOT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNOT, 0)
}

func (s *BtwCompareContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRANGE, 0)
}

func (s *BtwCompareContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBETWEEN, 0)
}

func (s *BtwCompareContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *BtwCompareContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *BtwCompareContext) AND() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAND, 0)
}

func (s *BtwCompareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BtwCompareContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BtwCompareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterBtwCompare(s)
	}
}

func (s *BtwCompareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitBtwCompare(s)
	}
}

func (s *BtwCompareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitBtwCompare(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) BtwCompare() (localctx IBtwCompareContext) {
	localctx = NewBtwCompareContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ElasticSQLParserRULE_btwCompare)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)

		var _x = p.FieldIdentifier()

		localctx.(*BtwCompareContext).field = _x
	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserNOT {
		{
			p.SetState(477)

			var _m = p.Match(ElasticSQLParserNOT)

			localctx.(*BtwCompareContext).not = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserBETWEEN:
		{
			p.SetState(480)

			var _m = p.Match(ElasticSQLParserBETWEEN)

			localctx.(*BtwCompareContext).gte = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(481)

			var _x = p.Param()

			localctx.(*BtwCompareContext).a = _x
		}
		{
			p.SetState(482)

			var _m = p.Match(ElasticSQLParserAND)

			localctx.(*BtwCompareContext).lte = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(483)

			var _x = p.Param()

			localctx.(*BtwCompareContext).b = _x
		}

	case ElasticSQLParserRANGE:
		{
			p.SetState(485)
			p.Match(ElasticSQLParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ElasticSQLParserT__6:
			{
				p.SetState(486)

				var _m = p.Match(ElasticSQLParserT__6)

				localctx.(*BtwCompareContext).gte = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case ElasticSQLParserT__4:
			{
				p.SetState(487)

				var _m = p.Match(ElasticSQLParserT__4)

				localctx.(*BtwCompareContext).gt = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(490)

			var _x = p.Param()

			localctx.(*BtwCompareContext).a = _x
		}
		{
			p.SetState(491)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(492)

			var _x = p.Param()

			localctx.(*BtwCompareContext).b = _x
		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ElasticSQLParserT__7:
			{
				p.SetState(493)

				var _m = p.Match(ElasticSQLParserT__7)

				localctx.(*BtwCompareContext).lte = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case ElasticSQLParserT__5:
			{
				p.SetState(494)

				var _m = p.Match(ElasticSQLParserT__5)

				localctx.(*BtwCompareContext).lt = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArithmeticExpressionCompareContext is an interface to support dynamic dispatch.
type IArithmeticExpressionCompareContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirst returns the first rule contexts.
	GetFirst() IArithmeticExpressionContext

	// GetOp returns the op rule contexts.
	GetOp() IComparisonOperatorContext

	// GetSecond returns the second rule contexts.
	GetSecond() IMultiplyingExpressionContext

	// SetFirst sets the first rule contexts.
	SetFirst(IArithmeticExpressionContext)

	// SetOp sets the op rule contexts.
	SetOp(IComparisonOperatorContext)

	// SetSecond sets the second rule contexts.
	SetSecond(IMultiplyingExpressionContext)

	// Getter signatures
	ArithmeticExpression() IArithmeticExpressionContext
	ComparisonOperator() IComparisonOperatorContext
	MultiplyingExpression() IMultiplyingExpressionContext

	// IsArithmeticExpressionCompareContext differentiates from other interfaces.
	IsArithmeticExpressionCompareContext()
}

type ArithmeticExpressionCompareContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	first  IArithmeticExpressionContext
	op     IComparisonOperatorContext
	second IMultiplyingExpressionContext
}

func NewEmptyArithmeticExpressionCompareContext() *ArithmeticExpressionCompareContext {
	var p = new(ArithmeticExpressionCompareContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_arithmeticExpressionCompare
	return p
}

func InitEmptyArithmeticExpressionCompareContext(p *ArithmeticExpressionCompareContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_arithmeticExpressionCompare
}

func (*ArithmeticExpressionCompareContext) IsArithmeticExpressionCompareContext() {}

func NewArithmeticExpressionCompareContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArithmeticExpressionCompareContext {
	var p = new(ArithmeticExpressionCompareContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_arithmeticExpressionCompare

	return p
}

func (s *ArithmeticExpressionCompareContext) GetParser() antlr.Parser { return s.parser }

func (s *ArithmeticExpressionCompareContext) GetFirst() IArithmeticExpressionContext { return s.first }

func (s *ArithmeticExpressionCompareContext) GetOp() IComparisonOperatorContext { return s.op }

func (s *ArithmeticExpressionCompareContext) GetSecond() IMultiplyingExpressionContext {
	return s.second
}

func (s *ArithmeticExpressionCompareContext) SetFirst(v IArithmeticExpressionContext) { s.first = v }

func (s *ArithmeticExpressionCompareContext) SetOp(v IComparisonOperatorContext) { s.op = v }

func (s *ArithmeticExpressionCompareContext) SetSecond(v IMultiplyingExpressionContext) { s.second = v }

func (s *ArithmeticExpressionCompareContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *ArithmeticExpressionCompareContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ArithmeticExpressionCompareContext) MultiplyingExpression() IMultiplyingExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyingExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyingExpressionContext)
}

func (s *ArithmeticExpressionCompareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticExpressionCompareContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArithmeticExpressionCompareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterArithmeticExpressionCompare(s)
	}
}

func (s *ArithmeticExpressionCompareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitArithmeticExpressionCompare(s)
	}
}

func (s *ArithmeticExpressionCompareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitArithmeticExpressionCompare(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ArithmeticExpressionCompare() (localctx IArithmeticExpressionCompareContext) {
	localctx = NewArithmeticExpressionCompareContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ElasticSQLParserRULE_arithmeticExpressionCompare)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)

		var _x = p.ArithmeticExpression()

		localctx.(*ArithmeticExpressionCompareContext).first = _x
	}
	{
		p.SetState(500)

		var _x = p.ComparisonOperator()

		localctx.(*ArithmeticExpressionCompareContext).op = _x
	}
	{
		p.SetState(501)

		var _x = p.MultiplyingExpression()

		localctx.(*ArithmeticExpressionCompareContext).second = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArithmeticExpressionContext is an interface to support dynamic dispatch.
type IArithmeticExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirst returns the first rule contexts.
	GetFirst() IMultiplyingExpressionContext

	// Get_addition returns the _addition rule contexts.
	Get_addition() IAdditionContext

	// SetFirst sets the first rule contexts.
	SetFirst(IMultiplyingExpressionContext)

	// Set_addition sets the _addition rule contexts.
	Set_addition(IAdditionContext)

	// GetRest returns the rest rule context list.
	GetRest() []IAdditionContext

	// SetRest sets the rest rule context list.
	SetRest([]IAdditionContext)

	// Getter signatures
	MultiplyingExpression() IMultiplyingExpressionContext
	AllAddition() []IAdditionContext
	Addition(i int) IAdditionContext

	// IsArithmeticExpressionContext differentiates from other interfaces.
	IsArithmeticExpressionContext()
}

type ArithmeticExpressionContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	first     IMultiplyingExpressionContext
	_addition IAdditionContext
	rest      []IAdditionContext
}

func NewEmptyArithmeticExpressionContext() *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_arithmeticExpression
	return p
}

func InitEmptyArithmeticExpressionContext(p *ArithmeticExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_arithmeticExpression
}

func (*ArithmeticExpressionContext) IsArithmeticExpressionContext() {}

func NewArithmeticExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_arithmeticExpression

	return p
}

func (s *ArithmeticExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArithmeticExpressionContext) GetFirst() IMultiplyingExpressionContext { return s.first }

func (s *ArithmeticExpressionContext) Get_addition() IAdditionContext { return s._addition }

func (s *ArithmeticExpressionContext) SetFirst(v IMultiplyingExpressionContext) { s.first = v }

func (s *ArithmeticExpressionContext) Set_addition(v IAdditionContext) { s._addition = v }

func (s *ArithmeticExpressionContext) GetRest() []IAdditionContext { return s.rest }

func (s *ArithmeticExpressionContext) SetRest(v []IAdditionContext) { s.rest = v }

func (s *ArithmeticExpressionContext) MultiplyingExpression() IMultiplyingExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyingExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyingExpressionContext)
}

func (s *ArithmeticExpressionContext) AllAddition() []IAdditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditionContext); ok {
			len++
		}
	}

	tst := make([]IAdditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditionContext); ok {
			tst[i] = t.(IAdditionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticExpressionContext) Addition(i int) IAdditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditionContext)
}

func (s *ArithmeticExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArithmeticExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterArithmeticExpression(s)
	}
}

func (s *ArithmeticExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitArithmeticExpression(s)
	}
}

func (s *ArithmeticExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitArithmeticExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ArithmeticExpression() (localctx IArithmeticExpressionContext) {
	localctx = NewArithmeticExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ElasticSQLParserRULE_arithmeticExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)

		var _x = p.MultiplyingExpression()

		localctx.(*ArithmeticExpressionContext).first = _x
	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(504)

				var _x = p.Addition()

				localctx.(*ArithmeticExpressionContext)._addition = _x
			}
			localctx.(*ArithmeticExpressionContext).rest = append(localctx.(*ArithmeticExpressionContext).rest, localctx.(*ArithmeticExpressionContext)._addition)

		}
		p.SetState(509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditionContext is an interface to support dynamic dispatch.
type IAdditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetNext returns the next rule contexts.
	GetNext() IMultiplyingExpressionContext

	// SetNext sets the next rule contexts.
	SetNext(IMultiplyingExpressionContext)

	// Getter signatures
	MultiplyingExpression() IMultiplyingExpressionContext
	MINUS() antlr.TerminalNode
	PLUS() antlr.TerminalNode

	// IsAdditionContext differentiates from other interfaces.
	IsAdditionContext()
}

type AdditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
	next   IMultiplyingExpressionContext
}

func NewEmptyAdditionContext() *AdditionContext {
	var p = new(AdditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_addition
	return p
}

func InitEmptyAdditionContext(p *AdditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_addition
}

func (*AdditionContext) IsAdditionContext() {}

func NewAdditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditionContext {
	var p = new(AdditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_addition

	return p
}

func (s *AdditionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditionContext) GetOp() antlr.Token { return s.op }

func (s *AdditionContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditionContext) GetNext() IMultiplyingExpressionContext { return s.next }

func (s *AdditionContext) SetNext(v IMultiplyingExpressionContext) { s.next = v }

func (s *AdditionContext) MultiplyingExpression() IMultiplyingExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyingExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyingExpressionContext)
}

func (s *AdditionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMINUS, 0)
}

func (s *AdditionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPLUS, 0)
}

func (s *AdditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterAddition(s)
	}
}

func (s *AdditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitAddition(s)
	}
}

func (s *AdditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitAddition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Addition() (localctx IAdditionContext) {
	localctx = NewAdditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ElasticSQLParserRULE_addition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AdditionContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == ElasticSQLParserPLUS || _la == ElasticSQLParserMINUS) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AdditionContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(511)

		var _x = p.MultiplyingExpression()

		localctx.(*AdditionContext).next = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplyingExpressionContext is an interface to support dynamic dispatch.
type IMultiplyingExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirst returns the first rule contexts.
	GetFirst() IAtomContext

	// Get_multi returns the _multi rule contexts.
	Get_multi() IMultiContext

	// SetFirst sets the first rule contexts.
	SetFirst(IAtomContext)

	// Set_multi sets the _multi rule contexts.
	Set_multi(IMultiContext)

	// GetRest returns the rest rule context list.
	GetRest() []IMultiContext

	// SetRest sets the rest rule context list.
	SetRest([]IMultiContext)

	// Getter signatures
	Atom() IAtomContext
	AllMulti() []IMultiContext
	Multi(i int) IMultiContext

	// IsMultiplyingExpressionContext differentiates from other interfaces.
	IsMultiplyingExpressionContext()
}

type MultiplyingExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	first  IAtomContext
	_multi IMultiContext
	rest   []IMultiContext
}

func NewEmptyMultiplyingExpressionContext() *MultiplyingExpressionContext {
	var p = new(MultiplyingExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_multiplyingExpression
	return p
}

func InitEmptyMultiplyingExpressionContext(p *MultiplyingExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_multiplyingExpression
}

func (*MultiplyingExpressionContext) IsMultiplyingExpressionContext() {}

func NewMultiplyingExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyingExpressionContext {
	var p = new(MultiplyingExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_multiplyingExpression

	return p
}

func (s *MultiplyingExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyingExpressionContext) GetFirst() IAtomContext { return s.first }

func (s *MultiplyingExpressionContext) Get_multi() IMultiContext { return s._multi }

func (s *MultiplyingExpressionContext) SetFirst(v IAtomContext) { s.first = v }

func (s *MultiplyingExpressionContext) Set_multi(v IMultiContext) { s._multi = v }

func (s *MultiplyingExpressionContext) GetRest() []IMultiContext { return s.rest }

func (s *MultiplyingExpressionContext) SetRest(v []IMultiContext) { s.rest = v }

func (s *MultiplyingExpressionContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *MultiplyingExpressionContext) AllMulti() []IMultiContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiContext); ok {
			len++
		}
	}

	tst := make([]IMultiContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiContext); ok {
			tst[i] = t.(IMultiContext)
			i++
		}
	}

	return tst
}

func (s *MultiplyingExpressionContext) Multi(i int) IMultiContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiContext)
}

func (s *MultiplyingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyingExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyingExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterMultiplyingExpression(s)
	}
}

func (s *MultiplyingExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitMultiplyingExpression(s)
	}
}

func (s *MultiplyingExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitMultiplyingExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) MultiplyingExpression() (localctx IMultiplyingExpressionContext) {
	localctx = NewMultiplyingExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ElasticSQLParserRULE_multiplyingExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)

		var _x = p.Atom()

		localctx.(*MultiplyingExpressionContext).first = _x
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(514)

				var _x = p.Multi()

				localctx.(*MultiplyingExpressionContext)._multi = _x
			}
			localctx.(*MultiplyingExpressionContext).rest = append(localctx.(*MultiplyingExpressionContext).rest, localctx.(*MultiplyingExpressionContext)._multi)

		}
		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiContext is an interface to support dynamic dispatch.
type IMultiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetNext returns the next rule contexts.
	GetNext() IAtomContext

	// SetNext sets the next rule contexts.
	SetNext(IAtomContext)

	// Getter signatures
	Atom() IAtomContext
	MUL() antlr.TerminalNode
	DIV() antlr.TerminalNode

	// IsMultiContext differentiates from other interfaces.
	IsMultiContext()
}

type MultiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
	next   IAtomContext
}

func NewEmptyMultiContext() *MultiContext {
	var p = new(MultiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_multi
	return p
}

func InitEmptyMultiContext(p *MultiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_multi
}

func (*MultiContext) IsMultiContext() {}

func NewMultiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiContext {
	var p = new(MultiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_multi

	return p
}

func (s *MultiContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiContext) GetOp() antlr.Token { return s.op }

func (s *MultiContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiContext) GetNext() IAtomContext { return s.next }

func (s *MultiContext) SetNext(v IAtomContext) { s.next = v }

func (s *MultiContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *MultiContext) MUL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMUL, 0)
}

func (s *MultiContext) DIV() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDIV, 0)
}

func (s *MultiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterMulti(s)
	}
}

func (s *MultiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitMulti(s)
	}
}

func (s *MultiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitMulti(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Multi() (localctx IMultiContext) {
	localctx = NewMultiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ElasticSQLParserRULE_multi)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(520)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*MultiContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == ElasticSQLParserMUL || _la == ElasticSQLParserDIV) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*MultiContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(521)

		var _x = p.Atom()

		localctx.(*MultiContext).next = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetData returns the data rule contexts.
	GetData() IParamContext

	// GetInner returns the inner rule contexts.
	GetInner() IArithmeticExpressionContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetData sets the data rule contexts.
	SetData(IParamContext)

	// SetInner sets the inner rule contexts.
	SetInner(IArithmeticExpressionContext)

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext
	TIME_T() antlr.TerminalNode
	Param() IParamContext
	ArithmeticExpression() IArithmeticExpressionContext

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	field  IFieldIdentifierContext
	data   IParamContext
	inner  IArithmeticExpressionContext
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_atom
	return p
}

func InitEmptyAtomContext(p *AtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_atom
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) GetField() IFieldIdentifierContext { return s.field }

func (s *AtomContext) GetData() IParamContext { return s.data }

func (s *AtomContext) GetInner() IArithmeticExpressionContext { return s.inner }

func (s *AtomContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *AtomContext) SetData(v IParamContext) { s.data = v }

func (s *AtomContext) SetInner(v IArithmeticExpressionContext) { s.inner = v }

func (s *AtomContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *AtomContext) TIME_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTIME_T, 0)
}

func (s *AtomContext) Param() IParamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *AtomContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (s *AtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ElasticSQLParserRULE_atom)
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(523)

			var _x = p.FieldIdentifier()

			localctx.(*AtomContext).field = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(524)
			p.Match(ElasticSQLParserTIME_T)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(525)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(526)

			var _x = p.FieldIdentifier()

			localctx.(*AtomContext).field = _x
		}
		{
			p.SetState(527)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(529)

			var _x = p.Param()

			localctx.(*AtomContext).data = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(530)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(531)

			var _x = p.ArithmeticExpression()

			localctx.(*AtomContext).inner = _x
		}
		{
			p.SetState(532)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionalCompareContext is an interface to support dynamic dispatch.
type IFunctionalCompareContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TermLevelFunction() ITermLevelFunctionContext
	FullLevelFunction() IFullLevelFunctionContext
	ScriptFunction() IScriptFunctionContext
	JoinFunction() IJoinFunctionContext

	// IsFunctionalCompareContext differentiates from other interfaces.
	IsFunctionalCompareContext()
}

type FunctionalCompareContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionalCompareContext() *FunctionalCompareContext {
	var p = new(FunctionalCompareContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_functionalCompare
	return p
}

func InitEmptyFunctionalCompareContext(p *FunctionalCompareContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_functionalCompare
}

func (*FunctionalCompareContext) IsFunctionalCompareContext() {}

func NewFunctionalCompareContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionalCompareContext {
	var p = new(FunctionalCompareContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_functionalCompare

	return p
}

func (s *FunctionalCompareContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionalCompareContext) TermLevelFunction() ITermLevelFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermLevelFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermLevelFunctionContext)
}

func (s *FunctionalCompareContext) FullLevelFunction() IFullLevelFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullLevelFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullLevelFunctionContext)
}

func (s *FunctionalCompareContext) ScriptFunction() IScriptFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptFunctionContext)
}

func (s *FunctionalCompareContext) JoinFunction() IJoinFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinFunctionContext)
}

func (s *FunctionalCompareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionalCompareContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionalCompareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterFunctionalCompare(s)
	}
}

func (s *FunctionalCompareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitFunctionalCompare(s)
	}
}

func (s *FunctionalCompareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitFunctionalCompare(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) FunctionalCompare() (localctx IFunctionalCompareContext) {
	localctx = NewFunctionalCompareContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ElasticSQLParserRULE_functionalCompare)
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(536)
			p.TermLevelFunction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(537)
			p.FullLevelFunction()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(538)
			p.ScriptFunction()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(539)
			p.JoinFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinFunctionContext is an interface to support dynamic dispatch.
type IJoinFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFuncName returns the funcName rule contexts.
	GetFuncName() IJoinFunctionNamesContext

	// GetRelationName returns the relationName rule contexts.
	GetRelationName() IStrictIdentifierContext

	// GetJoinCondition returns the joinCondition rule contexts.
	GetJoinCondition() IWhereExpressionContext

	// SetFuncName sets the funcName rule contexts.
	SetFuncName(IJoinFunctionNamesContext)

	// SetRelationName sets the relationName rule contexts.
	SetRelationName(IStrictIdentifierContext)

	// SetJoinCondition sets the joinCondition rule contexts.
	SetJoinCondition(IWhereExpressionContext)

	// Getter signatures
	JoinFunctionNames() IJoinFunctionNamesContext
	StrictIdentifier() IStrictIdentifierContext
	ON() antlr.TerminalNode
	WhereExpression() IWhereExpressionContext

	// IsJoinFunctionContext differentiates from other interfaces.
	IsJoinFunctionContext()
}

type JoinFunctionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	funcName      IJoinFunctionNamesContext
	relationName  IStrictIdentifierContext
	joinCondition IWhereExpressionContext
}

func NewEmptyJoinFunctionContext() *JoinFunctionContext {
	var p = new(JoinFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_joinFunction
	return p
}

func InitEmptyJoinFunctionContext(p *JoinFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_joinFunction
}

func (*JoinFunctionContext) IsJoinFunctionContext() {}

func NewJoinFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinFunctionContext {
	var p = new(JoinFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_joinFunction

	return p
}

func (s *JoinFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinFunctionContext) GetFuncName() IJoinFunctionNamesContext { return s.funcName }

func (s *JoinFunctionContext) GetRelationName() IStrictIdentifierContext { return s.relationName }

func (s *JoinFunctionContext) GetJoinCondition() IWhereExpressionContext { return s.joinCondition }

func (s *JoinFunctionContext) SetFuncName(v IJoinFunctionNamesContext) { s.funcName = v }

func (s *JoinFunctionContext) SetRelationName(v IStrictIdentifierContext) { s.relationName = v }

func (s *JoinFunctionContext) SetJoinCondition(v IWhereExpressionContext) { s.joinCondition = v }

func (s *JoinFunctionContext) JoinFunctionNames() IJoinFunctionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinFunctionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinFunctionNamesContext)
}

func (s *JoinFunctionContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *JoinFunctionContext) ON() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserON, 0)
}

func (s *JoinFunctionContext) WhereExpression() IWhereExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *JoinFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterJoinFunction(s)
	}
}

func (s *JoinFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitJoinFunction(s)
	}
}

func (s *JoinFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitJoinFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) JoinFunction() (localctx IJoinFunctionContext) {
	localctx = NewJoinFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ElasticSQLParserRULE_joinFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)

		var _x = p.JoinFunctionNames()

		localctx.(*JoinFunctionContext).funcName = _x
	}
	{
		p.SetState(543)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(544)

		var _x = p.StrictIdentifier()

		localctx.(*JoinFunctionContext).relationName = _x
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserON {
		{
			p.SetState(545)
			p.Match(ElasticSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(546)

			var _x = p.WhereExpression()

			localctx.(*JoinFunctionContext).joinCondition = _x
		}

	}
	{
		p.SetState(549)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinFunctionNamesContext is an interface to support dynamic dispatch.
type IJoinFunctionNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAS_PARENT() antlr.TerminalNode
	HAS_CHILD() antlr.TerminalNode

	// IsJoinFunctionNamesContext differentiates from other interfaces.
	IsJoinFunctionNamesContext()
}

type JoinFunctionNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinFunctionNamesContext() *JoinFunctionNamesContext {
	var p = new(JoinFunctionNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_joinFunctionNames
	return p
}

func InitEmptyJoinFunctionNamesContext(p *JoinFunctionNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_joinFunctionNames
}

func (*JoinFunctionNamesContext) IsJoinFunctionNamesContext() {}

func NewJoinFunctionNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinFunctionNamesContext {
	var p = new(JoinFunctionNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_joinFunctionNames

	return p
}

func (s *JoinFunctionNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinFunctionNamesContext) HAS_PARENT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHAS_PARENT, 0)
}

func (s *JoinFunctionNamesContext) HAS_CHILD() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHAS_CHILD, 0)
}

func (s *JoinFunctionNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinFunctionNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinFunctionNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterJoinFunctionNames(s)
	}
}

func (s *JoinFunctionNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitJoinFunctionNames(s)
	}
}

func (s *JoinFunctionNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitJoinFunctionNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) JoinFunctionNames() (localctx IJoinFunctionNamesContext) {
	localctx = NewJoinFunctionNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ElasticSQLParserRULE_joinFunctionNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ElasticSQLParserHAS_CHILD || _la == ElasticSQLParserHAS_PARENT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScriptFunctionContext is an interface to support dynamic dispatch.
type IScriptFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetScript returns the script rule contexts.
	GetScript() IScriptPhraseContext

	// SetScript sets the script rule contexts.
	SetScript(IScriptPhraseContext)

	// Getter signatures
	ScriptPhrase() IScriptPhraseContext

	// IsScriptFunctionContext differentiates from other interfaces.
	IsScriptFunctionContext()
}

type ScriptFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	script IScriptPhraseContext
}

func NewEmptyScriptFunctionContext() *ScriptFunctionContext {
	var p = new(ScriptFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_scriptFunction
	return p
}

func InitEmptyScriptFunctionContext(p *ScriptFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_scriptFunction
}

func (*ScriptFunctionContext) IsScriptFunctionContext() {}

func NewScriptFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptFunctionContext {
	var p = new(ScriptFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_scriptFunction

	return p
}

func (s *ScriptFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptFunctionContext) GetScript() IScriptPhraseContext { return s.script }

func (s *ScriptFunctionContext) SetScript(v IScriptPhraseContext) { s.script = v }

func (s *ScriptFunctionContext) ScriptPhrase() IScriptPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptPhraseContext)
}

func (s *ScriptFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterScriptFunction(s)
	}
}

func (s *ScriptFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitScriptFunction(s)
	}
}

func (s *ScriptFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitScriptFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ScriptFunction() (localctx IScriptFunctionContext) {
	localctx = NewScriptFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ElasticSQLParserRULE_scriptFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)

		var _x = p.ScriptPhrase()

		localctx.(*ScriptFunctionContext).script = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullLevelFunctionContext is an interface to support dynamic dispatch.
type IFullLevelFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFuncName returns the funcName rule contexts.
	GetFuncName() IFullLevelFunctionNamesContext

	// Get_prop returns the _prop rule contexts.
	Get_prop() IPropContext

	// SetFuncName sets the funcName rule contexts.
	SetFuncName(IFullLevelFunctionNamesContext)

	// Set_prop sets the _prop rule contexts.
	Set_prop(IPropContext)

	// GetProps returns the props rule context list.
	GetProps() []IPropContext

	// SetProps sets the props rule context list.
	SetProps([]IPropContext)

	// Getter signatures
	FullLevelFunctionNames() IFullLevelFunctionNamesContext
	AllProp() []IPropContext
	Prop(i int) IPropContext

	// IsFullLevelFunctionContext differentiates from other interfaces.
	IsFullLevelFunctionContext()
}

type FullLevelFunctionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	funcName IFullLevelFunctionNamesContext
	_prop    IPropContext
	props    []IPropContext
}

func NewEmptyFullLevelFunctionContext() *FullLevelFunctionContext {
	var p = new(FullLevelFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fullLevelFunction
	return p
}

func InitEmptyFullLevelFunctionContext(p *FullLevelFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fullLevelFunction
}

func (*FullLevelFunctionContext) IsFullLevelFunctionContext() {}

func NewFullLevelFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullLevelFunctionContext {
	var p = new(FullLevelFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_fullLevelFunction

	return p
}

func (s *FullLevelFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FullLevelFunctionContext) GetFuncName() IFullLevelFunctionNamesContext { return s.funcName }

func (s *FullLevelFunctionContext) Get_prop() IPropContext { return s._prop }

func (s *FullLevelFunctionContext) SetFuncName(v IFullLevelFunctionNamesContext) { s.funcName = v }

func (s *FullLevelFunctionContext) Set_prop(v IPropContext) { s._prop = v }

func (s *FullLevelFunctionContext) GetProps() []IPropContext { return s.props }

func (s *FullLevelFunctionContext) SetProps(v []IPropContext) { s.props = v }

func (s *FullLevelFunctionContext) FullLevelFunctionNames() IFullLevelFunctionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullLevelFunctionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullLevelFunctionNamesContext)
}

func (s *FullLevelFunctionContext) AllProp() []IPropContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropContext); ok {
			len++
		}
	}

	tst := make([]IPropContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropContext); ok {
			tst[i] = t.(IPropContext)
			i++
		}
	}

	return tst
}

func (s *FullLevelFunctionContext) Prop(i int) IPropContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropContext)
}

func (s *FullLevelFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullLevelFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullLevelFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterFullLevelFunction(s)
	}
}

func (s *FullLevelFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitFullLevelFunction(s)
	}
}

func (s *FullLevelFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitFullLevelFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) FullLevelFunction() (localctx IFullLevelFunctionContext) {
	localctx = NewFullLevelFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ElasticSQLParserRULE_fullLevelFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(555)

		var _x = p.FullLevelFunctionNames()

		localctx.(*FullLevelFunctionContext).funcName = _x
	}
	{
		p.SetState(556)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(557)

		var _x = p.Prop()

		localctx.(*FullLevelFunctionContext)._prop = _x
	}
	localctx.(*FullLevelFunctionContext).props = append(localctx.(*FullLevelFunctionContext).props, localctx.(*FullLevelFunctionContext)._prop)
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(558)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(559)

			var _x = p.Prop()

			localctx.(*FullLevelFunctionContext)._prop = _x
		}
		localctx.(*FullLevelFunctionContext).props = append(localctx.(*FullLevelFunctionContext).props, localctx.(*FullLevelFunctionContext)._prop)

		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(565)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullLevelFunctionNamesContext is an interface to support dynamic dispatch.
type IFullLevelFunctionNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUERY_STRING() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MULTI_MATCH() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	KNN() antlr.TerminalNode

	// IsFullLevelFunctionNamesContext differentiates from other interfaces.
	IsFullLevelFunctionNamesContext()
}

type FullLevelFunctionNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullLevelFunctionNamesContext() *FullLevelFunctionNamesContext {
	var p = new(FullLevelFunctionNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fullLevelFunctionNames
	return p
}

func InitEmptyFullLevelFunctionNamesContext(p *FullLevelFunctionNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fullLevelFunctionNames
}

func (*FullLevelFunctionNamesContext) IsFullLevelFunctionNamesContext() {}

func NewFullLevelFunctionNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullLevelFunctionNamesContext {
	var p = new(FullLevelFunctionNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_fullLevelFunctionNames

	return p
}

func (s *FullLevelFunctionNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *FullLevelFunctionNamesContext) QUERY_STRING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUERY_STRING, 0)
}

func (s *FullLevelFunctionNamesContext) MATCH() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMATCH, 0)
}

func (s *FullLevelFunctionNamesContext) MULTI_MATCH() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMULTI_MATCH, 0)
}

func (s *FullLevelFunctionNamesContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMATCH_PHRASE, 0)
}

func (s *FullLevelFunctionNamesContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMATCH_PHRASE_PREFIX, 0)
}

func (s *FullLevelFunctionNamesContext) KNN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserKNN, 0)
}

func (s *FullLevelFunctionNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullLevelFunctionNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullLevelFunctionNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterFullLevelFunctionNames(s)
	}
}

func (s *FullLevelFunctionNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitFullLevelFunctionNames(s)
	}
}

func (s *FullLevelFunctionNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitFullLevelFunctionNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) FullLevelFunctionNames() (localctx IFullLevelFunctionNamesContext) {
	localctx = NewFullLevelFunctionNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ElasticSQLParserRULE_fullLevelFunctionNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(567)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-99)) & ^0x3f) == 0 && ((int64(1)<<(_la-99))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermLevelFunctionContext is an interface to support dynamic dispatch.
type ITermLevelFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetBoost returns the boost rule contexts.
	GetBoost() INumberContext

	// GetFuncName returns the funcName rule contexts.
	GetFuncName() ITermLevelFunctionNamesContext

	// Get_param2 returns the _param2 rule contexts.
	Get_param2() IParam2Context

	// GetUseField returns the useField rule contexts.
	GetUseField() IFieldIdentifierContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetBoost sets the boost rule contexts.
	SetBoost(INumberContext)

	// SetFuncName sets the funcName rule contexts.
	SetFuncName(ITermLevelFunctionNamesContext)

	// Set_param2 sets the _param2 rule contexts.
	Set_param2(IParam2Context)

	// SetUseField sets the useField rule contexts.
	SetUseField(IFieldIdentifierContext)

	// GetParams returns the params rule context list.
	GetParams() []IParam2Context

	// SetParams sets the params rule context list.
	SetParams([]IParam2Context)

	// Getter signatures
	TermLevelFunctionNames() ITermLevelFunctionNamesContext
	AllParam2() []IParam2Context
	Param2(i int) IParam2Context
	AllFieldIdentifier() []IFieldIdentifierContext
	FieldIdentifier(i int) IFieldIdentifierContext
	POWER() antlr.TerminalNode
	Number() INumberContext

	// IsTermLevelFunctionContext differentiates from other interfaces.
	IsTermLevelFunctionContext()
}

type TermLevelFunctionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	field    IFieldIdentifierContext
	boost    INumberContext
	funcName ITermLevelFunctionNamesContext
	_param2  IParam2Context
	params   []IParam2Context
	useField IFieldIdentifierContext
}

func NewEmptyTermLevelFunctionContext() *TermLevelFunctionContext {
	var p = new(TermLevelFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_termLevelFunction
	return p
}

func InitEmptyTermLevelFunctionContext(p *TermLevelFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_termLevelFunction
}

func (*TermLevelFunctionContext) IsTermLevelFunctionContext() {}

func NewTermLevelFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermLevelFunctionContext {
	var p = new(TermLevelFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_termLevelFunction

	return p
}

func (s *TermLevelFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TermLevelFunctionContext) GetField() IFieldIdentifierContext { return s.field }

func (s *TermLevelFunctionContext) GetBoost() INumberContext { return s.boost }

func (s *TermLevelFunctionContext) GetFuncName() ITermLevelFunctionNamesContext { return s.funcName }

func (s *TermLevelFunctionContext) Get_param2() IParam2Context { return s._param2 }

func (s *TermLevelFunctionContext) GetUseField() IFieldIdentifierContext { return s.useField }

func (s *TermLevelFunctionContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *TermLevelFunctionContext) SetBoost(v INumberContext) { s.boost = v }

func (s *TermLevelFunctionContext) SetFuncName(v ITermLevelFunctionNamesContext) { s.funcName = v }

func (s *TermLevelFunctionContext) Set_param2(v IParam2Context) { s._param2 = v }

func (s *TermLevelFunctionContext) SetUseField(v IFieldIdentifierContext) { s.useField = v }

func (s *TermLevelFunctionContext) GetParams() []IParam2Context { return s.params }

func (s *TermLevelFunctionContext) SetParams(v []IParam2Context) { s.params = v }

func (s *TermLevelFunctionContext) TermLevelFunctionNames() ITermLevelFunctionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermLevelFunctionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermLevelFunctionNamesContext)
}

func (s *TermLevelFunctionContext) AllParam2() []IParam2Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParam2Context); ok {
			len++
		}
	}

	tst := make([]IParam2Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParam2Context); ok {
			tst[i] = t.(IParam2Context)
			i++
		}
	}

	return tst
}

func (s *TermLevelFunctionContext) Param2(i int) IParam2Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParam2Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParam2Context)
}

func (s *TermLevelFunctionContext) AllFieldIdentifier() []IFieldIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IFieldIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldIdentifierContext); ok {
			tst[i] = t.(IFieldIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TermLevelFunctionContext) FieldIdentifier(i int) IFieldIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *TermLevelFunctionContext) POWER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPOWER, 0)
}

func (s *TermLevelFunctionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *TermLevelFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermLevelFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermLevelFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterTermLevelFunction(s)
	}
}

func (s *TermLevelFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitTermLevelFunction(s)
	}
}

func (s *TermLevelFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitTermLevelFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) TermLevelFunction() (localctx ITermLevelFunctionContext) {
	localctx = NewTermLevelFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ElasticSQLParserRULE_termLevelFunction)
	var _la int

	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(574)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(569)

				var _x = p.FieldIdentifier()

				localctx.(*TermLevelFunctionContext).field = _x
			}
			p.SetState(572)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserPOWER {
				{
					p.SetState(570)
					p.Match(ElasticSQLParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(571)

					var _x = p.Number()

					localctx.(*TermLevelFunctionContext).boost = _x
				}

			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(576)

			var _x = p.TermLevelFunctionNames()

			localctx.(*TermLevelFunctionContext).funcName = _x
		}
		{
			p.SetState(577)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(578)

			var _x = p.Param2()

			localctx.(*TermLevelFunctionContext)._param2 = _x
		}
		localctx.(*TermLevelFunctionContext).params = append(localctx.(*TermLevelFunctionContext).params, localctx.(*TermLevelFunctionContext)._param2)
		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(579)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(580)

				var _x = p.Param2()

				localctx.(*TermLevelFunctionContext)._param2 = _x
			}
			localctx.(*TermLevelFunctionContext).params = append(localctx.(*TermLevelFunctionContext).params, localctx.(*TermLevelFunctionContext)._param2)

			p.SetState(585)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(586)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(588)

			var _x = p.TermLevelFunctionNames()

			localctx.(*TermLevelFunctionContext).funcName = _x
		}
		{
			p.SetState(589)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(590)

			var _x = p.FieldIdentifier()

			localctx.(*TermLevelFunctionContext).field = _x
		}
		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserPOWER {
			{
				p.SetState(591)
				p.Match(ElasticSQLParserPOWER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(592)

				var _x = p.Number()

				localctx.(*TermLevelFunctionContext).boost = _x
			}

		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(595)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(596)

				var _x = p.Param2()

				localctx.(*TermLevelFunctionContext)._param2 = _x
			}
			localctx.(*TermLevelFunctionContext).params = append(localctx.(*TermLevelFunctionContext).params, localctx.(*TermLevelFunctionContext)._param2)

			p.SetState(601)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(602)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(609)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(604)

				var _x = p.FieldIdentifier()

				localctx.(*TermLevelFunctionContext).field = _x
			}
			p.SetState(607)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserPOWER {
				{
					p.SetState(605)
					p.Match(ElasticSQLParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(606)

					var _x = p.Number()

					localctx.(*TermLevelFunctionContext).boost = _x
				}

			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(611)

			var _x = p.TermLevelFunctionNames()

			localctx.(*TermLevelFunctionContext).funcName = _x
		}
		{
			p.SetState(612)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(613)

			var _x = p.FieldIdentifier()

			localctx.(*TermLevelFunctionContext).useField = _x
		}
		{
			p.SetState(614)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermLevelFunctionNamesContext is an interface to support dynamic dispatch.
type ITermLevelFunctionNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IN() antlr.TerminalNode
	OUT() antlr.TerminalNode
	HAS_ALL() antlr.TerminalNode
	HAS_ANY() antlr.TerminalNode
	EXIST() antlr.TerminalNode
	MISS() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	NOT_LIKE() antlr.TerminalNode
	IDS() antlr.TerminalNode
	STARTS_WITH() antlr.TerminalNode
	LOCAL_FILE() antlr.TerminalNode

	// IsTermLevelFunctionNamesContext differentiates from other interfaces.
	IsTermLevelFunctionNamesContext()
}

type TermLevelFunctionNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermLevelFunctionNamesContext() *TermLevelFunctionNamesContext {
	var p = new(TermLevelFunctionNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_termLevelFunctionNames
	return p
}

func InitEmptyTermLevelFunctionNamesContext(p *TermLevelFunctionNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_termLevelFunctionNames
}

func (*TermLevelFunctionNamesContext) IsTermLevelFunctionNamesContext() {}

func NewTermLevelFunctionNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermLevelFunctionNamesContext {
	var p = new(TermLevelFunctionNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_termLevelFunctionNames

	return p
}

func (s *TermLevelFunctionNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *TermLevelFunctionNamesContext) IN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIN, 0)
}

func (s *TermLevelFunctionNamesContext) OUT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserOUT, 0)
}

func (s *TermLevelFunctionNamesContext) HAS_ALL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHAS_ALL, 0)
}

func (s *TermLevelFunctionNamesContext) HAS_ANY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHAS_ANY, 0)
}

func (s *TermLevelFunctionNamesContext) EXIST() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXIST, 0)
}

func (s *TermLevelFunctionNamesContext) MISS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMISS, 0)
}

func (s *TermLevelFunctionNamesContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRLIKE, 0)
}

func (s *TermLevelFunctionNamesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIKE, 0)
}

func (s *TermLevelFunctionNamesContext) NOT_LIKE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNOT_LIKE, 0)
}

func (s *TermLevelFunctionNamesContext) IDS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIDS, 0)
}

func (s *TermLevelFunctionNamesContext) STARTS_WITH() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSTARTS_WITH, 0)
}

func (s *TermLevelFunctionNamesContext) LOCAL_FILE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLOCAL_FILE, 0)
}

func (s *TermLevelFunctionNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermLevelFunctionNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermLevelFunctionNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterTermLevelFunctionNames(s)
	}
}

func (s *TermLevelFunctionNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitTermLevelFunctionNames(s)
	}
}

func (s *TermLevelFunctionNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitTermLevelFunctionNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) TermLevelFunctionNames() (localctx ITermLevelFunctionNamesContext) {
	localctx = NewTermLevelFunctionNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ElasticSQLParserRULE_termLevelFunctionNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&562949953487871) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropContext is an interface to support dynamic dispatch.
type IPropContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k rule contexts.
	GetK() IStrictIdentifierContext

	// GetV returns the v rule contexts.
	GetV() IParamContext

	// SetK sets the k rule contexts.
	SetK(IStrictIdentifierContext)

	// SetV sets the v rule contexts.
	SetV(IParamContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext
	Param() IParamContext

	// IsPropContext differentiates from other interfaces.
	IsPropContext()
}

type PropContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      IStrictIdentifierContext
	v      IParamContext
}

func NewEmptyPropContext() *PropContext {
	var p = new(PropContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_prop
	return p
}

func InitEmptyPropContext(p *PropContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_prop
}

func (*PropContext) IsPropContext() {}

func NewPropContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropContext {
	var p = new(PropContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_prop

	return p
}

func (s *PropContext) GetParser() antlr.Parser { return s.parser }

func (s *PropContext) GetK() IStrictIdentifierContext { return s.k }

func (s *PropContext) GetV() IParamContext { return s.v }

func (s *PropContext) SetK(v IStrictIdentifierContext) { s.k = v }

func (s *PropContext) SetV(v IParamContext) { s.v = v }

func (s *PropContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *PropContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *PropContext) Param() IParamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *PropContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterProp(s)
	}
}

func (s *PropContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitProp(s)
	}
}

func (s *PropContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitProp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Prop() (localctx IPropContext) {
	localctx = NewPropContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ElasticSQLParserRULE_prop)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(620)

		var _x = p.StrictIdentifier()

		localctx.(*PropContext).k = _x
	}
	{
		p.SetState(621)
		p.Match(ElasticSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(622)

		var _x = p.Param()

		localctx.(*PropContext).v = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayValue() IArrayValueContext
	BooleanValue() IBooleanValueContext
	LONG() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	Str() IStrContext
	MUL() antlr.TerminalNode

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) ArrayValue() IArrayValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayValueContext)
}

func (s *ParamContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *ParamContext) LONG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, 0)
}

func (s *ParamContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOUBLE, 0)
}

func (s *ParamContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *ParamContext) MUL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMUL, 0)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitParam(s)
	}
}

func (s *ParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ElasticSQLParserRULE_param)
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(624)
			p.ArrayValue()
		}

	case ElasticSQLParserFALSE, ElasticSQLParserTRUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(625)
			p.BooleanValue()
		}

	case ElasticSQLParserLONG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(626)
			p.Match(ElasticSQLParserLONG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserDOUBLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(627)
			p.Match(ElasticSQLParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserQUOTASTR, ElasticSQLParserIDENTIFIER, ElasticSQLParserEXT_IDENTIFIER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(628)
			p.Str()
		}

	case ElasticSQLParserMUL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(629)
			p.Match(ElasticSQLParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParam2Context is an interface to support dynamic dispatch.
type IParam2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayValue() IArrayValueContext
	BooleanValue() IBooleanValueContext
	LONG() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	QUOTASTR() antlr.TerminalNode
	MUL() antlr.TerminalNode

	// IsParam2Context differentiates from other interfaces.
	IsParam2Context()
}

type Param2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam2Context() *Param2Context {
	var p = new(Param2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_param2
	return p
}

func InitEmptyParam2Context(p *Param2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_param2
}

func (*Param2Context) IsParam2Context() {}

func NewParam2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param2Context {
	var p = new(Param2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_param2

	return p
}

func (s *Param2Context) GetParser() antlr.Parser { return s.parser }

func (s *Param2Context) ArrayValue() IArrayValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayValueContext)
}

func (s *Param2Context) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *Param2Context) LONG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, 0)
}

func (s *Param2Context) DOUBLE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOUBLE, 0)
}

func (s *Param2Context) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *Param2Context) MUL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMUL, 0)
}

func (s *Param2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterParam2(s)
	}
}

func (s *Param2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitParam2(s)
	}
}

func (s *Param2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitParam2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Param2() (localctx IParam2Context) {
	localctx = NewParam2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ElasticSQLParserRULE_param2)
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(632)
			p.ArrayValue()
		}

	case ElasticSQLParserFALSE, ElasticSQLParserTRUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(633)
			p.BooleanValue()
		}

	case ElasticSQLParserLONG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(634)
			p.Match(ElasticSQLParserLONG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserDOUBLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(635)
			p.Match(ElasticSQLParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserQUOTASTR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(636)
			p.Match(ElasticSQLParserQUOTASTR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserMUL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(637)
			p.Match(ElasticSQLParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayValueContext is an interface to support dynamic dispatch.
type IArrayValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	ParamValues() IParamValuesContext

	// IsArrayValueContext differentiates from other interfaces.
	IsArrayValueContext()
}

type ArrayValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayValueContext() *ArrayValueContext {
	var p = new(ArrayValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_arrayValue
	return p
}

func InitEmptyArrayValueContext(p *ArrayValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_arrayValue
}

func (*ArrayValueContext) IsArrayValueContext() {}

func NewArrayValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayValueContext {
	var p = new(ArrayValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_arrayValue

	return p
}

func (s *ArrayValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayValueContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserARRAY, 0)
}

func (s *ArrayValueContext) ParamValues() IParamValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamValuesContext)
}

func (s *ArrayValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterArrayValue(s)
	}
}

func (s *ArrayValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitArrayValue(s)
	}
}

func (s *ArrayValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitArrayValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ArrayValue() (localctx IArrayValueContext) {
	localctx = NewArrayValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ElasticSQLParserRULE_arrayValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(ElasticSQLParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(641)
		p.ParamValues()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDType returns the dType token.
	GetDType() antlr.Token

	// GetFilter returns the filter token.
	GetFilter() antlr.Token

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetMd returns the md token.
	GetMd() antlr.Token

	// SetDType sets the dType token.
	SetDType(antlr.Token)

	// SetFilter sets the filter token.
	SetFilter(antlr.Token)

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetMd sets the md token.
	SetMd(antlr.Token)

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetScript returns the script rule contexts.
	GetScript() IScriptPhraseContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetScript sets the script rule contexts.
	SetScript(IScriptPhraseContext)

	// Getter signatures
	WhereExpression() IWhereExpressionContext
	FieldIdentifier() IFieldIdentifierContext
	ScriptPhrase() IScriptPhraseContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	SUM() antlr.TerminalNode
	AVG() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	STRING() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	field    IFieldIdentifierContext
	dType    antlr.Token
	script   IScriptPhraseContext
	filter   antlr.Token
	ordering antlr.Token
	md       antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetDType() antlr.Token { return s.dType }

func (s *SortItemContext) GetFilter() antlr.Token { return s.filter }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetMd() antlr.Token { return s.md }

func (s *SortItemContext) SetDType(v antlr.Token) { s.dType = v }

func (s *SortItemContext) SetFilter(v antlr.Token) { s.filter = v }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetMd(v antlr.Token) { s.md = v }

func (s *SortItemContext) GetField() IFieldIdentifierContext { return s.field }

func (s *SortItemContext) GetScript() IScriptPhraseContext { return s.script }

func (s *SortItemContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *SortItemContext) SetScript(v IScriptPhraseContext) { s.script = v }

func (s *SortItemContext) WhereExpression() IWhereExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *SortItemContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *SortItemContext) ScriptPhrase() IScriptPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptPhraseContext)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDESC, 0)
}

func (s *SortItemContext) SUM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSUM, 0)
}

func (s *SortItemContext) AVG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAVG, 0)
}

func (s *SortItemContext) MAX() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAX, 0)
}

func (s *SortItemContext) MIN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMIN, 0)
}

func (s *SortItemContext) STRING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSTRING, 0)
}

func (s *SortItemContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNUMBER, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ElasticSQLParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(643)

			var _x = p.FieldIdentifier()

			localctx.(*SortItemContext).field = _x
		}

	case 2:
		p.SetState(645)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(644)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SortItemContext).dType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ElasticSQLParserNUMBER || _la == ElasticSQLParserSTRING) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SortItemContext).dType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

		{
			p.SetState(647)

			var _x = p.ScriptPhrase()

			localctx.(*SortItemContext).script = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__4 {
		{
			p.SetState(650)

			var _m = p.Match(ElasticSQLParserT__4)

			localctx.(*SortItemContext).filter = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(651)
			p.WhereExpression()
		}
		{
			p.SetState(652)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserASC || _la == ElasticSQLParserDESC {
		{
			p.SetState(656)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ElasticSQLParserASC || _la == ElasticSQLParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&23) != 0 {
		{
			p.SetState(659)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).md = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&23) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).md = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFileType returns the fileType token.
	GetFileType() antlr.Token

	// GetSep returns the sep token.
	GetSep() antlr.Token

	// SetFileType sets the fileType token.
	SetFileType(antlr.Token)

	// SetSep sets the sep token.
	SetSep(antlr.Token)

	// Get_exportField returns the _exportField rule contexts.
	Get_exportField() IExportFieldContext

	// Get_str returns the _str rule contexts.
	Get_str() IStrContext

	// GetFileName returns the fileName rule contexts.
	GetFileName() IStrContext

	// Set_exportField sets the _exportField rule contexts.
	Set_exportField(IExportFieldContext)

	// Set_str sets the _str rule contexts.
	Set_str(IStrContext)

	// SetFileName sets the fileName rule contexts.
	SetFileName(IStrContext)

	// GetFields returns the fields rule context list.
	GetFields() []IExportFieldContext

	// GetHeads returns the heads rule context list.
	GetHeads() []IStrContext

	// SetFields sets the fields rule context list.
	SetFields([]IExportFieldContext)

	// SetHeads sets the heads rule context list.
	SetHeads([]IStrContext)

	// Getter signatures
	EXPORT() antlr.TerminalNode
	AllStr() []IStrContext
	Str(i int) IStrContext
	DISTINCT() antlr.TerminalNode
	HEADER() antlr.TerminalNode
	AllExportField() []IExportFieldContext
	ExportField(i int) IExportFieldContext
	JSON() antlr.TerminalNode
	CSV() antlr.TerminalNode
	EXCEL() antlr.TerminalNode
	SEP() antlr.TerminalNode
	EQ() antlr.TerminalNode
	QUOTASTR() antlr.TerminalNode

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_exportField IExportFieldContext
	fields       []IExportFieldContext
	_str         IStrContext
	heads        []IStrContext
	fileType     antlr.Token
	sep          antlr.Token
	fileName     IStrContext
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_exportStatement
	return p
}

func InitEmptyExportStatementContext(p *ExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_exportStatement
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) GetFileType() antlr.Token { return s.fileType }

func (s *ExportStatementContext) GetSep() antlr.Token { return s.sep }

func (s *ExportStatementContext) SetFileType(v antlr.Token) { s.fileType = v }

func (s *ExportStatementContext) SetSep(v antlr.Token) { s.sep = v }

func (s *ExportStatementContext) Get_exportField() IExportFieldContext { return s._exportField }

func (s *ExportStatementContext) Get_str() IStrContext { return s._str }

func (s *ExportStatementContext) GetFileName() IStrContext { return s.fileName }

func (s *ExportStatementContext) Set_exportField(v IExportFieldContext) { s._exportField = v }

func (s *ExportStatementContext) Set_str(v IStrContext) { s._str = v }

func (s *ExportStatementContext) SetFileName(v IStrContext) { s.fileName = v }

func (s *ExportStatementContext) GetFields() []IExportFieldContext { return s.fields }

func (s *ExportStatementContext) GetHeads() []IStrContext { return s.heads }

func (s *ExportStatementContext) SetFields(v []IExportFieldContext) { s.fields = v }

func (s *ExportStatementContext) SetHeads(v []IStrContext) { s.heads = v }

func (s *ExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXPORT, 0)
}

func (s *ExportStatementContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *ExportStatementContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *ExportStatementContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDISTINCT, 0)
}

func (s *ExportStatementContext) HEADER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHEADER, 0)
}

func (s *ExportStatementContext) AllExportField() []IExportFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExportFieldContext); ok {
			len++
		}
	}

	tst := make([]IExportFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExportFieldContext); ok {
			tst[i] = t.(IExportFieldContext)
			i++
		}
	}

	return tst
}

func (s *ExportStatementContext) ExportField(i int) IExportFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportFieldContext)
}

func (s *ExportStatementContext) JSON() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserJSON, 0)
}

func (s *ExportStatementContext) CSV() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCSV, 0)
}

func (s *ExportStatementContext) EXCEL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXCEL, 0)
}

func (s *ExportStatementContext) SEP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSEP, 0)
}

func (s *ExportStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *ExportStatementContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterExportStatement(s)
	}
}

func (s *ExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitExportStatement(s)
	}
}

func (s *ExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ElasticSQLParserRULE_exportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Match(ElasticSQLParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserDISTINCT {
		{
			p.SetState(663)
			p.Match(ElasticSQLParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__4 {
		{
			p.SetState(666)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(667)

			var _x = p.ExportField()

			localctx.(*ExportStatementContext)._exportField = _x
		}
		localctx.(*ExportStatementContext).fields = append(localctx.(*ExportStatementContext).fields, localctx.(*ExportStatementContext)._exportField)
		p.SetState(672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(668)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(669)

				var _x = p.ExportField()

				localctx.(*ExportStatementContext)._exportField = _x
			}
			localctx.(*ExportStatementContext).fields = append(localctx.(*ExportStatementContext).fields, localctx.(*ExportStatementContext)._exportField)

			p.SetState(674)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(675)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(693)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserHEADER {
		{
			p.SetState(679)
			p.Match(ElasticSQLParserHEADER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserT__4 {
			{
				p.SetState(680)
				p.Match(ElasticSQLParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(681)

				var _x = p.Str()

				localctx.(*ExportStatementContext)._str = _x
			}
			localctx.(*ExportStatementContext).heads = append(localctx.(*ExportStatementContext).heads, localctx.(*ExportStatementContext)._str)
			p.SetState(686)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ElasticSQLParserT__3 {
				{
					p.SetState(682)
					p.Match(ElasticSQLParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(683)

					var _x = p.Str()

					localctx.(*ExportStatementContext)._str = _x
				}
				localctx.(*ExportStatementContext).heads = append(localctx.(*ExportStatementContext).heads, localctx.(*ExportStatementContext)._str)

				p.SetState(688)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(689)
				p.Match(ElasticSQLParserT__5)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&7) != 0 {
		{
			p.SetState(695)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExportStatementContext).fileType = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&7) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExportStatementContext).fileType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserSEP {
			{
				p.SetState(696)
				p.Match(ElasticSQLParserSEP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(697)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(698)

				var _m = p.Match(ElasticSQLParserQUOTASTR)

				localctx.(*ExportStatementContext).sep = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(703)

		var _x = p.Str()

		localctx.(*ExportStatementContext).fileName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportFieldContext is an interface to support dynamic dispatch.
type IExportFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext
	MetricNames() IMetricNamesContext

	// IsExportFieldContext differentiates from other interfaces.
	IsExportFieldContext()
}

type ExportFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportFieldContext() *ExportFieldContext {
	var p = new(ExportFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_exportField
	return p
}

func InitEmptyExportFieldContext(p *ExportFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_exportField
}

func (*ExportFieldContext) IsExportFieldContext() {}

func NewExportFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportFieldContext {
	var p = new(ExportFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_exportField

	return p
}

func (s *ExportFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportFieldContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *ExportFieldContext) MetricNames() IMetricNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetricNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetricNamesContext)
}

func (s *ExportFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterExportField(s)
	}
}

func (s *ExportFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitExportField(s)
	}
}

func (s *ExportFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitExportField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ExportField() (localctx IExportFieldContext) {
	localctx = NewExportFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ElasticSQLParserRULE_exportField)
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(705)
			p.FieldIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(706)
			p.MetricNames()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalysisStatementContext is an interface to support dynamic dispatch.
type IAnalysisStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFront returns the front rule contexts.
	GetFront() IStrictIdentifierContext

	// SetFront sets the front rule contexts.
	SetFront(IStrictIdentifierContext)

	// Getter signatures
	AllAggStatement() []IAggStatementContext
	AggStatement(i int) IAggStatementContext
	USING() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext

	// IsAnalysisStatementContext differentiates from other interfaces.
	IsAnalysisStatementContext()
}

type AnalysisStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	front  IStrictIdentifierContext
}

func NewEmptyAnalysisStatementContext() *AnalysisStatementContext {
	var p = new(AnalysisStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_analysisStatement
	return p
}

func InitEmptyAnalysisStatementContext(p *AnalysisStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_analysisStatement
}

func (*AnalysisStatementContext) IsAnalysisStatementContext() {}

func NewAnalysisStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalysisStatementContext {
	var p = new(AnalysisStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_analysisStatement

	return p
}

func (s *AnalysisStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalysisStatementContext) GetFront() IStrictIdentifierContext { return s.front }

func (s *AnalysisStatementContext) SetFront(v IStrictIdentifierContext) { s.front = v }

func (s *AnalysisStatementContext) AllAggStatement() []IAggStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAggStatementContext); ok {
			len++
		}
	}

	tst := make([]IAggStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAggStatementContext); ok {
			tst[i] = t.(IAggStatementContext)
			i++
		}
	}

	return tst
}

func (s *AnalysisStatementContext) AggStatement(i int) IAggStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggStatementContext)
}

func (s *AnalysisStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUSING, 0)
}

func (s *AnalysisStatementContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *AnalysisStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalysisStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalysisStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterAnalysisStatement(s)
	}
}

func (s *AnalysisStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitAnalysisStatement(s)
	}
}

func (s *AnalysisStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitAnalysisStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) AnalysisStatement() (localctx IAnalysisStatementContext) {
	localctx = NewAnalysisStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ElasticSQLParserRULE_analysisStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserUSING {
		{
			p.SetState(709)
			p.Match(ElasticSQLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(710)

			var _x = p.StrictIdentifier()

			localctx.(*AnalysisStatementContext).front = _x
		}

	}
	{
		p.SetState(713)
		p.AggStatement()
	}
	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__8 {
		{
			p.SetState(714)
			p.Match(ElasticSQLParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(715)
			p.AggStatement()
		}

		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggStatementContext is an interface to support dynamic dispatch.
type IAggStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// GetWhere returns the where rule contexts.
	GetWhere() IWhereExpressionContext

	// Get_metricAgg returns the _metricAgg rule contexts.
	Get_metricAgg() IMetricAggContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// SetWhere sets the where rule contexts.
	SetWhere(IWhereExpressionContext)

	// Set_metricAgg sets the _metricAgg rule contexts.
	Set_metricAgg(IMetricAggContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// GetMetrics returns the metrics rule context list.
	GetMetrics() []IMetricAggContext

	// SetMetrics sets the metrics rule context list.
	SetMetrics([]IMetricAggContext)

	// Getter signatures
	AllMetricAgg() []IMetricAggContext
	MetricAgg(i int) IMetricAggContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	BucketAggList() IBucketAggListContext
	HavingExpr() IHavingExprContext
	LIMIT() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ExportStatement() IExportStatementContext
	WhereExpression() IWhereExpressionContext
	LONG() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext
	COUNT() antlr.TerminalNode

	// IsAggStatementContext differentiates from other interfaces.
	IsAggStatementContext()
}

type AggStatementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	where      IWhereExpressionContext
	_metricAgg IMetricAggContext
	metrics    []IMetricAggContext
	limit      antlr.Token
	statName   IStrictIdentifierContext
}

func NewEmptyAggStatementContext() *AggStatementContext {
	var p = new(AggStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_aggStatement
	return p
}

func InitEmptyAggStatementContext(p *AggStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_aggStatement
}

func (*AggStatementContext) IsAggStatementContext() {}

func NewAggStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggStatementContext {
	var p = new(AggStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_aggStatement

	return p
}

func (s *AggStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AggStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *AggStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *AggStatementContext) GetWhere() IWhereExpressionContext { return s.where }

func (s *AggStatementContext) Get_metricAgg() IMetricAggContext { return s._metricAgg }

func (s *AggStatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *AggStatementContext) SetWhere(v IWhereExpressionContext) { s.where = v }

func (s *AggStatementContext) Set_metricAgg(v IMetricAggContext) { s._metricAgg = v }

func (s *AggStatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *AggStatementContext) GetMetrics() []IMetricAggContext { return s.metrics }

func (s *AggStatementContext) SetMetrics(v []IMetricAggContext) { s.metrics = v }

func (s *AggStatementContext) AllMetricAgg() []IMetricAggContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMetricAggContext); ok {
			len++
		}
	}

	tst := make([]IMetricAggContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMetricAggContext); ok {
			tst[i] = t.(IMetricAggContext)
			i++
		}
	}

	return tst
}

func (s *AggStatementContext) MetricAgg(i int) IMetricAggContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetricAggContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetricAggContext)
}

func (s *AggStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWHERE, 0)
}

func (s *AggStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserGROUP, 0)
}

func (s *AggStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *AggStatementContext) BucketAggList() IBucketAggListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBucketAggListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBucketAggListContext)
}

func (s *AggStatementContext) HavingExpr() IHavingExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingExprContext)
}

func (s *AggStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIMIT, 0)
}

func (s *AggStatementContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *AggStatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *AggStatementContext) WhereExpression() IWhereExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *AggStatementContext) LONG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, 0)
}

func (s *AggStatementContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *AggStatementContext) COUNT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCOUNT, 0)
}

func (s *AggStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterAggStatement(s)
	}
}

func (s *AggStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitAggStatement(s)
	}
}

func (s *AggStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitAggStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) AggStatement() (localctx IAggStatementContext) {
	localctx = NewAggStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ElasticSQLParserRULE_aggStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserWHERE {
		{
			p.SetState(721)
			p.Match(ElasticSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(722)
				p.Match(ElasticSQLParserCOUNT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(725)

			var _x = p.WhereExpression()

			localctx.(*AggStatementContext).where = _x
		}

	}
	{
		p.SetState(728)

		var _x = p.MetricAgg()

		localctx.(*AggStatementContext)._metricAgg = _x
	}
	localctx.(*AggStatementContext).metrics = append(localctx.(*AggStatementContext).metrics, localctx.(*AggStatementContext)._metricAgg)
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(729)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(730)

			var _x = p.MetricAgg()

			localctx.(*AggStatementContext)._metricAgg = _x
		}
		localctx.(*AggStatementContext).metrics = append(localctx.(*AggStatementContext).metrics, localctx.(*AggStatementContext)._metricAgg)

		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserGROUP {
		{
			p.SetState(736)
			p.Match(ElasticSQLParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(737)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(738)
			p.BucketAggList()
		}

	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserHAVING {
		{
			p.SetState(741)
			p.HavingExpr()
		}

	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserLIMIT {
		{
			p.SetState(744)
			p.Match(ElasticSQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(745)

			var _m = p.Match(ElasticSQLParserLONG)

			localctx.(*AggStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(750)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(748)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(749)

			var _x = p.StrictIdentifier()

			localctx.(*AggStatementContext).statName = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserEXPORT {
		{
			p.SetState(752)
			p.ExportStatement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetricAggContext is an interface to support dynamic dispatch.
type IMetricAggContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExpr returns the expr token.
	GetExpr() antlr.Token

	// SetExpr sets the expr token.
	SetExpr(antlr.Token)

	// GetWith returns the with rule contexts.
	GetWith() IWhereExpressionContext

	// GetMetricName returns the metricName rule contexts.
	GetMetricName() IMetricNamesContext

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetMetircAs returns the metircAs rule contexts.
	GetMetircAs() IExportFieldContext

	// SetWith sets the with rule contexts.
	SetWith(IWhereExpressionContext)

	// SetMetricName sets the metricName rule contexts.
	SetMetricName(IMetricNamesContext)

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetMetircAs sets the metircAs rule contexts.
	SetMetircAs(IExportFieldContext)

	// Getter signatures
	MetricParams() IMetricParamsContext
	WITH() antlr.TerminalNode
	MetricNames() IMetricNamesContext
	FieldIdentifier() IFieldIdentifierContext
	WhereExpression() IWhereExpressionContext
	ExportField() IExportFieldContext
	AS() antlr.TerminalNode

	// IsMetricAggContext differentiates from other interfaces.
	IsMetricAggContext()
}

type MetricAggContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	with       IWhereExpressionContext
	metricName IMetricNamesContext
	field      IFieldIdentifierContext
	expr       antlr.Token
	metircAs   IExportFieldContext
}

func NewEmptyMetricAggContext() *MetricAggContext {
	var p = new(MetricAggContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_metricAgg
	return p
}

func InitEmptyMetricAggContext(p *MetricAggContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_metricAgg
}

func (*MetricAggContext) IsMetricAggContext() {}

func NewMetricAggContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetricAggContext {
	var p = new(MetricAggContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_metricAgg

	return p
}

func (s *MetricAggContext) GetParser() antlr.Parser { return s.parser }

func (s *MetricAggContext) GetExpr() antlr.Token { return s.expr }

func (s *MetricAggContext) SetExpr(v antlr.Token) { s.expr = v }

func (s *MetricAggContext) GetWith() IWhereExpressionContext { return s.with }

func (s *MetricAggContext) GetMetricName() IMetricNamesContext { return s.metricName }

func (s *MetricAggContext) GetField() IFieldIdentifierContext { return s.field }

func (s *MetricAggContext) GetMetircAs() IExportFieldContext { return s.metircAs }

func (s *MetricAggContext) SetWith(v IWhereExpressionContext) { s.with = v }

func (s *MetricAggContext) SetMetricName(v IMetricNamesContext) { s.metricName = v }

func (s *MetricAggContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *MetricAggContext) SetMetircAs(v IExportFieldContext) { s.metircAs = v }

func (s *MetricAggContext) MetricParams() IMetricParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetricParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetricParamsContext)
}

func (s *MetricAggContext) WITH() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWITH, 0)
}

func (s *MetricAggContext) MetricNames() IMetricNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetricNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetricNamesContext)
}

func (s *MetricAggContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *MetricAggContext) WhereExpression() IWhereExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *MetricAggContext) ExportField() IExportFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportFieldContext)
}

func (s *MetricAggContext) AS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAS, 0)
}

func (s *MetricAggContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetricAggContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetricAggContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterMetricAgg(s)
	}
}

func (s *MetricAggContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitMetricAgg(s)
	}
}

func (s *MetricAggContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitMetricAgg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) MetricAgg() (localctx IMetricAggContext) {
	localctx = NewMetricAggContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ElasticSQLParserRULE_metricAgg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserWITH {
		{
			p.SetState(755)
			p.Match(ElasticSQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(756)

			var _x = p.WhereExpression()

			localctx.(*MetricAggContext).with = _x
		}

	}
	p.SetState(777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(759)

			var _x = p.MetricNames()

			localctx.(*MetricAggContext).metricName = _x
		}
		{
			p.SetState(760)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(761)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(763)

			var _x = p.MetricNames()

			localctx.(*MetricAggContext).metricName = _x
		}
		{
			p.SetState(764)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(765)

			var _x = p.FieldIdentifier()

			localctx.(*MetricAggContext).field = _x
		}
		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserT__3 {
			{
				p.SetState(766)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(767)
				p.MetricParams()
			}

		}
		{
			p.SetState(770)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(772)

			var _x = p.MetricNames()

			localctx.(*MetricAggContext).metricName = _x
		}
		{
			p.SetState(773)

			var _m = p.Match(ElasticSQLParserT__4)

			localctx.(*MetricAggContext).expr = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(774)
			p.MetricParams()
		}
		{
			p.SetState(775)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(783)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserAS {
			{
				p.SetState(779)
				p.Match(ElasticSQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(782)

			var _x = p.ExportField()

			localctx.(*MetricAggContext).metircAs = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetricNamesContext is an interface to support dynamic dispatch.
type IMetricNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCORE() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	AVG() antlr.TerminalNode
	AVG_DATE() antlr.TerminalNode
	SUM() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	VALUE_COUNT() antlr.TerminalNode
	PERCENTILES() antlr.TerminalNode
	PERCENTILE_RANKS() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	DISTINCT_PERCENT() antlr.TerminalNode
	TOP_HITS() antlr.TerminalNode
	POST_EXPR() antlr.TerminalNode

	// IsMetricNamesContext differentiates from other interfaces.
	IsMetricNamesContext()
}

type MetricNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetricNamesContext() *MetricNamesContext {
	var p = new(MetricNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_metricNames
	return p
}

func InitEmptyMetricNamesContext(p *MetricNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_metricNames
}

func (*MetricNamesContext) IsMetricNamesContext() {}

func NewMetricNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetricNamesContext {
	var p = new(MetricNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_metricNames

	return p
}

func (s *MetricNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *MetricNamesContext) SCORE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSCORE, 0)
}

func (s *MetricNamesContext) COUNT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCOUNT, 0)
}

func (s *MetricNamesContext) AVG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAVG, 0)
}

func (s *MetricNamesContext) AVG_DATE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAVG_DATE, 0)
}

func (s *MetricNamesContext) SUM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSUM, 0)
}

func (s *MetricNamesContext) MAX() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAX, 0)
}

func (s *MetricNamesContext) MIN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMIN, 0)
}

func (s *MetricNamesContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDISTINCT, 0)
}

func (s *MetricNamesContext) VALUE_COUNT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserVALUE_COUNT, 0)
}

func (s *MetricNamesContext) PERCENTILES() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPERCENTILES, 0)
}

func (s *MetricNamesContext) PERCENTILE_RANKS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPERCENTILE_RANKS, 0)
}

func (s *MetricNamesContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPERCENT, 0)
}

func (s *MetricNamesContext) DISTINCT_PERCENT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDISTINCT_PERCENT, 0)
}

func (s *MetricNamesContext) TOP_HITS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTOP_HITS, 0)
}

func (s *MetricNamesContext) POST_EXPR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPOST_EXPR, 0)
}

func (s *MetricNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetricNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetricNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterMetricNames(s)
	}
}

func (s *MetricNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitMetricNames(s)
	}
}

func (s *MetricNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitMetricNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) MetricNames() (localctx IMetricNamesContext) {
	localctx = NewMetricNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ElasticSQLParserRULE_metricNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(785)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ElasticSQLParserSCORE || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&16383) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetricParamsContext is an interface to support dynamic dispatch.
type IMetricParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_mkv returns the _mkv rule contexts.
	Get_mkv() IMkvContext

	// GetScript returns the script rule contexts.
	GetScript() IScriptPhraseContext

	// Set_mkv sets the _mkv rule contexts.
	Set_mkv(IMkvContext)

	// SetScript sets the script rule contexts.
	SetScript(IScriptPhraseContext)

	// GetKvs returns the kvs rule context list.
	GetKvs() []IMkvContext

	// SetKvs sets the kvs rule context list.
	SetKvs([]IMkvContext)

	// Getter signatures
	AllMkv() []IMkvContext
	Mkv(i int) IMkvContext
	ScriptPhrase() IScriptPhraseContext

	// IsMetricParamsContext differentiates from other interfaces.
	IsMetricParamsContext()
}

type MetricParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_mkv   IMkvContext
	kvs    []IMkvContext
	script IScriptPhraseContext
}

func NewEmptyMetricParamsContext() *MetricParamsContext {
	var p = new(MetricParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_metricParams
	return p
}

func InitEmptyMetricParamsContext(p *MetricParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_metricParams
}

func (*MetricParamsContext) IsMetricParamsContext() {}

func NewMetricParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetricParamsContext {
	var p = new(MetricParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_metricParams

	return p
}

func (s *MetricParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *MetricParamsContext) Get_mkv() IMkvContext { return s._mkv }

func (s *MetricParamsContext) GetScript() IScriptPhraseContext { return s.script }

func (s *MetricParamsContext) Set_mkv(v IMkvContext) { s._mkv = v }

func (s *MetricParamsContext) SetScript(v IScriptPhraseContext) { s.script = v }

func (s *MetricParamsContext) GetKvs() []IMkvContext { return s.kvs }

func (s *MetricParamsContext) SetKvs(v []IMkvContext) { s.kvs = v }

func (s *MetricParamsContext) AllMkv() []IMkvContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMkvContext); ok {
			len++
		}
	}

	tst := make([]IMkvContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMkvContext); ok {
			tst[i] = t.(IMkvContext)
			i++
		}
	}

	return tst
}

func (s *MetricParamsContext) Mkv(i int) IMkvContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMkvContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMkvContext)
}

func (s *MetricParamsContext) ScriptPhrase() IScriptPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptPhraseContext)
}

func (s *MetricParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetricParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetricParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterMetricParams(s)
	}
}

func (s *MetricParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitMetricParams(s)
	}
}

func (s *MetricParamsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitMetricParams(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) MetricParams() (localctx IMetricParamsContext) {
	localctx = NewMetricParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ElasticSQLParserRULE_metricParams)
	var _la int

	var _alt int

	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(787)

			var _x = p.Mkv()

			localctx.(*MetricParamsContext)._mkv = _x
		}
		localctx.(*MetricParamsContext).kvs = append(localctx.(*MetricParamsContext).kvs, localctx.(*MetricParamsContext)._mkv)
		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(788)
					p.Match(ElasticSQLParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(789)

					var _x = p.Mkv()

					localctx.(*MetricParamsContext)._mkv = _x
				}
				localctx.(*MetricParamsContext).kvs = append(localctx.(*MetricParamsContext).kvs, localctx.(*MetricParamsContext)._mkv)

			}
			p.SetState(794)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(797)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserT__3 {
			{
				p.SetState(795)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(796)

				var _x = p.ScriptPhrase()

				localctx.(*MetricParamsContext).script = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(799)

			var _x = p.ScriptPhrase()

			localctx.(*MetricParamsContext).script = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMkvContext is an interface to support dynamic dispatch.
type IMkvContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k rule contexts.
	GetK() IMetricParamNamesContext

	// GetV returns the v rule contexts.
	GetV() IParamContext

	// SetK sets the k rule contexts.
	SetK(IMetricParamNamesContext)

	// SetV sets the v rule contexts.
	SetV(IParamContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	MetricParamNames() IMetricParamNamesContext
	Param() IParamContext

	// IsMkvContext differentiates from other interfaces.
	IsMkvContext()
}

type MkvContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      IMetricParamNamesContext
	v      IParamContext
}

func NewEmptyMkvContext() *MkvContext {
	var p = new(MkvContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_mkv
	return p
}

func InitEmptyMkvContext(p *MkvContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_mkv
}

func (*MkvContext) IsMkvContext() {}

func NewMkvContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MkvContext {
	var p = new(MkvContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_mkv

	return p
}

func (s *MkvContext) GetParser() antlr.Parser { return s.parser }

func (s *MkvContext) GetK() IMetricParamNamesContext { return s.k }

func (s *MkvContext) GetV() IParamContext { return s.v }

func (s *MkvContext) SetK(v IMetricParamNamesContext) { s.k = v }

func (s *MkvContext) SetV(v IParamContext) { s.v = v }

func (s *MkvContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *MkvContext) MetricParamNames() IMetricParamNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetricParamNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetricParamNamesContext)
}

func (s *MkvContext) Param() IParamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *MkvContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MkvContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MkvContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterMkv(s)
	}
}

func (s *MkvContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitMkv(s)
	}
}

func (s *MkvContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitMkv(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Mkv() (localctx IMkvContext) {
	localctx = NewMkvContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ElasticSQLParserRULE_mkv)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)

		var _x = p.MetricParamNames()

		localctx.(*MkvContext).k = _x
	}
	{
		p.SetState(803)
		p.Match(ElasticSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(804)

		var _x = p.Param()

		localctx.(*MkvContext).v = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetricParamNamesContext is an interface to support dynamic dispatch.
type IMetricParamNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MISSING() antlr.TerminalNode
	KEYED() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	INCLUDE() antlr.TerminalNode
	FORMAT() antlr.TerminalNode

	// IsMetricParamNamesContext differentiates from other interfaces.
	IsMetricParamNamesContext()
}

type MetricParamNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetricParamNamesContext() *MetricParamNamesContext {
	var p = new(MetricParamNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_metricParamNames
	return p
}

func InitEmptyMetricParamNamesContext(p *MetricParamNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_metricParamNames
}

func (*MetricParamNamesContext) IsMetricParamNamesContext() {}

func NewMetricParamNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetricParamNamesContext {
	var p = new(MetricParamNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_metricParamNames

	return p
}

func (s *MetricParamNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *MetricParamNamesContext) MISSING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMISSING, 0)
}

func (s *MetricParamNamesContext) KEYED() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserKEYED, 0)
}

func (s *MetricParamNamesContext) SIZE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSIZE, 0)
}

func (s *MetricParamNamesContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserORDER, 0)
}

func (s *MetricParamNamesContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINCLUDE, 0)
}

func (s *MetricParamNamesContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFORMAT, 0)
}

func (s *MetricParamNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetricParamNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetricParamNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterMetricParamNames(s)
	}
}

func (s *MetricParamNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitMetricParamNames(s)
	}
}

func (s *MetricParamNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitMetricParamNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) MetricParamNames() (localctx IMetricParamNamesContext) {
	localctx = NewMetricParamNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ElasticSQLParserRULE_metricParamNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223090561878062080) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&15) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScriptPhraseContext is an interface to support dynamic dispatch.
type IScriptPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetScript returns the script token.
	GetScript() antlr.Token

	// SetScript sets the script token.
	SetScript(antlr.Token)

	// GetLang returns the lang rule contexts.
	GetLang() IStrContext

	// Get_prop returns the _prop rule contexts.
	Get_prop() IPropContext

	// GetArithmetic returns the arithmetic rule contexts.
	GetArithmetic() IArithmeticExpressionContext

	// SetLang sets the lang rule contexts.
	SetLang(IStrContext)

	// Set_prop sets the _prop rule contexts.
	Set_prop(IPropContext)

	// SetArithmetic sets the arithmetic rule contexts.
	SetArithmetic(IArithmeticExpressionContext)

	// GetProps returns the props rule context list.
	GetProps() []IPropContext

	// SetProps sets the props rule context list.
	SetProps([]IPropContext)

	// Getter signatures
	SCRIPT() antlr.TerminalNode
	QUOTASTR() antlr.TerminalNode
	AllProp() []IPropContext
	Prop(i int) IPropContext
	LANG() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Str() IStrContext
	ArithmeticExpression() IArithmeticExpressionContext
	MATH() antlr.TerminalNode

	// IsScriptPhraseContext differentiates from other interfaces.
	IsScriptPhraseContext()
}

type ScriptPhraseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	lang       IStrContext
	script     antlr.Token
	_prop      IPropContext
	props      []IPropContext
	arithmetic IArithmeticExpressionContext
}

func NewEmptyScriptPhraseContext() *ScriptPhraseContext {
	var p = new(ScriptPhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_scriptPhrase
	return p
}

func InitEmptyScriptPhraseContext(p *ScriptPhraseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_scriptPhrase
}

func (*ScriptPhraseContext) IsScriptPhraseContext() {}

func NewScriptPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptPhraseContext {
	var p = new(ScriptPhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_scriptPhrase

	return p
}

func (s *ScriptPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptPhraseContext) GetScript() antlr.Token { return s.script }

func (s *ScriptPhraseContext) SetScript(v antlr.Token) { s.script = v }

func (s *ScriptPhraseContext) GetLang() IStrContext { return s.lang }

func (s *ScriptPhraseContext) Get_prop() IPropContext { return s._prop }

func (s *ScriptPhraseContext) GetArithmetic() IArithmeticExpressionContext { return s.arithmetic }

func (s *ScriptPhraseContext) SetLang(v IStrContext) { s.lang = v }

func (s *ScriptPhraseContext) Set_prop(v IPropContext) { s._prop = v }

func (s *ScriptPhraseContext) SetArithmetic(v IArithmeticExpressionContext) { s.arithmetic = v }

func (s *ScriptPhraseContext) GetProps() []IPropContext { return s.props }

func (s *ScriptPhraseContext) SetProps(v []IPropContext) { s.props = v }

func (s *ScriptPhraseContext) SCRIPT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSCRIPT, 0)
}

func (s *ScriptPhraseContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *ScriptPhraseContext) AllProp() []IPropContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropContext); ok {
			len++
		}
	}

	tst := make([]IPropContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropContext); ok {
			tst[i] = t.(IPropContext)
			i++
		}
	}

	return tst
}

func (s *ScriptPhraseContext) Prop(i int) IPropContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropContext)
}

func (s *ScriptPhraseContext) LANG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLANG, 0)
}

func (s *ScriptPhraseContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *ScriptPhraseContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *ScriptPhraseContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *ScriptPhraseContext) MATH() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMATH, 0)
}

func (s *ScriptPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterScriptPhrase(s)
	}
}

func (s *ScriptPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitScriptPhrase(s)
	}
}

func (s *ScriptPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitScriptPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ScriptPhrase() (localctx IScriptPhraseContext) {
	localctx = NewScriptPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ElasticSQLParserRULE_scriptPhrase)
	var _la int

	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(808)
			p.Match(ElasticSQLParserSCRIPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserT__1 {
			{
				p.SetState(809)
				p.Match(ElasticSQLParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			{
				p.SetState(810)
				p.Match(ElasticSQLParserLANG)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(811)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(812)

				var _x = p.Str()

				localctx.(*ScriptPhraseContext).lang = _x
			}

			{
				p.SetState(814)
				p.Match(ElasticSQLParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(818)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(819)

			var _m = p.Match(ElasticSQLParserQUOTASTR)

			localctx.(*ScriptPhraseContext).script = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(820)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(821)

				var _x = p.Prop()

				localctx.(*ScriptPhraseContext)._prop = _x
			}
			localctx.(*ScriptPhraseContext).props = append(localctx.(*ScriptPhraseContext).props, localctx.(*ScriptPhraseContext)._prop)

			p.SetState(826)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(827)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(829)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(828)
				p.Match(ElasticSQLParserMATH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(831)

			var _x = p.ArithmeticExpression()

			localctx.(*ScriptPhraseContext).arithmetic = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBucketAggListContext is an interface to support dynamic dispatch.
type IBucketAggListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_bucketAgg returns the _bucketAgg rule contexts.
	Get_bucketAgg() IBucketAggContext

	// Set_bucketAgg sets the _bucketAgg rule contexts.
	Set_bucketAgg(IBucketAggContext)

	// GetBuckets returns the buckets rule context list.
	GetBuckets() []IBucketAggContext

	// SetBuckets sets the buckets rule context list.
	SetBuckets([]IBucketAggContext)

	// Getter signatures
	AllBucketAgg() []IBucketAggContext
	BucketAgg(i int) IBucketAggContext

	// IsBucketAggListContext differentiates from other interfaces.
	IsBucketAggListContext()
}

type BucketAggListContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_bucketAgg IBucketAggContext
	buckets    []IBucketAggContext
}

func NewEmptyBucketAggListContext() *BucketAggListContext {
	var p = new(BucketAggListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_bucketAggList
	return p
}

func InitEmptyBucketAggListContext(p *BucketAggListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_bucketAggList
}

func (*BucketAggListContext) IsBucketAggListContext() {}

func NewBucketAggListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BucketAggListContext {
	var p = new(BucketAggListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_bucketAggList

	return p
}

func (s *BucketAggListContext) GetParser() antlr.Parser { return s.parser }

func (s *BucketAggListContext) Get_bucketAgg() IBucketAggContext { return s._bucketAgg }

func (s *BucketAggListContext) Set_bucketAgg(v IBucketAggContext) { s._bucketAgg = v }

func (s *BucketAggListContext) GetBuckets() []IBucketAggContext { return s.buckets }

func (s *BucketAggListContext) SetBuckets(v []IBucketAggContext) { s.buckets = v }

func (s *BucketAggListContext) AllBucketAgg() []IBucketAggContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBucketAggContext); ok {
			len++
		}
	}

	tst := make([]IBucketAggContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBucketAggContext); ok {
			tst[i] = t.(IBucketAggContext)
			i++
		}
	}

	return tst
}

func (s *BucketAggListContext) BucketAgg(i int) IBucketAggContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBucketAggContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBucketAggContext)
}

func (s *BucketAggListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BucketAggListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BucketAggListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterBucketAggList(s)
	}
}

func (s *BucketAggListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitBucketAggList(s)
	}
}

func (s *BucketAggListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitBucketAggList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) BucketAggList() (localctx IBucketAggListContext) {
	localctx = NewBucketAggListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ElasticSQLParserRULE_bucketAggList)
	var _la int

	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(834)

			var _x = p.BucketAgg()

			localctx.(*BucketAggListContext)._bucketAgg = _x
		}
		localctx.(*BucketAggListContext).buckets = append(localctx.(*BucketAggListContext).buckets, localctx.(*BucketAggListContext)._bucketAgg)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(835)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(836)

			var _x = p.BucketAgg()

			localctx.(*BucketAggListContext)._bucketAgg = _x
		}
		localctx.(*BucketAggListContext).buckets = append(localctx.(*BucketAggListContext).buckets, localctx.(*BucketAggListContext)._bucketAgg)
		p.SetState(841)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(837)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(838)

				var _x = p.BucketAgg()

				localctx.(*BucketAggListContext)._bucketAgg = _x
			}
			localctx.(*BucketAggListContext).buckets = append(localctx.(*BucketAggListContext).buckets, localctx.(*BucketAggListContext)._bucketAgg)

			p.SetState(843)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(844)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBucketAggContext is an interface to support dynamic dispatch.
type IBucketAggContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBucket returns the bucket rule contexts.
	GetBucket() IBucketAggChoiceContext

	// GetBucketAs returns the bucketAs rule contexts.
	GetBucketAs() IExportFieldContext

	// SetBucket sets the bucket rule contexts.
	SetBucket(IBucketAggChoiceContext)

	// SetBucketAs sets the bucketAs rule contexts.
	SetBucketAs(IExportFieldContext)

	// Getter signatures
	BucketAggChoice() IBucketAggChoiceContext
	ExportField() IExportFieldContext
	AS() antlr.TerminalNode

	// IsBucketAggContext differentiates from other interfaces.
	IsBucketAggContext()
}

type BucketAggContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	bucket   IBucketAggChoiceContext
	bucketAs IExportFieldContext
}

func NewEmptyBucketAggContext() *BucketAggContext {
	var p = new(BucketAggContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_bucketAgg
	return p
}

func InitEmptyBucketAggContext(p *BucketAggContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_bucketAgg
}

func (*BucketAggContext) IsBucketAggContext() {}

func NewBucketAggContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BucketAggContext {
	var p = new(BucketAggContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_bucketAgg

	return p
}

func (s *BucketAggContext) GetParser() antlr.Parser { return s.parser }

func (s *BucketAggContext) GetBucket() IBucketAggChoiceContext { return s.bucket }

func (s *BucketAggContext) GetBucketAs() IExportFieldContext { return s.bucketAs }

func (s *BucketAggContext) SetBucket(v IBucketAggChoiceContext) { s.bucket = v }

func (s *BucketAggContext) SetBucketAs(v IExportFieldContext) { s.bucketAs = v }

func (s *BucketAggContext) BucketAggChoice() IBucketAggChoiceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBucketAggChoiceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBucketAggChoiceContext)
}

func (s *BucketAggContext) ExportField() IExportFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportFieldContext)
}

func (s *BucketAggContext) AS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAS, 0)
}

func (s *BucketAggContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BucketAggContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BucketAggContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterBucketAgg(s)
	}
}

func (s *BucketAggContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitBucketAgg(s)
	}
}

func (s *BucketAggContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitBucketAgg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) BucketAgg() (localctx IBucketAggContext) {
	localctx = NewBucketAggContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ElasticSQLParserRULE_bucketAgg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)

		var _x = p.BucketAggChoice()

		localctx.(*BucketAggContext).bucket = _x
	}
	p.SetState(853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3562264197601165312) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-504403296133711885) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&288252361520453845) != 0) {
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserAS {
			{
				p.SetState(849)
				p.Match(ElasticSQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(852)

			var _x = p.ExportField()

			localctx.(*BucketAggContext).bucketAs = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBucketAggChoiceContext is an interface to support dynamic dispatch.
type IBucketAggChoiceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TermsBucket() ITermsBucketContext
	RangeBucket() IRangeBucketContext
	DateRangeBucket() IDateRangeBucketContext
	HistogramBucket() IHistogramBucketContext
	DateHistogramBucket() IDateHistogramBucketContext
	FiltersBucket() IFiltersBucketContext
	SignificantBucket() ISignificantBucketContext

	// IsBucketAggChoiceContext differentiates from other interfaces.
	IsBucketAggChoiceContext()
}

type BucketAggChoiceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBucketAggChoiceContext() *BucketAggChoiceContext {
	var p = new(BucketAggChoiceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_bucketAggChoice
	return p
}

func InitEmptyBucketAggChoiceContext(p *BucketAggChoiceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_bucketAggChoice
}

func (*BucketAggChoiceContext) IsBucketAggChoiceContext() {}

func NewBucketAggChoiceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BucketAggChoiceContext {
	var p = new(BucketAggChoiceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_bucketAggChoice

	return p
}

func (s *BucketAggChoiceContext) GetParser() antlr.Parser { return s.parser }

func (s *BucketAggChoiceContext) TermsBucket() ITermsBucketContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermsBucketContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermsBucketContext)
}

func (s *BucketAggChoiceContext) RangeBucket() IRangeBucketContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeBucketContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeBucketContext)
}

func (s *BucketAggChoiceContext) DateRangeBucket() IDateRangeBucketContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateRangeBucketContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateRangeBucketContext)
}

func (s *BucketAggChoiceContext) HistogramBucket() IHistogramBucketContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramBucketContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramBucketContext)
}

func (s *BucketAggChoiceContext) DateHistogramBucket() IDateHistogramBucketContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateHistogramBucketContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateHistogramBucketContext)
}

func (s *BucketAggChoiceContext) FiltersBucket() IFiltersBucketContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFiltersBucketContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFiltersBucketContext)
}

func (s *BucketAggChoiceContext) SignificantBucket() ISignificantBucketContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignificantBucketContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignificantBucketContext)
}

func (s *BucketAggChoiceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BucketAggChoiceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BucketAggChoiceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterBucketAggChoice(s)
	}
}

func (s *BucketAggChoiceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitBucketAggChoice(s)
	}
}

func (s *BucketAggChoiceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitBucketAggChoice(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) BucketAggChoice() (localctx IBucketAggChoiceContext) {
	localctx = NewBucketAggChoiceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ElasticSQLParserRULE_bucketAggChoice)
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(855)
			p.TermsBucket()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(856)
			p.RangeBucket()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(857)
			p.DateRangeBucket()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(858)
			p.HistogramBucket()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(859)
			p.DateHistogramBucket()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(860)
			p.FiltersBucket()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(861)
			p.SignificantBucket()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermsBucketContext is an interface to support dynamic dispatch.
type ITermsBucketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMinDocCount returns the minDocCount token.
	GetMinDocCount() antlr.Token

	// GetTop returns the top token.
	GetTop() antlr.Token

	// GetOrder returns the order token.
	GetOrder() antlr.Token

	// SetMinDocCount sets the minDocCount token.
	SetMinDocCount(antlr.Token)

	// SetTop sets the top token.
	SetTop(antlr.Token)

	// SetOrder sets the order token.
	SetOrder(antlr.Token)

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// Get_param returns the _param rule contexts.
	Get_param() IParamContext

	// GetMissing returns the missing rule contexts.
	GetMissing() IParamContext

	// GetScript returns the script rule contexts.
	GetScript() IScriptPhraseContext

	// GetOrderPath returns the orderPath rule contexts.
	GetOrderPath() IPathIdentifierContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// Set_param sets the _param rule contexts.
	Set_param(IParamContext)

	// SetMissing sets the missing rule contexts.
	SetMissing(IParamContext)

	// SetScript sets the script rule contexts.
	SetScript(IScriptPhraseContext)

	// SetOrderPath sets the orderPath rule contexts.
	SetOrderPath(IPathIdentifierContext)

	// GetInclude returns the include rule context list.
	GetInclude() []IParamContext

	// GetExclude returns the exclude rule context list.
	GetExclude() []IParamContext

	// SetInclude sets the include rule context list.
	SetInclude([]IParamContext)

	// SetExclude sets the exclude rule context list.
	SetExclude([]IParamContext)

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext
	AllINCLUDE() []antlr.TerminalNode
	INCLUDE(i int) antlr.TerminalNode
	AllEXCLUDE() []antlr.TerminalNode
	EXCLUDE(i int) antlr.TerminalNode
	AllDOC_COUNT() []antlr.TerminalNode
	DOC_COUNT(i int) antlr.TerminalNode
	AllMISSING() []antlr.TerminalNode
	MISSING(i int) antlr.TerminalNode
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	AllTOP() []antlr.TerminalNode
	TOP(i int) antlr.TerminalNode
	AllORDER() []antlr.TerminalNode
	ORDER(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	AllParam() []IParamContext
	Param(i int) IParamContext
	AllLONG() []antlr.TerminalNode
	LONG(i int) antlr.TerminalNode
	AllScriptPhrase() []IScriptPhraseContext
	ScriptPhrase(i int) IScriptPhraseContext
	AllPathIdentifier() []IPathIdentifierContext
	PathIdentifier(i int) IPathIdentifierContext
	AllDESC() []antlr.TerminalNode
	DESC(i int) antlr.TerminalNode
	AllASC() []antlr.TerminalNode
	ASC(i int) antlr.TerminalNode

	// IsTermsBucketContext differentiates from other interfaces.
	IsTermsBucketContext()
}

type TermsBucketContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	field       IFieldIdentifierContext
	_param      IParamContext
	include     []IParamContext
	exclude     []IParamContext
	minDocCount antlr.Token
	missing     IParamContext
	script      IScriptPhraseContext
	top         antlr.Token
	orderPath   IPathIdentifierContext
	order       antlr.Token
}

func NewEmptyTermsBucketContext() *TermsBucketContext {
	var p = new(TermsBucketContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_termsBucket
	return p
}

func InitEmptyTermsBucketContext(p *TermsBucketContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_termsBucket
}

func (*TermsBucketContext) IsTermsBucketContext() {}

func NewTermsBucketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermsBucketContext {
	var p = new(TermsBucketContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_termsBucket

	return p
}

func (s *TermsBucketContext) GetParser() antlr.Parser { return s.parser }

func (s *TermsBucketContext) GetMinDocCount() antlr.Token { return s.minDocCount }

func (s *TermsBucketContext) GetTop() antlr.Token { return s.top }

func (s *TermsBucketContext) GetOrder() antlr.Token { return s.order }

func (s *TermsBucketContext) SetMinDocCount(v antlr.Token) { s.minDocCount = v }

func (s *TermsBucketContext) SetTop(v antlr.Token) { s.top = v }

func (s *TermsBucketContext) SetOrder(v antlr.Token) { s.order = v }

func (s *TermsBucketContext) GetField() IFieldIdentifierContext { return s.field }

func (s *TermsBucketContext) Get_param() IParamContext { return s._param }

func (s *TermsBucketContext) GetMissing() IParamContext { return s.missing }

func (s *TermsBucketContext) GetScript() IScriptPhraseContext { return s.script }

func (s *TermsBucketContext) GetOrderPath() IPathIdentifierContext { return s.orderPath }

func (s *TermsBucketContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *TermsBucketContext) Set_param(v IParamContext) { s._param = v }

func (s *TermsBucketContext) SetMissing(v IParamContext) { s.missing = v }

func (s *TermsBucketContext) SetScript(v IScriptPhraseContext) { s.script = v }

func (s *TermsBucketContext) SetOrderPath(v IPathIdentifierContext) { s.orderPath = v }

func (s *TermsBucketContext) GetInclude() []IParamContext { return s.include }

func (s *TermsBucketContext) GetExclude() []IParamContext { return s.exclude }

func (s *TermsBucketContext) SetInclude(v []IParamContext) { s.include = v }

func (s *TermsBucketContext) SetExclude(v []IParamContext) { s.exclude = v }

func (s *TermsBucketContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *TermsBucketContext) AllINCLUDE() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserINCLUDE)
}

func (s *TermsBucketContext) INCLUDE(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINCLUDE, i)
}

func (s *TermsBucketContext) AllEXCLUDE() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserEXCLUDE)
}

func (s *TermsBucketContext) EXCLUDE(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXCLUDE, i)
}

func (s *TermsBucketContext) AllDOC_COUNT() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserDOC_COUNT)
}

func (s *TermsBucketContext) DOC_COUNT(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOC_COUNT, i)
}

func (s *TermsBucketContext) AllMISSING() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserMISSING)
}

func (s *TermsBucketContext) MISSING(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMISSING, i)
}

func (s *TermsBucketContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserAS)
}

func (s *TermsBucketContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAS, i)
}

func (s *TermsBucketContext) AllTOP() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserTOP)
}

func (s *TermsBucketContext) TOP(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTOP, i)
}

func (s *TermsBucketContext) AllORDER() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserORDER)
}

func (s *TermsBucketContext) ORDER(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserORDER, i)
}

func (s *TermsBucketContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserBY)
}

func (s *TermsBucketContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, i)
}

func (s *TermsBucketContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *TermsBucketContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *TermsBucketContext) AllLONG() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserLONG)
}

func (s *TermsBucketContext) LONG(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, i)
}

func (s *TermsBucketContext) AllScriptPhrase() []IScriptPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScriptPhraseContext); ok {
			len++
		}
	}

	tst := make([]IScriptPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScriptPhraseContext); ok {
			tst[i] = t.(IScriptPhraseContext)
			i++
		}
	}

	return tst
}

func (s *TermsBucketContext) ScriptPhrase(i int) IScriptPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptPhraseContext)
}

func (s *TermsBucketContext) AllPathIdentifier() []IPathIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IPathIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathIdentifierContext); ok {
			tst[i] = t.(IPathIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TermsBucketContext) PathIdentifier(i int) IPathIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathIdentifierContext)
}

func (s *TermsBucketContext) AllDESC() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserDESC)
}

func (s *TermsBucketContext) DESC(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDESC, i)
}

func (s *TermsBucketContext) AllASC() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserASC)
}

func (s *TermsBucketContext) ASC(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserASC, i)
}

func (s *TermsBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermsBucketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermsBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterTermsBucket(s)
	}
}

func (s *TermsBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitTermsBucket(s)
	}
}

func (s *TermsBucketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitTermsBucket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) TermsBucket() (localctx ITermsBucketContext) {
	localctx = NewTermsBucketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ElasticSQLParserRULE_termsBucket)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(865)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(864)

			var _x = p.FieldIdentifier()

			localctx.(*TermsBucketContext).field = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(906)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(867)
					p.Match(ElasticSQLParserINCLUDE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(868)
					p.Match(ElasticSQLParserT__4)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(869)

					var _x = p.Param()

					localctx.(*TermsBucketContext)._param = _x
				}
				localctx.(*TermsBucketContext).include = append(localctx.(*TermsBucketContext).include, localctx.(*TermsBucketContext)._param)
				p.SetState(874)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ElasticSQLParserT__3 {
					{
						p.SetState(870)
						p.Match(ElasticSQLParserT__3)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(871)

						var _x = p.Param()

						localctx.(*TermsBucketContext)._param = _x
					}
					localctx.(*TermsBucketContext).include = append(localctx.(*TermsBucketContext).include, localctx.(*TermsBucketContext)._param)

					p.SetState(876)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(877)
					p.Match(ElasticSQLParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				{
					p.SetState(879)
					p.Match(ElasticSQLParserEXCLUDE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(880)
					p.Match(ElasticSQLParserT__4)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(881)

					var _x = p.Param()

					localctx.(*TermsBucketContext)._param = _x
				}
				localctx.(*TermsBucketContext).exclude = append(localctx.(*TermsBucketContext).exclude, localctx.(*TermsBucketContext)._param)
				p.SetState(886)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ElasticSQLParserT__3 {
					{
						p.SetState(882)
						p.Match(ElasticSQLParserT__3)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(883)

						var _x = p.Param()

						localctx.(*TermsBucketContext)._param = _x
					}
					localctx.(*TermsBucketContext).exclude = append(localctx.(*TermsBucketContext).exclude, localctx.(*TermsBucketContext)._param)

					p.SetState(888)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(889)
					p.Match(ElasticSQLParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				{
					p.SetState(891)
					p.Match(ElasticSQLParserDOC_COUNT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(892)

					var _m = p.Match(ElasticSQLParserLONG)

					localctx.(*TermsBucketContext).minDocCount = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 4:
				{
					p.SetState(893)
					p.Match(ElasticSQLParserMISSING)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(894)
					p.Match(ElasticSQLParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(895)

					var _x = p.Param()

					localctx.(*TermsBucketContext).missing = _x
				}

			case 5:
				{
					p.SetState(896)

					var _x = p.ScriptPhrase()

					localctx.(*TermsBucketContext).script = _x
				}

			case 6:
				{
					p.SetState(897)
					p.Match(ElasticSQLParserTOP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(898)

					var _m = p.Match(ElasticSQLParserLONG)

					localctx.(*TermsBucketContext).top = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 7:
				{
					p.SetState(899)
					p.Match(ElasticSQLParserORDER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(900)
					p.Match(ElasticSQLParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(901)

					var _x = p.PathIdentifier()

					localctx.(*TermsBucketContext).orderPath = _x
				}
				p.SetState(904)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				switch p.GetTokenStream().LA(1) {
				case ElasticSQLParserASC:
					{
						p.SetState(902)

						var _m = p.Match(ElasticSQLParserASC)

						localctx.(*TermsBucketContext).order = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case ElasticSQLParserDESC:
					{
						p.SetState(903)
						p.Match(ElasticSQLParserDESC)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case ElasticSQLParserEOF, ElasticSQLParserT__0, ElasticSQLParserT__3, ElasticSQLParserT__4, ElasticSQLParserT__5, ElasticSQLParserT__8, ElasticSQLParserINNER_HIT, ElasticSQLParserRESCORE, ElasticSQLParserWINDOWS, ElasticSQLParserCOLLAPSE, ElasticSQLParserSCORE, ElasticSQLParserLIMIT, ElasticSQLParserSQL, ElasticSQLParserSTRUCT, ElasticSQLParserCK, ElasticSQLParserURL, ElasticSQLParserPASSWORD, ElasticSQLParserUSER, ElasticSQLParserAS, ElasticSQLParserMAP, ElasticSQLParserGROUP, ElasticSQLParserORDER, ElasticSQLParserTEMPLATE, ElasticSQLParserALL, ElasticSQLParserNOT, ElasticSQLParserINTO, ElasticSQLParserTO, ElasticSQLParserHAVING, ElasticSQLParserEXCLUDE, ElasticSQLParserINCLUDE, ElasticSQLParserDOC_COUNT, ElasticSQLParserTOP, ElasticSQLParserID, ElasticSQLParserSLICE, ElasticSQLParserEXPORT, ElasticSQLParserJSON, ElasticSQLParserCSV, ElasticSQLParserEXCEL, ElasticSQLParserSEP, ElasticSQLParserSCRIPT, ElasticSQLParserLANG, ElasticSQLParserRETURN, ElasticSQLParserPK, ElasticSQLParserUUID, ElasticSQLParserMEM, ElasticSQLParserRIGHT, ElasticSQLParserLEFT, ElasticSQLParserALIAS, ElasticSQLParserRLIKE, ElasticSQLParserLIKE, ElasticSQLParserIN, ElasticSQLParserOUT, ElasticSQLParserEXIST, ElasticSQLParserMISS, ElasticSQLParserQUERY_STRING, ElasticSQLParserMATCH, ElasticSQLParserMULTI_MATCH, ElasticSQLParserMATCH_PHRASE_PREFIX, ElasticSQLParserMATCH_PHRASE, ElasticSQLParserKNN, ElasticSQLParserHAS_CHILD, ElasticSQLParserHAS_PARENT, ElasticSQLParserCOUNT, ElasticSQLParserMAX, ElasticSQLParserMIN, ElasticSQLParserAVG, ElasticSQLParserAVG_DATE, ElasticSQLParserSUM, ElasticSQLParserDISTINCT, ElasticSQLParserVALUE_COUNT, ElasticSQLParserPERCENTILE_RANKS, ElasticSQLParserPERCENTILES, ElasticSQLParserPERCENT, ElasticSQLParserDISTINCT_PERCENT, ElasticSQLParserTOP_HITS, ElasticSQLParserPOST_EXPR, ElasticSQLParserMATH, ElasticSQLParserRANGE, ElasticSQLParserINTERVAL, ElasticSQLParserFORMAT, ElasticSQLParserKEYED, ElasticSQLParserSIZE, ElasticSQLParserMISSING, ElasticSQLParserNULL, ElasticSQLParserEND, ElasticSQLParserSAMPLE, ElasticSQLParserIDS, ElasticSQLParserIDS_FILE, ElasticSQLParserPUT, ElasticSQLParserADD, ElasticSQLParserARRAY, ElasticSQLParserFALSE, ElasticSQLParserTRUE, ElasticSQLParserNUMBER, ElasticSQLParserSTRING, ElasticSQLParserDATETIME_T, ElasticSQLParserTIMESTAMP_T, ElasticSQLParserDATE_T, ElasticSQLParserTIME_T, ElasticSQLParserLOCAL, ElasticSQLParserDATA, ElasticSQLParserLIST, ElasticSQLParserSEPARATED, ElasticSQLParserANALYZE, ElasticSQLParserNLP, ElasticSQLParserENABLE, ElasticSQLParserSEGMENT, ElasticSQLParserNAME, ElasticSQLParserORG, ElasticSQLParserLOC, ElasticSQLParserMUL, ElasticSQLParserLONG, ElasticSQLParserDOUBLE, ElasticSQLParserQUOTASTR, ElasticSQLParserIDENTIFIER, ElasticSQLParserEXT_IDENTIFIER:

				default:
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingExprContext is an interface to support dynamic dispatch.
type IHavingExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBucketPath returns the bucketPath rule contexts.
	GetBucketPath() IPathIdentifierContext

	// GetScript returns the script rule contexts.
	GetScript() IStrContext

	// SetBucketPath sets the bucketPath rule contexts.
	SetBucketPath(IPathIdentifierContext)

	// SetScript sets the script rule contexts.
	SetScript(IStrContext)

	// Getter signatures
	HAVING() antlr.TerminalNode
	PathIdentifier() IPathIdentifierContext
	Str() IStrContext

	// IsHavingExprContext differentiates from other interfaces.
	IsHavingExprContext()
}

type HavingExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	bucketPath IPathIdentifierContext
	script     IStrContext
}

func NewEmptyHavingExprContext() *HavingExprContext {
	var p = new(HavingExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_havingExpr
	return p
}

func InitEmptyHavingExprContext(p *HavingExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_havingExpr
}

func (*HavingExprContext) IsHavingExprContext() {}

func NewHavingExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingExprContext {
	var p = new(HavingExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_havingExpr

	return p
}

func (s *HavingExprContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingExprContext) GetBucketPath() IPathIdentifierContext { return s.bucketPath }

func (s *HavingExprContext) GetScript() IStrContext { return s.script }

func (s *HavingExprContext) SetBucketPath(v IPathIdentifierContext) { s.bucketPath = v }

func (s *HavingExprContext) SetScript(v IStrContext) { s.script = v }

func (s *HavingExprContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHAVING, 0)
}

func (s *HavingExprContext) PathIdentifier() IPathIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathIdentifierContext)
}

func (s *HavingExprContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *HavingExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterHavingExpr(s)
	}
}

func (s *HavingExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitHavingExpr(s)
	}
}

func (s *HavingExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitHavingExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) HavingExpr() (localctx IHavingExprContext) {
	localctx = NewHavingExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ElasticSQLParserRULE_havingExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		p.Match(ElasticSQLParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(912)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(913)

		var _x = p.PathIdentifier()

		localctx.(*HavingExprContext).bucketPath = _x
	}
	{
		p.SetState(914)
		p.Match(ElasticSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(915)

		var _x = p.Str()

		localctx.(*HavingExprContext).script = _x
	}
	{
		p.SetState(916)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeBucketContext is an interface to support dynamic dispatch.
type IRangeBucketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetMissing returns the missing rule contexts.
	GetMissing() IParamContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetMissing sets the missing rule contexts.
	SetMissing(IParamContext)

	// Getter signatures
	RANGE() antlr.TerminalNode
	RangeExpr() IRangeExprContext
	FieldIdentifier() IFieldIdentifierContext
	Param() IParamContext
	MISSING() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsRangeBucketContext differentiates from other interfaces.
	IsRangeBucketContext()
}

type RangeBucketContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	field   IFieldIdentifierContext
	missing IParamContext
}

func NewEmptyRangeBucketContext() *RangeBucketContext {
	var p = new(RangeBucketContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rangeBucket
	return p
}

func InitEmptyRangeBucketContext(p *RangeBucketContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rangeBucket
}

func (*RangeBucketContext) IsRangeBucketContext() {}

func NewRangeBucketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeBucketContext {
	var p = new(RangeBucketContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_rangeBucket

	return p
}

func (s *RangeBucketContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeBucketContext) GetField() IFieldIdentifierContext { return s.field }

func (s *RangeBucketContext) GetMissing() IParamContext { return s.missing }

func (s *RangeBucketContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *RangeBucketContext) SetMissing(v IParamContext) { s.missing = v }

func (s *RangeBucketContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRANGE, 0)
}

func (s *RangeBucketContext) RangeExpr() IRangeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExprContext)
}

func (s *RangeBucketContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *RangeBucketContext) Param() IParamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *RangeBucketContext) MISSING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMISSING, 0)
}

func (s *RangeBucketContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *RangeBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeBucketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterRangeBucket(s)
	}
}

func (s *RangeBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitRangeBucket(s)
	}
}

func (s *RangeBucketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitRangeBucket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) RangeBucket() (localctx IRangeBucketContext) {
	localctx = NewRangeBucketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ElasticSQLParserRULE_rangeBucket)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(918)
		p.Match(ElasticSQLParserRANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(919)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(920)

		var _x = p.FieldIdentifier()

		localctx.(*RangeBucketContext).field = _x
	}
	p.SetState(927)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(921)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserMISSING {
			{
				p.SetState(922)
				p.Match(ElasticSQLParserMISSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(923)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(926)

			var _x = p.Param()

			localctx.(*RangeBucketContext).missing = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(929)
		p.Match(ElasticSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(930)
		p.RangeExpr()
	}
	{
		p.SetState(931)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeExprContext is an interface to support dynamic dispatch.
type IRangeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_rangeUnit returns the _rangeUnit rule contexts.
	Get_rangeUnit() IRangeUnitContext

	// Set_rangeUnit sets the _rangeUnit rule contexts.
	Set_rangeUnit(IRangeUnitContext)

	// GetRanges returns the ranges rule context list.
	GetRanges() []IRangeUnitContext

	// SetRanges sets the ranges rule context list.
	SetRanges([]IRangeUnitContext)

	// Getter signatures
	AllRangeUnit() []IRangeUnitContext
	RangeUnit(i int) IRangeUnitContext

	// IsRangeExprContext differentiates from other interfaces.
	IsRangeExprContext()
}

type RangeExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_rangeUnit IRangeUnitContext
	ranges     []IRangeUnitContext
}

func NewEmptyRangeExprContext() *RangeExprContext {
	var p = new(RangeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rangeExpr
	return p
}

func InitEmptyRangeExprContext(p *RangeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rangeExpr
}

func (*RangeExprContext) IsRangeExprContext() {}

func NewRangeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExprContext {
	var p = new(RangeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_rangeExpr

	return p
}

func (s *RangeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExprContext) Get_rangeUnit() IRangeUnitContext { return s._rangeUnit }

func (s *RangeExprContext) Set_rangeUnit(v IRangeUnitContext) { s._rangeUnit = v }

func (s *RangeExprContext) GetRanges() []IRangeUnitContext { return s.ranges }

func (s *RangeExprContext) SetRanges(v []IRangeUnitContext) { s.ranges = v }

func (s *RangeExprContext) AllRangeUnit() []IRangeUnitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangeUnitContext); ok {
			len++
		}
	}

	tst := make([]IRangeUnitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangeUnitContext); ok {
			tst[i] = t.(IRangeUnitContext)
			i++
		}
	}

	return tst
}

func (s *RangeExprContext) RangeUnit(i int) IRangeUnitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeUnitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeUnitContext)
}

func (s *RangeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterRangeExpr(s)
	}
}

func (s *RangeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitRangeExpr(s)
	}
}

func (s *RangeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitRangeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) RangeExpr() (localctx IRangeExprContext) {
	localctx = NewRangeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ElasticSQLParserRULE_rangeExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(933)

		var _x = p.RangeUnit()

		localctx.(*RangeExprContext)._rangeUnit = _x
	}
	localctx.(*RangeExprContext).ranges = append(localctx.(*RangeExprContext).ranges, localctx.(*RangeExprContext)._rangeUnit)
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(934)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(935)

			var _x = p.RangeUnit()

			localctx.(*RangeExprContext)._rangeUnit = _x
		}
		localctx.(*RangeExprContext).ranges = append(localctx.(*RangeExprContext).ranges, localctx.(*RangeExprContext)._rangeUnit)

		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeUnitContext is an interface to support dynamic dispatch.
type IRangeUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrom returns the from rule contexts.
	GetFrom() IRangeFromToContext

	// GetTo returns the to rule contexts.
	GetTo() IRangeFromToContext

	// GetKey returns the key rule contexts.
	GetKey() IStrContext

	// SetFrom sets the from rule contexts.
	SetFrom(IRangeFromToContext)

	// SetTo sets the to rule contexts.
	SetTo(IRangeFromToContext)

	// SetKey sets the key rule contexts.
	SetKey(IStrContext)

	// Getter signatures
	AllRangeFromTo() []IRangeFromToContext
	RangeFromTo(i int) IRangeFromToContext
	Str() IStrContext

	// IsRangeUnitContext differentiates from other interfaces.
	IsRangeUnitContext()
}

type RangeUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	from   IRangeFromToContext
	to     IRangeFromToContext
	key    IStrContext
}

func NewEmptyRangeUnitContext() *RangeUnitContext {
	var p = new(RangeUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rangeUnit
	return p
}

func InitEmptyRangeUnitContext(p *RangeUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rangeUnit
}

func (*RangeUnitContext) IsRangeUnitContext() {}

func NewRangeUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeUnitContext {
	var p = new(RangeUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_rangeUnit

	return p
}

func (s *RangeUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeUnitContext) GetFrom() IRangeFromToContext { return s.from }

func (s *RangeUnitContext) GetTo() IRangeFromToContext { return s.to }

func (s *RangeUnitContext) GetKey() IStrContext { return s.key }

func (s *RangeUnitContext) SetFrom(v IRangeFromToContext) { s.from = v }

func (s *RangeUnitContext) SetTo(v IRangeFromToContext) { s.to = v }

func (s *RangeUnitContext) SetKey(v IStrContext) { s.key = v }

func (s *RangeUnitContext) AllRangeFromTo() []IRangeFromToContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangeFromToContext); ok {
			len++
		}
	}

	tst := make([]IRangeFromToContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangeFromToContext); ok {
			tst[i] = t.(IRangeFromToContext)
			i++
		}
	}

	return tst
}

func (s *RangeUnitContext) RangeFromTo(i int) IRangeFromToContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeFromToContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeFromToContext)
}

func (s *RangeUnitContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *RangeUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterRangeUnit(s)
	}
}

func (s *RangeUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitRangeUnit(s)
	}
}

func (s *RangeUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitRangeUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) RangeUnit() (localctx IRangeUnitContext) {
	localctx = NewRangeUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ElasticSQLParserRULE_rangeUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(941)
		p.Match(ElasticSQLParserT__6)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(942)

		var _x = p.RangeFromTo()

		localctx.(*RangeUnitContext).from = _x
	}
	{
		p.SetState(943)
		p.Match(ElasticSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(944)

		var _x = p.RangeFromTo()

		localctx.(*RangeUnitContext).to = _x
	}
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__3 {
		{
			p.SetState(945)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(946)

			var _x = p.Str()

			localctx.(*RangeUnitContext).key = _x
		}

	}
	{
		p.SetState(949)
		p.Match(ElasticSQLParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeFromToContext is an interface to support dynamic dispatch.
type IRangeFromToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	Number() INumberContext

	// IsRangeFromToContext differentiates from other interfaces.
	IsRangeFromToContext()
}

type RangeFromToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeFromToContext() *RangeFromToContext {
	var p = new(RangeFromToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rangeFromTo
	return p
}

func InitEmptyRangeFromToContext(p *RangeFromToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_rangeFromTo
}

func (*RangeFromToContext) IsRangeFromToContext() {}

func NewRangeFromToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeFromToContext {
	var p = new(RangeFromToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_rangeFromTo

	return p
}

func (s *RangeFromToContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeFromToContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMINUS, 0)
}

func (s *RangeFromToContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *RangeFromToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeFromToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeFromToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterRangeFromTo(s)
	}
}

func (s *RangeFromToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitRangeFromTo(s)
	}
}

func (s *RangeFromToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitRangeFromTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) RangeFromTo() (localctx IRangeFromToContext) {
	localctx = NewRangeFromToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ElasticSQLParserRULE_rangeFromTo)
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserMINUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(951)
			p.Match(ElasticSQLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserLONG, ElasticSQLParserDOUBLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(952)
			p.Number()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateRangeBucketContext is an interface to support dynamic dispatch.
type IDateRangeBucketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetFormat returns the format rule contexts.
	GetFormat() IStrContext

	// GetMissing returns the missing rule contexts.
	GetMissing() IStrContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IStrContext)

	// SetMissing sets the missing rule contexts.
	SetMissing(IStrContext)

	// Getter signatures
	DATE_RANGE() antlr.TerminalNode
	DateRangeExpr() IDateRangeExprContext
	FieldIdentifier() IFieldIdentifierContext
	MISSING() antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	AllStr() []IStrContext
	Str(i int) IStrContext
	FORMAT() antlr.TerminalNode

	// IsDateRangeBucketContext differentiates from other interfaces.
	IsDateRangeBucketContext()
}

type DateRangeBucketContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	field   IFieldIdentifierContext
	format  IStrContext
	missing IStrContext
}

func NewEmptyDateRangeBucketContext() *DateRangeBucketContext {
	var p = new(DateRangeBucketContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateRangeBucket
	return p
}

func InitEmptyDateRangeBucketContext(p *DateRangeBucketContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateRangeBucket
}

func (*DateRangeBucketContext) IsDateRangeBucketContext() {}

func NewDateRangeBucketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateRangeBucketContext {
	var p = new(DateRangeBucketContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_dateRangeBucket

	return p
}

func (s *DateRangeBucketContext) GetParser() antlr.Parser { return s.parser }

func (s *DateRangeBucketContext) GetField() IFieldIdentifierContext { return s.field }

func (s *DateRangeBucketContext) GetFormat() IStrContext { return s.format }

func (s *DateRangeBucketContext) GetMissing() IStrContext { return s.missing }

func (s *DateRangeBucketContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *DateRangeBucketContext) SetFormat(v IStrContext) { s.format = v }

func (s *DateRangeBucketContext) SetMissing(v IStrContext) { s.missing = v }

func (s *DateRangeBucketContext) DATE_RANGE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDATE_RANGE, 0)
}

func (s *DateRangeBucketContext) DateRangeExpr() IDateRangeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateRangeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateRangeExprContext)
}

func (s *DateRangeBucketContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *DateRangeBucketContext) MISSING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMISSING, 0)
}

func (s *DateRangeBucketContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserEQ)
}

func (s *DateRangeBucketContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, i)
}

func (s *DateRangeBucketContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *DateRangeBucketContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *DateRangeBucketContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFORMAT, 0)
}

func (s *DateRangeBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateRangeBucketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateRangeBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDateRangeBucket(s)
	}
}

func (s *DateRangeBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDateRangeBucket(s)
	}
}

func (s *DateRangeBucketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDateRangeBucket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) DateRangeBucket() (localctx IDateRangeBucketContext) {
	localctx = NewDateRangeBucketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ElasticSQLParserRULE_dateRangeBucket)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(955)
		p.Match(ElasticSQLParserDATE_RANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(956)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(957)

		var _x = p.FieldIdentifier()

		localctx.(*DateRangeBucketContext).field = _x
	}
	p.SetState(964)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(958)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserFORMAT {
			{
				p.SetState(959)
				p.Match(ElasticSQLParserFORMAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(960)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(963)

			var _x = p.Str()

			localctx.(*DateRangeBucketContext).format = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(970)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(966)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(967)
			p.Match(ElasticSQLParserMISSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(968)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(969)

			var _x = p.Str()

			localctx.(*DateRangeBucketContext).missing = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(972)
		p.Match(ElasticSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(973)
		p.DateRangeExpr()
	}
	{
		p.SetState(974)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateRangeExprContext is an interface to support dynamic dispatch.
type IDateRangeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_dateRange returns the _dateRange rule contexts.
	Get_dateRange() IDateRangeContext

	// Set_dateRange sets the _dateRange rule contexts.
	Set_dateRange(IDateRangeContext)

	// GetRanges returns the ranges rule context list.
	GetRanges() []IDateRangeContext

	// SetRanges sets the ranges rule context list.
	SetRanges([]IDateRangeContext)

	// Getter signatures
	AllDateRange() []IDateRangeContext
	DateRange(i int) IDateRangeContext

	// IsDateRangeExprContext differentiates from other interfaces.
	IsDateRangeExprContext()
}

type DateRangeExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_dateRange IDateRangeContext
	ranges     []IDateRangeContext
}

func NewEmptyDateRangeExprContext() *DateRangeExprContext {
	var p = new(DateRangeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateRangeExpr
	return p
}

func InitEmptyDateRangeExprContext(p *DateRangeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateRangeExpr
}

func (*DateRangeExprContext) IsDateRangeExprContext() {}

func NewDateRangeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateRangeExprContext {
	var p = new(DateRangeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_dateRangeExpr

	return p
}

func (s *DateRangeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *DateRangeExprContext) Get_dateRange() IDateRangeContext { return s._dateRange }

func (s *DateRangeExprContext) Set_dateRange(v IDateRangeContext) { s._dateRange = v }

func (s *DateRangeExprContext) GetRanges() []IDateRangeContext { return s.ranges }

func (s *DateRangeExprContext) SetRanges(v []IDateRangeContext) { s.ranges = v }

func (s *DateRangeExprContext) AllDateRange() []IDateRangeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDateRangeContext); ok {
			len++
		}
	}

	tst := make([]IDateRangeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDateRangeContext); ok {
			tst[i] = t.(IDateRangeContext)
			i++
		}
	}

	return tst
}

func (s *DateRangeExprContext) DateRange(i int) IDateRangeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateRangeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateRangeContext)
}

func (s *DateRangeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateRangeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateRangeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDateRangeExpr(s)
	}
}

func (s *DateRangeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDateRangeExpr(s)
	}
}

func (s *DateRangeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDateRangeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) DateRangeExpr() (localctx IDateRangeExprContext) {
	localctx = NewDateRangeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ElasticSQLParserRULE_dateRangeExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(976)

		var _x = p.DateRange()

		localctx.(*DateRangeExprContext)._dateRange = _x
	}
	localctx.(*DateRangeExprContext).ranges = append(localctx.(*DateRangeExprContext).ranges, localctx.(*DateRangeExprContext)._dateRange)
	p.SetState(981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(977)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(978)

			var _x = p.DateRange()

			localctx.(*DateRangeExprContext)._dateRange = _x
		}
		localctx.(*DateRangeExprContext).ranges = append(localctx.(*DateRangeExprContext).ranges, localctx.(*DateRangeExprContext)._dateRange)

		p.SetState(983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateRangeContext is an interface to support dynamic dispatch.
type IDateRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrom returns the from rule contexts.
	GetFrom() IDateRangeFromToContext

	// GetTo returns the to rule contexts.
	GetTo() IDateRangeFromToContext

	// GetKey returns the key rule contexts.
	GetKey() IStrContext

	// SetFrom sets the from rule contexts.
	SetFrom(IDateRangeFromToContext)

	// SetTo sets the to rule contexts.
	SetTo(IDateRangeFromToContext)

	// SetKey sets the key rule contexts.
	SetKey(IStrContext)

	// Getter signatures
	AllDateRangeFromTo() []IDateRangeFromToContext
	DateRangeFromTo(i int) IDateRangeFromToContext
	Str() IStrContext

	// IsDateRangeContext differentiates from other interfaces.
	IsDateRangeContext()
}

type DateRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	from   IDateRangeFromToContext
	to     IDateRangeFromToContext
	key    IStrContext
}

func NewEmptyDateRangeContext() *DateRangeContext {
	var p = new(DateRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateRange
	return p
}

func InitEmptyDateRangeContext(p *DateRangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateRange
}

func (*DateRangeContext) IsDateRangeContext() {}

func NewDateRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateRangeContext {
	var p = new(DateRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_dateRange

	return p
}

func (s *DateRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *DateRangeContext) GetFrom() IDateRangeFromToContext { return s.from }

func (s *DateRangeContext) GetTo() IDateRangeFromToContext { return s.to }

func (s *DateRangeContext) GetKey() IStrContext { return s.key }

func (s *DateRangeContext) SetFrom(v IDateRangeFromToContext) { s.from = v }

func (s *DateRangeContext) SetTo(v IDateRangeFromToContext) { s.to = v }

func (s *DateRangeContext) SetKey(v IStrContext) { s.key = v }

func (s *DateRangeContext) AllDateRangeFromTo() []IDateRangeFromToContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDateRangeFromToContext); ok {
			len++
		}
	}

	tst := make([]IDateRangeFromToContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDateRangeFromToContext); ok {
			tst[i] = t.(IDateRangeFromToContext)
			i++
		}
	}

	return tst
}

func (s *DateRangeContext) DateRangeFromTo(i int) IDateRangeFromToContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateRangeFromToContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateRangeFromToContext)
}

func (s *DateRangeContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *DateRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDateRange(s)
	}
}

func (s *DateRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDateRange(s)
	}
}

func (s *DateRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDateRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) DateRange() (localctx IDateRangeContext) {
	localctx = NewDateRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ElasticSQLParserRULE_dateRange)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		p.Match(ElasticSQLParserT__6)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(985)

		var _x = p.DateRangeFromTo()

		localctx.(*DateRangeContext).from = _x
	}
	{
		p.SetState(986)
		p.Match(ElasticSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(987)

		var _x = p.DateRangeFromTo()

		localctx.(*DateRangeContext).to = _x
	}
	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__3 {
		{
			p.SetState(988)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(989)

			var _x = p.Str()

			localctx.(*DateRangeContext).key = _x
		}

	}
	{
		p.SetState(992)
		p.Match(ElasticSQLParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateRangeFromToContext is an interface to support dynamic dispatch.
type IDateRangeFromToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	LONG() antlr.TerminalNode
	Str() IStrContext

	// IsDateRangeFromToContext differentiates from other interfaces.
	IsDateRangeFromToContext()
}

type DateRangeFromToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateRangeFromToContext() *DateRangeFromToContext {
	var p = new(DateRangeFromToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateRangeFromTo
	return p
}

func InitEmptyDateRangeFromToContext(p *DateRangeFromToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateRangeFromTo
}

func (*DateRangeFromToContext) IsDateRangeFromToContext() {}

func NewDateRangeFromToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateRangeFromToContext {
	var p = new(DateRangeFromToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_dateRangeFromTo

	return p
}

func (s *DateRangeFromToContext) GetParser() antlr.Parser { return s.parser }

func (s *DateRangeFromToContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMINUS, 0)
}

func (s *DateRangeFromToContext) LONG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, 0)
}

func (s *DateRangeFromToContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *DateRangeFromToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateRangeFromToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateRangeFromToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDateRangeFromTo(s)
	}
}

func (s *DateRangeFromToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDateRangeFromTo(s)
	}
}

func (s *DateRangeFromToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDateRangeFromTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) DateRangeFromTo() (localctx IDateRangeFromToContext) {
	localctx = NewDateRangeFromToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ElasticSQLParserRULE_dateRangeFromTo)
	p.SetState(997)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserMINUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(994)
			p.Match(ElasticSQLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserLONG:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(995)
			p.Match(ElasticSQLParserLONG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserQUOTASTR, ElasticSQLParserIDENTIFIER, ElasticSQLParserEXT_IDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(996)
			p.Str()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHistogramBucketContext is an interface to support dynamic dispatch.
type IHistogramBucketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetInterval returns the interval rule contexts.
	GetInterval() IParamContext

	// GetMissing returns the missing rule contexts.
	GetMissing() IParamContext

	// GetOffset returns the offset rule contexts.
	GetOffset() IParamContext

	// GetOrder returns the order rule contexts.
	GetOrder() IPathIdentifierContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetInterval sets the interval rule contexts.
	SetInterval(IParamContext)

	// SetMissing sets the missing rule contexts.
	SetMissing(IParamContext)

	// SetOffset sets the offset rule contexts.
	SetOffset(IParamContext)

	// SetOrder sets the order rule contexts.
	SetOrder(IPathIdentifierContext)

	// Getter signatures
	HISTOGRAM() antlr.TerminalNode
	FieldIdentifier() IFieldIdentifierContext
	AllParam() []IParamContext
	Param(i int) IParamContext
	INTERVAL() antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	MISSING() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	PathIdentifier() IPathIdentifierContext
	ASC() antlr.TerminalNode

	// IsHistogramBucketContext differentiates from other interfaces.
	IsHistogramBucketContext()
}

type HistogramBucketContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	field    IFieldIdentifierContext
	interval IParamContext
	missing  IParamContext
	offset   IParamContext
	order    IPathIdentifierContext
}

func NewEmptyHistogramBucketContext() *HistogramBucketContext {
	var p = new(HistogramBucketContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_histogramBucket
	return p
}

func InitEmptyHistogramBucketContext(p *HistogramBucketContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_histogramBucket
}

func (*HistogramBucketContext) IsHistogramBucketContext() {}

func NewHistogramBucketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HistogramBucketContext {
	var p = new(HistogramBucketContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_histogramBucket

	return p
}

func (s *HistogramBucketContext) GetParser() antlr.Parser { return s.parser }

func (s *HistogramBucketContext) GetField() IFieldIdentifierContext { return s.field }

func (s *HistogramBucketContext) GetInterval() IParamContext { return s.interval }

func (s *HistogramBucketContext) GetMissing() IParamContext { return s.missing }

func (s *HistogramBucketContext) GetOffset() IParamContext { return s.offset }

func (s *HistogramBucketContext) GetOrder() IPathIdentifierContext { return s.order }

func (s *HistogramBucketContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *HistogramBucketContext) SetInterval(v IParamContext) { s.interval = v }

func (s *HistogramBucketContext) SetMissing(v IParamContext) { s.missing = v }

func (s *HistogramBucketContext) SetOffset(v IParamContext) { s.offset = v }

func (s *HistogramBucketContext) SetOrder(v IPathIdentifierContext) { s.order = v }

func (s *HistogramBucketContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHISTOGRAM, 0)
}

func (s *HistogramBucketContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *HistogramBucketContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *HistogramBucketContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *HistogramBucketContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINTERVAL, 0)
}

func (s *HistogramBucketContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserEQ)
}

func (s *HistogramBucketContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, i)
}

func (s *HistogramBucketContext) MISSING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMISSING, 0)
}

func (s *HistogramBucketContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserOFFSET, 0)
}

func (s *HistogramBucketContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserORDER, 0)
}

func (s *HistogramBucketContext) PathIdentifier() IPathIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathIdentifierContext)
}

func (s *HistogramBucketContext) ASC() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserASC, 0)
}

func (s *HistogramBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HistogramBucketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HistogramBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterHistogramBucket(s)
	}
}

func (s *HistogramBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitHistogramBucket(s)
	}
}

func (s *HistogramBucketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitHistogramBucket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) HistogramBucket() (localctx IHistogramBucketContext) {
	localctx = NewHistogramBucketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ElasticSQLParserRULE_histogramBucket)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(999)
		p.Match(ElasticSQLParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1000)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1001)

		var _x = p.FieldIdentifier()

		localctx.(*HistogramBucketContext).field = _x
	}
	{
		p.SetState(1002)
		p.Match(ElasticSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserINTERVAL {
		{
			p.SetState(1003)
			p.Match(ElasticSQLParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1004)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1007)

		var _x = p.Param()

		localctx.(*HistogramBucketContext).interval = _x
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1008)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1009)
			p.Match(ElasticSQLParserMISSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1010)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1011)

			var _x = p.Param()

			localctx.(*HistogramBucketContext).missing = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1014)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1015)
			p.Match(ElasticSQLParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1016)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1017)

			var _x = p.Param()

			localctx.(*HistogramBucketContext).offset = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__3 {
		{
			p.SetState(1020)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1021)
			p.Match(ElasticSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1022)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1023)

			var _x = p.PathIdentifier()

			localctx.(*HistogramBucketContext).order = _x
		}
		p.SetState(1025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserASC {
			{
				p.SetState(1024)
				p.Match(ElasticSQLParserASC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1029)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateHistogramBucketContext is an interface to support dynamic dispatch.
type IDateHistogramBucketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetInterval returns the interval rule contexts.
	GetInterval() IStrContext

	// GetFormat returns the format rule contexts.
	GetFormat() IStrContext

	// GetMissing returns the missing rule contexts.
	GetMissing() IParamContext

	// GetOffset returns the offset rule contexts.
	GetOffset() IParamContext

	// GetOrder returns the order rule contexts.
	GetOrder() IPathIdentifierContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetInterval sets the interval rule contexts.
	SetInterval(IStrContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IStrContext)

	// SetMissing sets the missing rule contexts.
	SetMissing(IParamContext)

	// SetOffset sets the offset rule contexts.
	SetOffset(IParamContext)

	// SetOrder sets the order rule contexts.
	SetOrder(IPathIdentifierContext)

	// Getter signatures
	DATE_HISTOGRAM() antlr.TerminalNode
	FieldIdentifier() IFieldIdentifierContext
	AllStr() []IStrContext
	Str(i int) IStrContext
	INTERVAL() antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	MISSING() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	AllParam() []IParamContext
	Param(i int) IParamContext
	PathIdentifier() IPathIdentifierContext
	ASC() antlr.TerminalNode

	// IsDateHistogramBucketContext differentiates from other interfaces.
	IsDateHistogramBucketContext()
}

type DateHistogramBucketContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	field    IFieldIdentifierContext
	interval IStrContext
	format   IStrContext
	missing  IParamContext
	offset   IParamContext
	order    IPathIdentifierContext
}

func NewEmptyDateHistogramBucketContext() *DateHistogramBucketContext {
	var p = new(DateHistogramBucketContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateHistogramBucket
	return p
}

func InitEmptyDateHistogramBucketContext(p *DateHistogramBucketContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dateHistogramBucket
}

func (*DateHistogramBucketContext) IsDateHistogramBucketContext() {}

func NewDateHistogramBucketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateHistogramBucketContext {
	var p = new(DateHistogramBucketContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_dateHistogramBucket

	return p
}

func (s *DateHistogramBucketContext) GetParser() antlr.Parser { return s.parser }

func (s *DateHistogramBucketContext) GetField() IFieldIdentifierContext { return s.field }

func (s *DateHistogramBucketContext) GetInterval() IStrContext { return s.interval }

func (s *DateHistogramBucketContext) GetFormat() IStrContext { return s.format }

func (s *DateHistogramBucketContext) GetMissing() IParamContext { return s.missing }

func (s *DateHistogramBucketContext) GetOffset() IParamContext { return s.offset }

func (s *DateHistogramBucketContext) GetOrder() IPathIdentifierContext { return s.order }

func (s *DateHistogramBucketContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *DateHistogramBucketContext) SetInterval(v IStrContext) { s.interval = v }

func (s *DateHistogramBucketContext) SetFormat(v IStrContext) { s.format = v }

func (s *DateHistogramBucketContext) SetMissing(v IParamContext) { s.missing = v }

func (s *DateHistogramBucketContext) SetOffset(v IParamContext) { s.offset = v }

func (s *DateHistogramBucketContext) SetOrder(v IPathIdentifierContext) { s.order = v }

func (s *DateHistogramBucketContext) DATE_HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDATE_HISTOGRAM, 0)
}

func (s *DateHistogramBucketContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *DateHistogramBucketContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *DateHistogramBucketContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *DateHistogramBucketContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINTERVAL, 0)
}

func (s *DateHistogramBucketContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserEQ)
}

func (s *DateHistogramBucketContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, i)
}

func (s *DateHistogramBucketContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFORMAT, 0)
}

func (s *DateHistogramBucketContext) MISSING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMISSING, 0)
}

func (s *DateHistogramBucketContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserOFFSET, 0)
}

func (s *DateHistogramBucketContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserORDER, 0)
}

func (s *DateHistogramBucketContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *DateHistogramBucketContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *DateHistogramBucketContext) PathIdentifier() IPathIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathIdentifierContext)
}

func (s *DateHistogramBucketContext) ASC() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserASC, 0)
}

func (s *DateHistogramBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateHistogramBucketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateHistogramBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDateHistogramBucket(s)
	}
}

func (s *DateHistogramBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDateHistogramBucket(s)
	}
}

func (s *DateHistogramBucketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDateHistogramBucket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) DateHistogramBucket() (localctx IDateHistogramBucketContext) {
	localctx = NewDateHistogramBucketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ElasticSQLParserRULE_dateHistogramBucket)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.Match(ElasticSQLParserDATE_HISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1032)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1033)

		var _x = p.FieldIdentifier()

		localctx.(*DateHistogramBucketContext).field = _x
	}
	{
		p.SetState(1034)
		p.Match(ElasticSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserINTERVAL {
		{
			p.SetState(1035)
			p.Match(ElasticSQLParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1036)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1039)

		var _x = p.Str()

		localctx.(*DateHistogramBucketContext).interval = _x
	}
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1040)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1041)
			p.Match(ElasticSQLParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1042)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1043)

			var _x = p.Str()

			localctx.(*DateHistogramBucketContext).format = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1046)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1047)
			p.Match(ElasticSQLParserMISSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1048)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1049)

			var _x = p.Param()

			localctx.(*DateHistogramBucketContext).missing = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1052)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Match(ElasticSQLParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1054)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1055)

			var _x = p.Param()

			localctx.(*DateHistogramBucketContext).offset = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__3 {
		{
			p.SetState(1058)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1059)
			p.Match(ElasticSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1060)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1061)

			var _x = p.PathIdentifier()

			localctx.(*DateHistogramBucketContext).order = _x
		}
		p.SetState(1063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserASC {
			{
				p.SetState(1062)
				p.Match(ElasticSQLParserASC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1067)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignificantBucketContext is an interface to support dynamic dispatch.
type ISignificantBucketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSmp returns the smp token.
	GetSmp() antlr.Token

	// GetMinDocCount returns the minDocCount token.
	GetMinDocCount() antlr.Token

	// GetTop returns the top token.
	GetTop() antlr.Token

	// SetSmp sets the smp token.
	SetSmp(antlr.Token)

	// SetMinDocCount sets the minDocCount token.
	SetMinDocCount(antlr.Token)

	// SetTop sets the top token.
	SetTop(antlr.Token)

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// GetScoreAlg returns the scoreAlg rule contexts.
	GetScoreAlg() IStrContext

	// Get_param returns the _param rule contexts.
	Get_param() IParamContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// SetScoreAlg sets the scoreAlg rule contexts.
	SetScoreAlg(IStrContext)

	// Set_param sets the _param rule contexts.
	Set_param(IParamContext)

	// GetExclude returns the exclude rule context list.
	GetExclude() []IParamContext

	// GetInclude returns the include rule context list.
	GetInclude() []IParamContext

	// SetExclude sets the exclude rule context list.
	SetExclude([]IParamContext)

	// SetInclude sets the include rule context list.
	SetInclude([]IParamContext)

	// Getter signatures
	SIGNIFICANT() antlr.TerminalNode
	FieldIdentifier() IFieldIdentifierContext
	AllSAMPLE() []antlr.TerminalNode
	SAMPLE(i int) antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	AllDOC_COUNT() []antlr.TerminalNode
	DOC_COUNT(i int) antlr.TerminalNode
	AllSCORE() []antlr.TerminalNode
	SCORE(i int) antlr.TerminalNode
	AllEXCLUDE() []antlr.TerminalNode
	EXCLUDE(i int) antlr.TerminalNode
	AllINCLUDE() []antlr.TerminalNode
	INCLUDE(i int) antlr.TerminalNode
	AllTOP() []antlr.TerminalNode
	TOP(i int) antlr.TerminalNode
	AllLONG() []antlr.TerminalNode
	LONG(i int) antlr.TerminalNode
	AllStr() []IStrContext
	Str(i int) IStrContext
	AllParam() []IParamContext
	Param(i int) IParamContext

	// IsSignificantBucketContext differentiates from other interfaces.
	IsSignificantBucketContext()
}

type SignificantBucketContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	field       IFieldIdentifierContext
	smp         antlr.Token
	minDocCount antlr.Token
	scoreAlg    IStrContext
	_param      IParamContext
	exclude     []IParamContext
	include     []IParamContext
	top         antlr.Token
}

func NewEmptySignificantBucketContext() *SignificantBucketContext {
	var p = new(SignificantBucketContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_significantBucket
	return p
}

func InitEmptySignificantBucketContext(p *SignificantBucketContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_significantBucket
}

func (*SignificantBucketContext) IsSignificantBucketContext() {}

func NewSignificantBucketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignificantBucketContext {
	var p = new(SignificantBucketContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_significantBucket

	return p
}

func (s *SignificantBucketContext) GetParser() antlr.Parser { return s.parser }

func (s *SignificantBucketContext) GetSmp() antlr.Token { return s.smp }

func (s *SignificantBucketContext) GetMinDocCount() antlr.Token { return s.minDocCount }

func (s *SignificantBucketContext) GetTop() antlr.Token { return s.top }

func (s *SignificantBucketContext) SetSmp(v antlr.Token) { s.smp = v }

func (s *SignificantBucketContext) SetMinDocCount(v antlr.Token) { s.minDocCount = v }

func (s *SignificantBucketContext) SetTop(v antlr.Token) { s.top = v }

func (s *SignificantBucketContext) GetField() IFieldIdentifierContext { return s.field }

func (s *SignificantBucketContext) GetScoreAlg() IStrContext { return s.scoreAlg }

func (s *SignificantBucketContext) Get_param() IParamContext { return s._param }

func (s *SignificantBucketContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *SignificantBucketContext) SetScoreAlg(v IStrContext) { s.scoreAlg = v }

func (s *SignificantBucketContext) Set_param(v IParamContext) { s._param = v }

func (s *SignificantBucketContext) GetExclude() []IParamContext { return s.exclude }

func (s *SignificantBucketContext) GetInclude() []IParamContext { return s.include }

func (s *SignificantBucketContext) SetExclude(v []IParamContext) { s.exclude = v }

func (s *SignificantBucketContext) SetInclude(v []IParamContext) { s.include = v }

func (s *SignificantBucketContext) SIGNIFICANT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSIGNIFICANT, 0)
}

func (s *SignificantBucketContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *SignificantBucketContext) AllSAMPLE() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserSAMPLE)
}

func (s *SignificantBucketContext) SAMPLE(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSAMPLE, i)
}

func (s *SignificantBucketContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserEQ)
}

func (s *SignificantBucketContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, i)
}

func (s *SignificantBucketContext) AllDOC_COUNT() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserDOC_COUNT)
}

func (s *SignificantBucketContext) DOC_COUNT(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOC_COUNT, i)
}

func (s *SignificantBucketContext) AllSCORE() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserSCORE)
}

func (s *SignificantBucketContext) SCORE(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSCORE, i)
}

func (s *SignificantBucketContext) AllEXCLUDE() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserEXCLUDE)
}

func (s *SignificantBucketContext) EXCLUDE(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXCLUDE, i)
}

func (s *SignificantBucketContext) AllINCLUDE() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserINCLUDE)
}

func (s *SignificantBucketContext) INCLUDE(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINCLUDE, i)
}

func (s *SignificantBucketContext) AllTOP() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserTOP)
}

func (s *SignificantBucketContext) TOP(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTOP, i)
}

func (s *SignificantBucketContext) AllLONG() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserLONG)
}

func (s *SignificantBucketContext) LONG(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, i)
}

func (s *SignificantBucketContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *SignificantBucketContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *SignificantBucketContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *SignificantBucketContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *SignificantBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignificantBucketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignificantBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterSignificantBucket(s)
	}
}

func (s *SignificantBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitSignificantBucket(s)
	}
}

func (s *SignificantBucketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitSignificantBucket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) SignificantBucket() (localctx ISignificantBucketContext) {
	localctx = NewSignificantBucketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ElasticSQLParserRULE_significantBucket)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1069)
		p.Match(ElasticSQLParserSIGNIFICANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1070)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1071)

		var _x = p.FieldIdentifier()

		localctx.(*SignificantBucketContext).field = _x
	}
	p.SetState(1114)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		p.SetState(1112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1072)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1073)
				p.Match(ElasticSQLParserSAMPLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1074)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1075)

				var _m = p.Match(ElasticSQLParserLONG)

				localctx.(*SignificantBucketContext).smp = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(1076)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1077)
				p.Match(ElasticSQLParserDOC_COUNT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1078)

				var _m = p.Match(ElasticSQLParserLONG)

				localctx.(*SignificantBucketContext).minDocCount = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(1079)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1080)
				p.Match(ElasticSQLParserSCORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1081)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1082)

				var _x = p.Str()

				localctx.(*SignificantBucketContext).scoreAlg = _x
			}

		case 4:
			{
				p.SetState(1083)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1084)
				p.Match(ElasticSQLParserEXCLUDE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1085)
				p.Match(ElasticSQLParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1086)

				var _x = p.Param()

				localctx.(*SignificantBucketContext)._param = _x
			}
			localctx.(*SignificantBucketContext).exclude = append(localctx.(*SignificantBucketContext).exclude, localctx.(*SignificantBucketContext)._param)
			p.SetState(1091)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ElasticSQLParserT__3 {
				{
					p.SetState(1087)
					p.Match(ElasticSQLParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1088)

					var _x = p.Param()

					localctx.(*SignificantBucketContext)._param = _x
				}
				localctx.(*SignificantBucketContext).exclude = append(localctx.(*SignificantBucketContext).exclude, localctx.(*SignificantBucketContext)._param)

				p.SetState(1093)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1094)
				p.Match(ElasticSQLParserT__5)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(1096)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1097)
				p.Match(ElasticSQLParserINCLUDE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1098)
				p.Match(ElasticSQLParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1099)

				var _x = p.Param()

				localctx.(*SignificantBucketContext)._param = _x
			}
			localctx.(*SignificantBucketContext).include = append(localctx.(*SignificantBucketContext).include, localctx.(*SignificantBucketContext)._param)
			p.SetState(1104)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ElasticSQLParserT__3 {
				{
					p.SetState(1100)
					p.Match(ElasticSQLParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1101)

					var _x = p.Param()

					localctx.(*SignificantBucketContext)._param = _x
				}
				localctx.(*SignificantBucketContext).include = append(localctx.(*SignificantBucketContext).include, localctx.(*SignificantBucketContext)._param)

				p.SetState(1106)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1107)
				p.Match(ElasticSQLParserT__5)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(1109)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1110)
				p.Match(ElasticSQLParserTOP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1111)

				var _m = p.Match(ElasticSQLParserLONG)

				localctx.(*SignificantBucketContext).top = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1117)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFiltersBucketContext is an interface to support dynamic dispatch.
type IFiltersBucketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IFieldIdentifierContext

	// Get_whereExpression returns the _whereExpression rule contexts.
	Get_whereExpression() IWhereExpressionContext

	// Get_str returns the _str rule contexts.
	Get_str() IStrContext

	// SetField sets the field rule contexts.
	SetField(IFieldIdentifierContext)

	// Set_whereExpression sets the _whereExpression rule contexts.
	Set_whereExpression(IWhereExpressionContext)

	// Set_str sets the _str rule contexts.
	Set_str(IStrContext)

	// GetWhere returns the where rule context list.
	GetWhere() []IWhereExpressionContext

	// GetKey returns the key rule context list.
	GetKey() []IStrContext

	// SetWhere sets the where rule context list.
	SetWhere([]IWhereExpressionContext)

	// SetKey sets the key rule context list.
	SetKey([]IStrContext)

	// Getter signatures
	END() antlr.TerminalNode
	FieldIdentifier() IFieldIdentifierContext
	AllWHEN() []antlr.TerminalNode
	WHEN(i int) antlr.TerminalNode
	AllTHEN() []antlr.TerminalNode
	THEN(i int) antlr.TerminalNode
	AllWhereExpression() []IWhereExpressionContext
	WhereExpression(i int) IWhereExpressionContext
	AllStr() []IStrContext
	Str(i int) IStrContext

	// IsFiltersBucketContext differentiates from other interfaces.
	IsFiltersBucketContext()
}

type FiltersBucketContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	field            IFieldIdentifierContext
	_whereExpression IWhereExpressionContext
	where            []IWhereExpressionContext
	_str             IStrContext
	key              []IStrContext
}

func NewEmptyFiltersBucketContext() *FiltersBucketContext {
	var p = new(FiltersBucketContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_filtersBucket
	return p
}

func InitEmptyFiltersBucketContext(p *FiltersBucketContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_filtersBucket
}

func (*FiltersBucketContext) IsFiltersBucketContext() {}

func NewFiltersBucketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FiltersBucketContext {
	var p = new(FiltersBucketContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_filtersBucket

	return p
}

func (s *FiltersBucketContext) GetParser() antlr.Parser { return s.parser }

func (s *FiltersBucketContext) GetField() IFieldIdentifierContext { return s.field }

func (s *FiltersBucketContext) Get_whereExpression() IWhereExpressionContext {
	return s._whereExpression
}

func (s *FiltersBucketContext) Get_str() IStrContext { return s._str }

func (s *FiltersBucketContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *FiltersBucketContext) Set_whereExpression(v IWhereExpressionContext) { s._whereExpression = v }

func (s *FiltersBucketContext) Set_str(v IStrContext) { s._str = v }

func (s *FiltersBucketContext) GetWhere() []IWhereExpressionContext { return s.where }

func (s *FiltersBucketContext) GetKey() []IStrContext { return s.key }

func (s *FiltersBucketContext) SetWhere(v []IWhereExpressionContext) { s.where = v }

func (s *FiltersBucketContext) SetKey(v []IStrContext) { s.key = v }

func (s *FiltersBucketContext) END() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEND, 0)
}

func (s *FiltersBucketContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *FiltersBucketContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserWHEN)
}

func (s *FiltersBucketContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWHEN, i)
}

func (s *FiltersBucketContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserTHEN)
}

func (s *FiltersBucketContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTHEN, i)
}

func (s *FiltersBucketContext) AllWhereExpression() []IWhereExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			len++
		}
	}

	tst := make([]IWhereExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhereExpressionContext); ok {
			tst[i] = t.(IWhereExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FiltersBucketContext) WhereExpression(i int) IWhereExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *FiltersBucketContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *FiltersBucketContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *FiltersBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FiltersBucketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FiltersBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterFiltersBucket(s)
	}
}

func (s *FiltersBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitFiltersBucket(s)
	}
}

func (s *FiltersBucketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitFiltersBucket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) FiltersBucket() (localctx IFiltersBucketContext) {
	localctx = NewFiltersBucketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ElasticSQLParserRULE_filtersBucket)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1119)

		var _x = p.FieldIdentifier()

		localctx.(*FiltersBucketContext).field = _x
	}
	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ElasticSQLParserWHEN {
		{
			p.SetState(1120)
			p.Match(ElasticSQLParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1121)

			var _x = p.WhereExpression()

			localctx.(*FiltersBucketContext)._whereExpression = _x
		}
		localctx.(*FiltersBucketContext).where = append(localctx.(*FiltersBucketContext).where, localctx.(*FiltersBucketContext)._whereExpression)
		{
			p.SetState(1122)
			p.Match(ElasticSQLParserTHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1123)

			var _x = p.Str()

			localctx.(*FiltersBucketContext)._str = _x
		}
		localctx.(*FiltersBucketContext).key = append(localctx.(*FiltersBucketContext).key, localctx.(*FiltersBucketContext)._str)

		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1129)
		p.Match(ElasticSQLParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISparkStatementContext is an interface to support dynamic dispatch.
type ISparkStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSql returns the sql token.
	GetSql() antlr.Token

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetSql sets the sql token.
	SetSql(antlr.Token)

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Get_dataStruct returns the _dataStruct rule contexts.
	Get_dataStruct() IDataStructContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// Set_dataStruct sets the _dataStruct rule contexts.
	Set_dataStruct(IDataStructContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// GetFiles returns the files rule context list.
	GetFiles() []IDataStructContext

	// SetFiles sets the files rule context list.
	SetFiles([]IDataStructContext)

	// Getter signatures
	SQL() antlr.TerminalNode
	QUOTASTR() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ExportStatement() IExportStatementContext
	AllDataStruct() []IDataStructContext
	DataStruct(i int) IDataStructContext
	LONG() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext

	// IsSparkStatementContext differentiates from other interfaces.
	IsSparkStatementContext()
}

type SparkStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_dataStruct IDataStructContext
	files       []IDataStructContext
	sql         antlr.Token
	limit       antlr.Token
	statName    IStrictIdentifierContext
}

func NewEmptySparkStatementContext() *SparkStatementContext {
	var p = new(SparkStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_sparkStatement
	return p
}

func InitEmptySparkStatementContext(p *SparkStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_sparkStatement
}

func (*SparkStatementContext) IsSparkStatementContext() {}

func NewSparkStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SparkStatementContext {
	var p = new(SparkStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_sparkStatement

	return p
}

func (s *SparkStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SparkStatementContext) GetSql() antlr.Token { return s.sql }

func (s *SparkStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *SparkStatementContext) SetSql(v antlr.Token) { s.sql = v }

func (s *SparkStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *SparkStatementContext) Get_dataStruct() IDataStructContext { return s._dataStruct }

func (s *SparkStatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *SparkStatementContext) Set_dataStruct(v IDataStructContext) { s._dataStruct = v }

func (s *SparkStatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *SparkStatementContext) GetFiles() []IDataStructContext { return s.files }

func (s *SparkStatementContext) SetFiles(v []IDataStructContext) { s.files = v }

func (s *SparkStatementContext) SQL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSQL, 0)
}

func (s *SparkStatementContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *SparkStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIMIT, 0)
}

func (s *SparkStatementContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *SparkStatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *SparkStatementContext) AllDataStruct() []IDataStructContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataStructContext); ok {
			len++
		}
	}

	tst := make([]IDataStructContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataStructContext); ok {
			tst[i] = t.(IDataStructContext)
			i++
		}
	}

	return tst
}

func (s *SparkStatementContext) DataStruct(i int) IDataStructContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataStructContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataStructContext)
}

func (s *SparkStatementContext) LONG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, 0)
}

func (s *SparkStatementContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *SparkStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SparkStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SparkStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterSparkStatement(s)
	}
}

func (s *SparkStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitSparkStatement(s)
	}
}

func (s *SparkStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitSparkStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) SparkStatement() (localctx ISparkStatementContext) {
	localctx = NewSparkStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ElasticSQLParserRULE_sparkStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1131)
		p.Match(ElasticSQLParserSQL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1143)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__1 {
		{
			p.SetState(1132)
			p.Match(ElasticSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1133)

			var _x = p.DataStruct()

			localctx.(*SparkStatementContext)._dataStruct = _x
		}
		localctx.(*SparkStatementContext).files = append(localctx.(*SparkStatementContext).files, localctx.(*SparkStatementContext)._dataStruct)
		p.SetState(1138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1134)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1135)

				var _x = p.DataStruct()

				localctx.(*SparkStatementContext)._dataStruct = _x
			}
			localctx.(*SparkStatementContext).files = append(localctx.(*SparkStatementContext).files, localctx.(*SparkStatementContext)._dataStruct)

			p.SetState(1140)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1141)
			p.Match(ElasticSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1145)

		var _m = p.Match(ElasticSQLParserQUOTASTR)

		localctx.(*SparkStatementContext).sql = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserLIMIT {
		{
			p.SetState(1146)
			p.Match(ElasticSQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1147)

			var _m = p.Match(ElasticSQLParserLONG)

			localctx.(*SparkStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(1150)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1151)

			var _x = p.StrictIdentifier()

			localctx.(*SparkStatementContext).statName = _x
		}

	}
	p.SetState(1155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserEXPORT {
		{
			p.SetState(1154)
			p.ExportStatement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataStructContext is an interface to support dynamic dispatch.
type IDataStructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTableName returns the tableName rule contexts.
	GetTableName() IStrictIdentifierContext

	// Get_exportField returns the _exportField rule contexts.
	Get_exportField() IExportFieldContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IStrictIdentifierContext)

	// Set_exportField sets the _exportField rule contexts.
	Set_exportField(IExportFieldContext)

	// GetFields returns the fields rule context list.
	GetFields() []IExportFieldContext

	// SetFields sets the fields rule context list.
	SetFields([]IExportFieldContext)

	// Getter signatures
	STRUCT() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext
	AllExportField() []IExportFieldContext
	ExportField(i int) IExportFieldContext

	// IsDataStructContext differentiates from other interfaces.
	IsDataStructContext()
}

type DataStructContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	tableName    IStrictIdentifierContext
	_exportField IExportFieldContext
	fields       []IExportFieldContext
}

func NewEmptyDataStructContext() *DataStructContext {
	var p = new(DataStructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dataStruct
	return p
}

func InitEmptyDataStructContext(p *DataStructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dataStruct
}

func (*DataStructContext) IsDataStructContext() {}

func NewDataStructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataStructContext {
	var p = new(DataStructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_dataStruct

	return p
}

func (s *DataStructContext) GetParser() antlr.Parser { return s.parser }

func (s *DataStructContext) GetTableName() IStrictIdentifierContext { return s.tableName }

func (s *DataStructContext) Get_exportField() IExportFieldContext { return s._exportField }

func (s *DataStructContext) SetTableName(v IStrictIdentifierContext) { s.tableName = v }

func (s *DataStructContext) Set_exportField(v IExportFieldContext) { s._exportField = v }

func (s *DataStructContext) GetFields() []IExportFieldContext { return s.fields }

func (s *DataStructContext) SetFields(v []IExportFieldContext) { s.fields = v }

func (s *DataStructContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSTRUCT, 0)
}

func (s *DataStructContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *DataStructContext) AllExportField() []IExportFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExportFieldContext); ok {
			len++
		}
	}

	tst := make([]IExportFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExportFieldContext); ok {
			tst[i] = t.(IExportFieldContext)
			i++
		}
	}

	return tst
}

func (s *DataStructContext) ExportField(i int) IExportFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportFieldContext)
}

func (s *DataStructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataStructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataStructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDataStruct(s)
	}
}

func (s *DataStructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDataStruct(s)
	}
}

func (s *DataStructContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDataStruct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) DataStruct() (localctx IDataStructContext) {
	localctx = NewDataStructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ElasticSQLParserRULE_dataStruct)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1157)
		p.Match(ElasticSQLParserSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1158)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1159)

		var _x = p.StrictIdentifier()

		localctx.(*DataStructContext).tableName = _x
	}
	{
		p.SetState(1160)
		p.Match(ElasticSQLParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1161)

		var _x = p.ExportField()

		localctx.(*DataStructContext)._exportField = _x
	}
	localctx.(*DataStructContext).fields = append(localctx.(*DataStructContext).fields, localctx.(*DataStructContext)._exportField)
	p.SetState(1166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1162)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1163)

			var _x = p.ExportField()

			localctx.(*DataStructContext)._exportField = _x
		}
		localctx.(*DataStructContext).fields = append(localctx.(*DataStructContext).fields, localctx.(*DataStructContext)._exportField)

		p.SetState(1168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1169)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinQueryAnalysisStatementContext is an interface to support dynamic dispatch.
type IJoinQueryAnalysisStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// GetSliceMax returns the sliceMax token.
	GetSliceMax() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// SetSliceMax sets the sliceMax token.
	SetSliceMax(antlr.Token)

	// Get_fieldIdentifier returns the _fieldIdentifier rule contexts.
	Get_fieldIdentifier() IFieldIdentifierContext

	// GetArithmetic returns the arithmetic rule contexts.
	GetArithmetic() IArithmeticExpressionContext

	// GetPostAs returns the postAs rule contexts.
	GetPostAs() IStrictIdentifierContext

	// Get_indexIdentifier returns the _indexIdentifier rule contexts.
	Get_indexIdentifier() IIndexIdentifierContext

	// GetAAs returns the aAs rule contexts.
	GetAAs() IStrictIdentifierContext

	// GetTableB returns the tableB rule contexts.
	GetTableB() IStrictIdentifierContext

	// GetBAs returns the bAs rule contexts.
	GetBAs() IStrictIdentifierContext

	// GetFirst returns the first rule contexts.
	GetFirst() IFieldIdentifierContext

	// GetSecond returns the second rule contexts.
	GetSecond() IFieldIdentifierContext

	// Get_sortItem returns the _sortItem rule contexts.
	Get_sortItem() ISortItemContext

	// GetSliceField returns the sliceField rule contexts.
	GetSliceField() IFieldIdentifierContext

	// Get_aggStatement returns the _aggStatement rule contexts.
	Get_aggStatement() IAggStatementContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// Set_fieldIdentifier sets the _fieldIdentifier rule contexts.
	Set_fieldIdentifier(IFieldIdentifierContext)

	// SetArithmetic sets the arithmetic rule contexts.
	SetArithmetic(IArithmeticExpressionContext)

	// SetPostAs sets the postAs rule contexts.
	SetPostAs(IStrictIdentifierContext)

	// Set_indexIdentifier sets the _indexIdentifier rule contexts.
	Set_indexIdentifier(IIndexIdentifierContext)

	// SetAAs sets the aAs rule contexts.
	SetAAs(IStrictIdentifierContext)

	// SetTableB sets the tableB rule contexts.
	SetTableB(IStrictIdentifierContext)

	// SetBAs sets the bAs rule contexts.
	SetBAs(IStrictIdentifierContext)

	// SetFirst sets the first rule contexts.
	SetFirst(IFieldIdentifierContext)

	// SetSecond sets the second rule contexts.
	SetSecond(IFieldIdentifierContext)

	// Set_sortItem sets the _sortItem rule contexts.
	Set_sortItem(ISortItemContext)

	// SetSliceField sets the sliceField rule contexts.
	SetSliceField(IFieldIdentifierContext)

	// Set_aggStatement sets the _aggStatement rule contexts.
	Set_aggStatement(IAggStatementContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// GetFields returns the fields rule context list.
	GetFields() []IFieldIdentifierContext

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexIdentifierContext

	// GetSorts returns the sorts rule context list.
	GetSorts() []ISortItemContext

	// GetAggs returns the aggs rule context list.
	GetAggs() []IAggStatementContext

	// SetFields sets the fields rule context list.
	SetFields([]IFieldIdentifierContext)

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexIdentifierContext)

	// SetSorts sets the sorts rule context list.
	SetSorts([]ISortItemContext)

	// SetAggs sets the aggs rule context list.
	SetAggs([]IAggStatementContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	ON() antlr.TerminalNode
	EQ() antlr.TerminalNode
	AllIndexIdentifier() []IIndexIdentifierContext
	IndexIdentifier(i int) IIndexIdentifierContext
	AllStrictIdentifier() []IStrictIdentifierContext
	StrictIdentifier(i int) IStrictIdentifierContext
	AllFieldIdentifier() []IFieldIdentifierContext
	FieldIdentifier(i int) IFieldIdentifierContext
	POST_EXPR() antlr.TerminalNode
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	WHERE() antlr.TerminalNode
	WhereExpression() IWhereExpressionContext
	MEM() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	SLICE() antlr.TerminalNode
	ExportStatement() IExportStatementContext
	AGG() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ArithmeticExpression() IArithmeticExpressionContext
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllLONG() []antlr.TerminalNode
	LONG(i int) antlr.TerminalNode
	AllAggStatement() []IAggStatementContext
	AggStatement(i int) IAggStatementContext
	LEFT() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RIGHT() antlr.TerminalNode

	// IsJoinQueryAnalysisStatementContext differentiates from other interfaces.
	IsJoinQueryAnalysisStatementContext()
}

type JoinQueryAnalysisStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_fieldIdentifier IFieldIdentifierContext
	fields           []IFieldIdentifierContext
	arithmetic       IArithmeticExpressionContext
	postAs           IStrictIdentifierContext
	_indexIdentifier IIndexIdentifierContext
	indexes          []IIndexIdentifierContext
	aAs              IStrictIdentifierContext
	kind             antlr.Token
	tableB           IStrictIdentifierContext
	bAs              IStrictIdentifierContext
	first            IFieldIdentifierContext
	second           IFieldIdentifierContext
	_sortItem        ISortItemContext
	sorts            []ISortItemContext
	limit            antlr.Token
	sliceMax         antlr.Token
	sliceField       IFieldIdentifierContext
	_aggStatement    IAggStatementContext
	aggs             []IAggStatementContext
	statName         IStrictIdentifierContext
}

func NewEmptyJoinQueryAnalysisStatementContext() *JoinQueryAnalysisStatementContext {
	var p = new(JoinQueryAnalysisStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_joinQueryAnalysisStatement
	return p
}

func InitEmptyJoinQueryAnalysisStatementContext(p *JoinQueryAnalysisStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_joinQueryAnalysisStatement
}

func (*JoinQueryAnalysisStatementContext) IsJoinQueryAnalysisStatementContext() {}

func NewJoinQueryAnalysisStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinQueryAnalysisStatementContext {
	var p = new(JoinQueryAnalysisStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_joinQueryAnalysisStatement

	return p
}

func (s *JoinQueryAnalysisStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinQueryAnalysisStatementContext) GetKind() antlr.Token { return s.kind }

func (s *JoinQueryAnalysisStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *JoinQueryAnalysisStatementContext) GetSliceMax() antlr.Token { return s.sliceMax }

func (s *JoinQueryAnalysisStatementContext) SetKind(v antlr.Token) { s.kind = v }

func (s *JoinQueryAnalysisStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *JoinQueryAnalysisStatementContext) SetSliceMax(v antlr.Token) { s.sliceMax = v }

func (s *JoinQueryAnalysisStatementContext) Get_fieldIdentifier() IFieldIdentifierContext {
	return s._fieldIdentifier
}

func (s *JoinQueryAnalysisStatementContext) GetArithmetic() IArithmeticExpressionContext {
	return s.arithmetic
}

func (s *JoinQueryAnalysisStatementContext) GetPostAs() IStrictIdentifierContext { return s.postAs }

func (s *JoinQueryAnalysisStatementContext) Get_indexIdentifier() IIndexIdentifierContext {
	return s._indexIdentifier
}

func (s *JoinQueryAnalysisStatementContext) GetAAs() IStrictIdentifierContext { return s.aAs }

func (s *JoinQueryAnalysisStatementContext) GetTableB() IStrictIdentifierContext { return s.tableB }

func (s *JoinQueryAnalysisStatementContext) GetBAs() IStrictIdentifierContext { return s.bAs }

func (s *JoinQueryAnalysisStatementContext) GetFirst() IFieldIdentifierContext { return s.first }

func (s *JoinQueryAnalysisStatementContext) GetSecond() IFieldIdentifierContext { return s.second }

func (s *JoinQueryAnalysisStatementContext) Get_sortItem() ISortItemContext { return s._sortItem }

func (s *JoinQueryAnalysisStatementContext) GetSliceField() IFieldIdentifierContext {
	return s.sliceField
}

func (s *JoinQueryAnalysisStatementContext) Get_aggStatement() IAggStatementContext {
	return s._aggStatement
}

func (s *JoinQueryAnalysisStatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *JoinQueryAnalysisStatementContext) Set_fieldIdentifier(v IFieldIdentifierContext) {
	s._fieldIdentifier = v
}

func (s *JoinQueryAnalysisStatementContext) SetArithmetic(v IArithmeticExpressionContext) {
	s.arithmetic = v
}

func (s *JoinQueryAnalysisStatementContext) SetPostAs(v IStrictIdentifierContext) { s.postAs = v }

func (s *JoinQueryAnalysisStatementContext) Set_indexIdentifier(v IIndexIdentifierContext) {
	s._indexIdentifier = v
}

func (s *JoinQueryAnalysisStatementContext) SetAAs(v IStrictIdentifierContext) { s.aAs = v }

func (s *JoinQueryAnalysisStatementContext) SetTableB(v IStrictIdentifierContext) { s.tableB = v }

func (s *JoinQueryAnalysisStatementContext) SetBAs(v IStrictIdentifierContext) { s.bAs = v }

func (s *JoinQueryAnalysisStatementContext) SetFirst(v IFieldIdentifierContext) { s.first = v }

func (s *JoinQueryAnalysisStatementContext) SetSecond(v IFieldIdentifierContext) { s.second = v }

func (s *JoinQueryAnalysisStatementContext) Set_sortItem(v ISortItemContext) { s._sortItem = v }

func (s *JoinQueryAnalysisStatementContext) SetSliceField(v IFieldIdentifierContext) {
	s.sliceField = v
}

func (s *JoinQueryAnalysisStatementContext) Set_aggStatement(v IAggStatementContext) {
	s._aggStatement = v
}

func (s *JoinQueryAnalysisStatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *JoinQueryAnalysisStatementContext) GetFields() []IFieldIdentifierContext { return s.fields }

func (s *JoinQueryAnalysisStatementContext) GetIndexes() []IIndexIdentifierContext { return s.indexes }

func (s *JoinQueryAnalysisStatementContext) GetSorts() []ISortItemContext { return s.sorts }

func (s *JoinQueryAnalysisStatementContext) GetAggs() []IAggStatementContext { return s.aggs }

func (s *JoinQueryAnalysisStatementContext) SetFields(v []IFieldIdentifierContext) { s.fields = v }

func (s *JoinQueryAnalysisStatementContext) SetIndexes(v []IIndexIdentifierContext) { s.indexes = v }

func (s *JoinQueryAnalysisStatementContext) SetSorts(v []ISortItemContext) { s.sorts = v }

func (s *JoinQueryAnalysisStatementContext) SetAggs(v []IAggStatementContext) { s.aggs = v }

func (s *JoinQueryAnalysisStatementContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSELECT, 0)
}

func (s *JoinQueryAnalysisStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFROM, 0)
}

func (s *JoinQueryAnalysisStatementContext) JOIN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserJOIN, 0)
}

func (s *JoinQueryAnalysisStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserON, 0)
}

func (s *JoinQueryAnalysisStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *JoinQueryAnalysisStatementContext) AllIndexIdentifier() []IIndexIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIndexIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexIdentifierContext); ok {
			tst[i] = t.(IIndexIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinQueryAnalysisStatementContext) IndexIdentifier(i int) IIndexIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexIdentifierContext)
}

func (s *JoinQueryAnalysisStatementContext) AllStrictIdentifier() []IStrictIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IStrictIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrictIdentifierContext); ok {
			tst[i] = t.(IStrictIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinQueryAnalysisStatementContext) StrictIdentifier(i int) IStrictIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *JoinQueryAnalysisStatementContext) AllFieldIdentifier() []IFieldIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IFieldIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldIdentifierContext); ok {
			tst[i] = t.(IFieldIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinQueryAnalysisStatementContext) FieldIdentifier(i int) IFieldIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *JoinQueryAnalysisStatementContext) POST_EXPR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPOST_EXPR, 0)
}

func (s *JoinQueryAnalysisStatementContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserAS)
}

func (s *JoinQueryAnalysisStatementContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAS, i)
}

func (s *JoinQueryAnalysisStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWHERE, 0)
}

func (s *JoinQueryAnalysisStatementContext) WhereExpression() IWhereExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *JoinQueryAnalysisStatementContext) MEM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMEM, 0)
}

func (s *JoinQueryAnalysisStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserORDER, 0)
}

func (s *JoinQueryAnalysisStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *JoinQueryAnalysisStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIMIT, 0)
}

func (s *JoinQueryAnalysisStatementContext) SLICE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSLICE, 0)
}

func (s *JoinQueryAnalysisStatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *JoinQueryAnalysisStatementContext) AGG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAGG, 0)
}

func (s *JoinQueryAnalysisStatementContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *JoinQueryAnalysisStatementContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *JoinQueryAnalysisStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *JoinQueryAnalysisStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *JoinQueryAnalysisStatementContext) AllLONG() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserLONG)
}

func (s *JoinQueryAnalysisStatementContext) LONG(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, i)
}

func (s *JoinQueryAnalysisStatementContext) AllAggStatement() []IAggStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAggStatementContext); ok {
			len++
		}
	}

	tst := make([]IAggStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAggStatementContext); ok {
			tst[i] = t.(IAggStatementContext)
			i++
		}
	}

	return tst
}

func (s *JoinQueryAnalysisStatementContext) AggStatement(i int) IAggStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggStatementContext)
}

func (s *JoinQueryAnalysisStatementContext) LEFT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLEFT, 0)
}

func (s *JoinQueryAnalysisStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserALL, 0)
}

func (s *JoinQueryAnalysisStatementContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRIGHT, 0)
}

func (s *JoinQueryAnalysisStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinQueryAnalysisStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinQueryAnalysisStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterJoinQueryAnalysisStatement(s)
	}
}

func (s *JoinQueryAnalysisStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitJoinQueryAnalysisStatement(s)
	}
}

func (s *JoinQueryAnalysisStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitJoinQueryAnalysisStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) JoinQueryAnalysisStatement() (localctx IJoinQueryAnalysisStatementContext) {
	localctx = NewJoinQueryAnalysisStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ElasticSQLParserRULE_joinQueryAnalysisStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1171)
		p.Match(ElasticSQLParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(1172)

		var _x = p.FieldIdentifier()

		localctx.(*JoinQueryAnalysisStatementContext)._fieldIdentifier = _x
	}
	localctx.(*JoinQueryAnalysisStatementContext).fields = append(localctx.(*JoinQueryAnalysisStatementContext).fields, localctx.(*JoinQueryAnalysisStatementContext)._fieldIdentifier)
	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1173)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1174)

				var _x = p.FieldIdentifier()

				localctx.(*JoinQueryAnalysisStatementContext)._fieldIdentifier = _x
			}
			localctx.(*JoinQueryAnalysisStatementContext).fields = append(localctx.(*JoinQueryAnalysisStatementContext).fields, localctx.(*JoinQueryAnalysisStatementContext)._fieldIdentifier)

		}
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__3 {
		{
			p.SetState(1180)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1181)
			p.Match(ElasticSQLParserPOST_EXPR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1182)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1183)

			var _x = p.ArithmeticExpression()

			localctx.(*JoinQueryAnalysisStatementContext).arithmetic = _x
		}
		{
			p.SetState(1184)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserAS {
			{
				p.SetState(1185)
				p.Match(ElasticSQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1186)

				var _x = p.StrictIdentifier()

				localctx.(*JoinQueryAnalysisStatementContext).postAs = _x
			}

		}

	}
	{
		p.SetState(1191)
		p.Match(ElasticSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1192)

		var _x = p.IndexIdentifier()

		localctx.(*JoinQueryAnalysisStatementContext)._indexIdentifier = _x
	}
	localctx.(*JoinQueryAnalysisStatementContext).indexes = append(localctx.(*JoinQueryAnalysisStatementContext).indexes, localctx.(*JoinQueryAnalysisStatementContext)._indexIdentifier)
	p.SetState(1197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1193)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1194)

			var _x = p.IndexIdentifier()

			localctx.(*JoinQueryAnalysisStatementContext)._indexIdentifier = _x
		}
		localctx.(*JoinQueryAnalysisStatementContext).indexes = append(localctx.(*JoinQueryAnalysisStatementContext).indexes, localctx.(*JoinQueryAnalysisStatementContext)._indexIdentifier)

		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserAS {
		{
			p.SetState(1200)
			p.Match(ElasticSQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1201)

			var _x = p.StrictIdentifier()

			localctx.(*JoinQueryAnalysisStatementContext).aAs = _x
		}

	}
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserWHERE {
		{
			p.SetState(1204)
			p.Match(ElasticSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1205)
			p.WhereExpression()
		}

	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMEM {
		{
			p.SetState(1208)
			p.Match(ElasticSQLParserMEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-55)) & ^0x3f) == 0 && ((int64(1)<<(_la-55))&805306369) != 0 {
		{
			p.SetState(1211)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*JoinQueryAnalysisStatementContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-55)) & ^0x3f) == 0 && ((int64(1)<<(_la-55))&805306369) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*JoinQueryAnalysisStatementContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1214)
		p.Match(ElasticSQLParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1215)

		var _x = p.StrictIdentifier()

		localctx.(*JoinQueryAnalysisStatementContext).tableB = _x
	}
	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserAS {
		{
			p.SetState(1216)
			p.Match(ElasticSQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1217)

			var _x = p.StrictIdentifier()

			localctx.(*JoinQueryAnalysisStatementContext).bAs = _x
		}

	}
	{
		p.SetState(1220)
		p.Match(ElasticSQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1221)

		var _x = p.FieldIdentifier()

		localctx.(*JoinQueryAnalysisStatementContext).first = _x
	}
	{
		p.SetState(1222)
		p.Match(ElasticSQLParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1223)

		var _x = p.FieldIdentifier()

		localctx.(*JoinQueryAnalysisStatementContext).second = _x
	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserORDER {
		{
			p.SetState(1224)
			p.Match(ElasticSQLParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1225)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1226)

			var _x = p.SortItem()

			localctx.(*JoinQueryAnalysisStatementContext)._sortItem = _x
		}
		localctx.(*JoinQueryAnalysisStatementContext).sorts = append(localctx.(*JoinQueryAnalysisStatementContext).sorts, localctx.(*JoinQueryAnalysisStatementContext)._sortItem)
		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1227)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1228)

				var _x = p.SortItem()

				localctx.(*JoinQueryAnalysisStatementContext)._sortItem = _x
			}
			localctx.(*JoinQueryAnalysisStatementContext).sorts = append(localctx.(*JoinQueryAnalysisStatementContext).sorts, localctx.(*JoinQueryAnalysisStatementContext)._sortItem)

			p.SetState(1233)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserLIMIT {
		{
			p.SetState(1236)
			p.Match(ElasticSQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1237)

			var _m = p.Match(ElasticSQLParserLONG)

			localctx.(*JoinQueryAnalysisStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserSLICE {
		{
			p.SetState(1240)
			p.Match(ElasticSQLParserSLICE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserT__4 {
			{
				p.SetState(1241)
				p.Match(ElasticSQLParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1242)

				var _m = p.Match(ElasticSQLParserLONG)

				localctx.(*JoinQueryAnalysisStatementContext).sliceMax = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1245)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ElasticSQLParserT__3 {
				{
					p.SetState(1243)
					p.Match(ElasticSQLParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1244)

					var _x = p.FieldIdentifier()

					localctx.(*JoinQueryAnalysisStatementContext).sliceField = _x
				}

			}
			{
				p.SetState(1247)
				p.Match(ElasticSQLParserT__5)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserEXPORT {
		{
			p.SetState(1252)
			p.ExportStatement()
		}

	}
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserAGG {
		{
			p.SetState(1255)
			p.Match(ElasticSQLParserAGG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1256)

			var _x = p.AggStatement()

			localctx.(*JoinQueryAnalysisStatementContext)._aggStatement = _x
		}
		localctx.(*JoinQueryAnalysisStatementContext).aggs = append(localctx.(*JoinQueryAnalysisStatementContext).aggs, localctx.(*JoinQueryAnalysisStatementContext)._aggStatement)
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__8 {
			{
				p.SetState(1257)
				p.Match(ElasticSQLParserT__8)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1258)

				var _x = p.AggStatement()

				localctx.(*JoinQueryAnalysisStatementContext)._aggStatement = _x
			}
			localctx.(*JoinQueryAnalysisStatementContext).aggs = append(localctx.(*JoinQueryAnalysisStatementContext).aggs, localctx.(*JoinQueryAnalysisStatementContext)._aggStatement)

			p.SetState(1263)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(1266)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1267)

			var _x = p.StrictIdentifier()

			localctx.(*JoinQueryAnalysisStatementContext).statName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFront returns the front rule contexts.
	GetFront() IStrictIdentifierContext

	// GetSink returns the sink rule contexts.
	GetSink() IStrictIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IIndexNameContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IFieldListContext

	// GetValueCluase returns the valueCluase rule contexts.
	GetValueCluase() IValueListContext

	// GetIdField returns the idField rule contexts.
	GetIdField() IFieldIdentifierContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// SetFront sets the front rule contexts.
	SetFront(IStrictIdentifierContext)

	// SetSink sets the sink rule contexts.
	SetSink(IStrictIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IIndexNameContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IFieldListContext)

	// SetValueCluase sets the valueCluase rule contexts.
	SetValueCluase(IValueListContext)

	// SetIdField sets the idField rule contexts.
	SetIdField(IFieldIdentifierContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// Getter signatures
	INSERT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	IndexName() IIndexNameContext
	USING() antlr.TerminalNode
	MQL() antlr.TerminalNode
	DOT() antlr.TerminalNode
	ON() antlr.TerminalNode
	PK() antlr.TerminalNode
	MAP() antlr.TerminalNode
	AllStrictIdentifier() []IStrictIdentifierContext
	StrictIdentifier(i int) IStrictIdentifierContext
	FieldList() IFieldListContext
	FieldIdentifier() IFieldIdentifierContext
	UUID() antlr.TerminalNode
	ValueList() IValueListContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	front       IStrictIdentifierContext
	sink        IStrictIdentifierContext
	table       IIndexNameContext
	columns     IFieldListContext
	valueCluase IValueListContext
	idField     IFieldIdentifierContext
	statName    IStrictIdentifierContext
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) GetFront() IStrictIdentifierContext { return s.front }

func (s *InsertStatementContext) GetSink() IStrictIdentifierContext { return s.sink }

func (s *InsertStatementContext) GetTable() IIndexNameContext { return s.table }

func (s *InsertStatementContext) GetColumns() IFieldListContext { return s.columns }

func (s *InsertStatementContext) GetValueCluase() IValueListContext { return s.valueCluase }

func (s *InsertStatementContext) GetIdField() IFieldIdentifierContext { return s.idField }

func (s *InsertStatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *InsertStatementContext) SetFront(v IStrictIdentifierContext) { s.front = v }

func (s *InsertStatementContext) SetSink(v IStrictIdentifierContext) { s.sink = v }

func (s *InsertStatementContext) SetTable(v IIndexNameContext) { s.table = v }

func (s *InsertStatementContext) SetColumns(v IFieldListContext) { s.columns = v }

func (s *InsertStatementContext) SetValueCluase(v IValueListContext) { s.valueCluase = v }

func (s *InsertStatementContext) SetIdField(v IFieldIdentifierContext) { s.idField = v }

func (s *InsertStatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINSERT, 0)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINTO, 0)
}

func (s *InsertStatementContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *InsertStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUSING, 0)
}

func (s *InsertStatementContext) MQL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMQL, 0)
}

func (s *InsertStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOT, 0)
}

func (s *InsertStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserON, 0)
}

func (s *InsertStatementContext) PK() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPK, 0)
}

func (s *InsertStatementContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *InsertStatementContext) AllStrictIdentifier() []IStrictIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IStrictIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrictIdentifierContext); ok {
			tst[i] = t.(IStrictIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) StrictIdentifier(i int) IStrictIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *InsertStatementContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *InsertStatementContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *InsertStatementContext) UUID() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUUID, 0)
}

func (s *InsertStatementContext) ValueList() IValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueListContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ElasticSQLParserRULE_insertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserUSING {
		{
			p.SetState(1270)
			p.Match(ElasticSQLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1271)

			var _x = p.StrictIdentifier()

			localctx.(*InsertStatementContext).front = _x
		}

	}
	p.SetState(1275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMQL {
		{
			p.SetState(1274)
			p.Match(ElasticSQLParserMQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1277)
		p.Match(ElasticSQLParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1278)
		p.Match(ElasticSQLParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1279)

			var _x = p.StrictIdentifier()

			localctx.(*InsertStatementContext).sink = _x
		}
		{
			p.SetState(1280)
			p.Match(ElasticSQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1284)

		var _x = p.IndexName()

		localctx.(*InsertStatementContext).table = _x
	}
	p.SetState(1289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__4 {
		{
			p.SetState(1285)

			var _x = p.FieldList()

			localctx.(*InsertStatementContext).columns = _x
		}
		p.SetState(1287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserVALUES {
			{
				p.SetState(1286)

				var _x = p.ValueList()

				localctx.(*InsertStatementContext).valueCluase = _x
			}

		}

	}
	p.SetState(1297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserON {
		{
			p.SetState(1291)
			p.Match(ElasticSQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserUUID {
			{
				p.SetState(1292)
				p.Match(ElasticSQLParserUUID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1295)
			p.Match(ElasticSQLParserPK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1296)

			var _x = p.FieldIdentifier()

			localctx.(*InsertStatementContext).idField = _x
		}

	}
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(1299)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1300)

			var _x = p.StrictIdentifier()

			localctx.(*InsertStatementContext).statName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_fieldDefine returns the _fieldDefine rule contexts.
	Get_fieldDefine() IFieldDefineContext

	// Set_fieldDefine sets the _fieldDefine rule contexts.
	Set_fieldDefine(IFieldDefineContext)

	// GetFields returns the fields rule context list.
	GetFields() []IFieldDefineContext

	// SetFields sets the fields rule context list.
	SetFields([]IFieldDefineContext)

	// Getter signatures
	AllFieldDefine() []IFieldDefineContext
	FieldDefine(i int) IFieldDefineContext

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_fieldDefine IFieldDefineContext
	fields       []IFieldDefineContext
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) Get_fieldDefine() IFieldDefineContext { return s._fieldDefine }

func (s *FieldListContext) Set_fieldDefine(v IFieldDefineContext) { s._fieldDefine = v }

func (s *FieldListContext) GetFields() []IFieldDefineContext { return s.fields }

func (s *FieldListContext) SetFields(v []IFieldDefineContext) { s.fields = v }

func (s *FieldListContext) AllFieldDefine() []IFieldDefineContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDefineContext); ok {
			len++
		}
	}

	tst := make([]IFieldDefineContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDefineContext); ok {
			tst[i] = t.(IFieldDefineContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) FieldDefine(i int) IFieldDefineContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDefineContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDefineContext)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (s *FieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ElasticSQLParserRULE_fieldList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1303)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(1304)

		var _x = p.FieldDefine()

		localctx.(*FieldListContext)._fieldDefine = _x
	}
	localctx.(*FieldListContext).fields = append(localctx.(*FieldListContext).fields, localctx.(*FieldListContext)._fieldDefine)
	p.SetState(1309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1305)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1306)

			var _x = p.FieldDefine()

			localctx.(*FieldListContext)._fieldDefine = _x
		}
		localctx.(*FieldListContext).fields = append(localctx.(*FieldListContext).fields, localctx.(*FieldListContext)._fieldDefine)

		p.SetState(1311)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	{
		p.SetState(1312)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueListContext is an interface to support dynamic dispatch.
type IValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_paramValues returns the _paramValues rule contexts.
	Get_paramValues() IParamValuesContext

	// Set_paramValues sets the _paramValues rule contexts.
	Set_paramValues(IParamValuesContext)

	// GetValuesList returns the valuesList rule context list.
	GetValuesList() []IParamValuesContext

	// SetValuesList sets the valuesList rule context list.
	SetValuesList([]IParamValuesContext)

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllParamValues() []IParamValuesContext
	ParamValues(i int) IParamValuesContext

	// IsValueListContext differentiates from other interfaces.
	IsValueListContext()
}

type ValueListContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_paramValues IParamValuesContext
	valuesList   []IParamValuesContext
}

func NewEmptyValueListContext() *ValueListContext {
	var p = new(ValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_valueList
	return p
}

func InitEmptyValueListContext(p *ValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_valueList
}

func (*ValueListContext) IsValueListContext() {}

func NewValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueListContext {
	var p = new(ValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_valueList

	return p
}

func (s *ValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueListContext) Get_paramValues() IParamValuesContext { return s._paramValues }

func (s *ValueListContext) Set_paramValues(v IParamValuesContext) { s._paramValues = v }

func (s *ValueListContext) GetValuesList() []IParamValuesContext { return s.valuesList }

func (s *ValueListContext) SetValuesList(v []IParamValuesContext) { s.valuesList = v }

func (s *ValueListContext) VALUES() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserVALUES, 0)
}

func (s *ValueListContext) AllParamValues() []IParamValuesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamValuesContext); ok {
			len++
		}
	}

	tst := make([]IParamValuesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamValuesContext); ok {
			tst[i] = t.(IParamValuesContext)
			i++
		}
	}

	return tst
}

func (s *ValueListContext) ParamValues(i int) IParamValuesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamValuesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamValuesContext)
}

func (s *ValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterValueList(s)
	}
}

func (s *ValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitValueList(s)
	}
}

func (s *ValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ValueList() (localctx IValueListContext) {
	localctx = NewValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ElasticSQLParserRULE_valueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1314)
		p.Match(ElasticSQLParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1315)

		var _x = p.ParamValues()

		localctx.(*ValueListContext)._paramValues = _x
	}
	localctx.(*ValueListContext).valuesList = append(localctx.(*ValueListContext).valuesList, localctx.(*ValueListContext)._paramValues)
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__3 {
		{
			p.SetState(1316)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1317)

			var _x = p.ParamValues()

			localctx.(*ValueListContext)._paramValues = _x
		}
		localctx.(*ValueListContext).valuesList = append(localctx.(*ValueListContext).valuesList, localctx.(*ValueListContext)._paramValues)

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamValuesContext is an interface to support dynamic dispatch.
type IParamValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_param returns the _param rule contexts.
	Get_param() IParamContext

	// Set_param sets the _param rule contexts.
	Set_param(IParamContext)

	// GetVs returns the vs rule context list.
	GetVs() []IParamContext

	// SetVs sets the vs rule context list.
	SetVs([]IParamContext)

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext

	// IsParamValuesContext differentiates from other interfaces.
	IsParamValuesContext()
}

type ParamValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_param IParamContext
	vs     []IParamContext
}

func NewEmptyParamValuesContext() *ParamValuesContext {
	var p = new(ParamValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_paramValues
	return p
}

func InitEmptyParamValuesContext(p *ParamValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_paramValues
}

func (*ParamValuesContext) IsParamValuesContext() {}

func NewParamValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamValuesContext {
	var p = new(ParamValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_paramValues

	return p
}

func (s *ParamValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamValuesContext) Get_param() IParamContext { return s._param }

func (s *ParamValuesContext) Set_param(v IParamContext) { s._param = v }

func (s *ParamValuesContext) GetVs() []IParamContext { return s.vs }

func (s *ParamValuesContext) SetVs(v []IParamContext) { s.vs = v }

func (s *ParamValuesContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParamValuesContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParamValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterParamValues(s)
	}
}

func (s *ParamValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitParamValues(s)
	}
}

func (s *ParamValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitParamValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ParamValues() (localctx IParamValuesContext) {
	localctx = NewParamValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ElasticSQLParserRULE_paramValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1320)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1321)

		var _x = p.Param()

		localctx.(*ParamValuesContext)._param = _x
	}
	localctx.(*ParamValuesContext).vs = append(localctx.(*ParamValuesContext).vs, localctx.(*ParamValuesContext)._param)
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1322)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1323)

			var _x = p.Param()

			localctx.(*ParamValuesContext)._param = _x
		}
		localctx.(*ParamValuesContext).vs = append(localctx.(*ParamValuesContext).vs, localctx.(*ParamValuesContext)._param)

		p.SetState(1328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1329)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_indexIdentifier returns the _indexIdentifier rule contexts.
	Get_indexIdentifier() IIndexIdentifierContext

	// GetScript returns the script rule contexts.
	GetScript() IScriptPhraseContext

	// Get_updateField returns the _updateField rule contexts.
	Get_updateField() IUpdateFieldContext

	// GetFileName returns the fileName rule contexts.
	GetFileName() IStrContext

	// GetId returns the id rule contexts.
	GetId() IStrContext

	// Get_str returns the _str rule contexts.
	Get_str() IStrContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// Set_indexIdentifier sets the _indexIdentifier rule contexts.
	Set_indexIdentifier(IIndexIdentifierContext)

	// SetScript sets the script rule contexts.
	SetScript(IScriptPhraseContext)

	// Set_updateField sets the _updateField rule contexts.
	Set_updateField(IUpdateFieldContext)

	// SetFileName sets the fileName rule contexts.
	SetFileName(IStrContext)

	// SetId sets the id rule contexts.
	SetId(IStrContext)

	// Set_str sets the _str rule contexts.
	Set_str(IStrContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexIdentifierContext

	// GetFields returns the fields rule context list.
	GetFields() []IUpdateFieldContext

	// GetItems returns the items rule context list.
	GetItems() []IStrContext

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexIdentifierContext)

	// SetFields sets the fields rule context list.
	SetFields([]IUpdateFieldContext)

	// SetItems sets the items rule context list.
	SetItems([]IStrContext)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	UPSERT() antlr.TerminalNode
	AllIndexIdentifier() []IIndexIdentifierContext
	IndexIdentifier(i int) IIndexIdentifierContext
	MAP() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	WhereExpression() IWhereExpressionContext
	BY() antlr.TerminalNode
	IDS_FILE() antlr.TerminalNode
	ID() antlr.TerminalNode
	EQ() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext
	SET() antlr.TerminalNode
	AllStr() []IStrContext
	Str(i int) IStrContext
	ScriptPhrase() IScriptPhraseContext
	AllUpdateField() []IUpdateFieldContext
	UpdateField(i int) IUpdateFieldContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_indexIdentifier IIndexIdentifierContext
	indexes          []IIndexIdentifierContext
	script           IScriptPhraseContext
	_updateField     IUpdateFieldContext
	fields           []IUpdateFieldContext
	fileName         IStrContext
	id               IStrContext
	_str             IStrContext
	items            []IStrContext
	statName         IStrictIdentifierContext
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) Get_indexIdentifier() IIndexIdentifierContext {
	return s._indexIdentifier
}

func (s *UpdateStatementContext) GetScript() IScriptPhraseContext { return s.script }

func (s *UpdateStatementContext) Get_updateField() IUpdateFieldContext { return s._updateField }

func (s *UpdateStatementContext) GetFileName() IStrContext { return s.fileName }

func (s *UpdateStatementContext) GetId() IStrContext { return s.id }

func (s *UpdateStatementContext) Get_str() IStrContext { return s._str }

func (s *UpdateStatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *UpdateStatementContext) Set_indexIdentifier(v IIndexIdentifierContext) {
	s._indexIdentifier = v
}

func (s *UpdateStatementContext) SetScript(v IScriptPhraseContext) { s.script = v }

func (s *UpdateStatementContext) Set_updateField(v IUpdateFieldContext) { s._updateField = v }

func (s *UpdateStatementContext) SetFileName(v IStrContext) { s.fileName = v }

func (s *UpdateStatementContext) SetId(v IStrContext) { s.id = v }

func (s *UpdateStatementContext) Set_str(v IStrContext) { s._str = v }

func (s *UpdateStatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *UpdateStatementContext) GetIndexes() []IIndexIdentifierContext { return s.indexes }

func (s *UpdateStatementContext) GetFields() []IUpdateFieldContext { return s.fields }

func (s *UpdateStatementContext) GetItems() []IStrContext { return s.items }

func (s *UpdateStatementContext) SetIndexes(v []IIndexIdentifierContext) { s.indexes = v }

func (s *UpdateStatementContext) SetFields(v []IUpdateFieldContext) { s.fields = v }

func (s *UpdateStatementContext) SetItems(v []IStrContext) { s.items = v }

func (s *UpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUPDATE, 0)
}

func (s *UpdateStatementContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUPSERT, 0)
}

func (s *UpdateStatementContext) AllIndexIdentifier() []IIndexIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIndexIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexIdentifierContext); ok {
			tst[i] = t.(IIndexIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UpdateStatementContext) IndexIdentifier(i int) IIndexIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexIdentifierContext)
}

func (s *UpdateStatementContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *UpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWHERE, 0)
}

func (s *UpdateStatementContext) WhereExpression() IWhereExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *UpdateStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *UpdateStatementContext) IDS_FILE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIDS_FILE, 0)
}

func (s *UpdateStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserID, 0)
}

func (s *UpdateStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *UpdateStatementContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *UpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSET, 0)
}

func (s *UpdateStatementContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *UpdateStatementContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *UpdateStatementContext) ScriptPhrase() IScriptPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptPhraseContext)
}

func (s *UpdateStatementContext) AllUpdateField() []IUpdateFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateFieldContext); ok {
			len++
		}
	}

	tst := make([]IUpdateFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateFieldContext); ok {
			tst[i] = t.(IUpdateFieldContext)
			i++
		}
	}

	return tst
}

func (s *UpdateStatementContext) UpdateField(i int) IUpdateFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateFieldContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ElasticSQLParserRULE_updateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1331)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ElasticSQLParserUPDATE || _la == ElasticSQLParserUPSERT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1332)

		var _x = p.IndexIdentifier()

		localctx.(*UpdateStatementContext)._indexIdentifier = _x
	}
	localctx.(*UpdateStatementContext).indexes = append(localctx.(*UpdateStatementContext).indexes, localctx.(*UpdateStatementContext)._indexIdentifier)
	p.SetState(1337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1333)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1334)

			var _x = p.IndexIdentifier()

			localctx.(*UpdateStatementContext)._indexIdentifier = _x
		}
		localctx.(*UpdateStatementContext).indexes = append(localctx.(*UpdateStatementContext).indexes, localctx.(*UpdateStatementContext)._indexIdentifier)

		p.SetState(1339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	p.SetState(1341)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3562272993694187488) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-513428087574497293) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&1116914692957083861) != 0) {
		{
			p.SetState(1340)

			var _x = p.ScriptPhrase()

			localctx.(*UpdateStatementContext).script = _x
		}

	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserSET {
		{
			p.SetState(1343)
			p.Match(ElasticSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1344)

			var _x = p.UpdateField()

			localctx.(*UpdateStatementContext)._updateField = _x
		}
		localctx.(*UpdateStatementContext).fields = append(localctx.(*UpdateStatementContext).fields, localctx.(*UpdateStatementContext)._updateField)
		p.SetState(1349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1345)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1346)

				var _x = p.UpdateField()

				localctx.(*UpdateStatementContext)._updateField = _x
			}
			localctx.(*UpdateStatementContext).fields = append(localctx.(*UpdateStatementContext).fields, localctx.(*UpdateStatementContext)._updateField)

			p.SetState(1351)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

	p.SetState(1375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1354)
			p.Match(ElasticSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1355)
			p.WhereExpression()
		}

	case 2:
		{
			p.SetState(1356)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1357)
			p.Match(ElasticSQLParserIDS_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1358)

			var _x = p.Str()

			localctx.(*UpdateStatementContext).fileName = _x
		}

	case 3:
		{
			p.SetState(1359)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1360)
			p.Match(ElasticSQLParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1361)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1362)

			var _x = p.Str()

			localctx.(*UpdateStatementContext).id = _x
		}

	case 4:
		{
			p.SetState(1363)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1364)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1365)

			var _x = p.Str()

			localctx.(*UpdateStatementContext)._str = _x
		}
		localctx.(*UpdateStatementContext).items = append(localctx.(*UpdateStatementContext).items, localctx.(*UpdateStatementContext)._str)
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1366)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1367)

				var _x = p.Str()

				localctx.(*UpdateStatementContext)._str = _x
			}
			localctx.(*UpdateStatementContext).items = append(localctx.(*UpdateStatementContext).items, localctx.(*UpdateStatementContext)._str)

			p.SetState(1372)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1373)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(1377)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1378)

			var _x = p.StrictIdentifier()

			localctx.(*UpdateStatementContext).statName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateFieldContext is an interface to support dynamic dispatch.
type IUpdateFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUpdateFieldContext differentiates from other interfaces.
	IsUpdateFieldContext()
}

type UpdateFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateFieldContext() *UpdateFieldContext {
	var p = new(UpdateFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_updateField
	return p
}

func InitEmptyUpdateFieldContext(p *UpdateFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_updateField
}

func (*UpdateFieldContext) IsUpdateFieldContext() {}

func NewUpdateFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateFieldContext {
	var p = new(UpdateFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_updateField

	return p
}

func (s *UpdateFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateFieldContext) CopyAll(ctx *UpdateFieldContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UpdateFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UpdateReplaceFieldContext struct {
	UpdateFieldContext
	field  IFieldIdentifierContext
	value  IParamContext
	dType  antlr.Token
	_param IParamContext
	values []IParamContext
}

func NewUpdateReplaceFieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateReplaceFieldContext {
	var p = new(UpdateReplaceFieldContext)

	InitEmptyUpdateFieldContext(&p.UpdateFieldContext)
	p.parser = parser
	p.CopyAll(ctx.(*UpdateFieldContext))

	return p
}

func (s *UpdateReplaceFieldContext) GetDType() antlr.Token { return s.dType }

func (s *UpdateReplaceFieldContext) SetDType(v antlr.Token) { s.dType = v }

func (s *UpdateReplaceFieldContext) GetField() IFieldIdentifierContext { return s.field }

func (s *UpdateReplaceFieldContext) GetValue() IParamContext { return s.value }

func (s *UpdateReplaceFieldContext) Get_param() IParamContext { return s._param }

func (s *UpdateReplaceFieldContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *UpdateReplaceFieldContext) SetValue(v IParamContext) { s.value = v }

func (s *UpdateReplaceFieldContext) Set_param(v IParamContext) { s._param = v }

func (s *UpdateReplaceFieldContext) GetValues() []IParamContext { return s.values }

func (s *UpdateReplaceFieldContext) SetValues(v []IParamContext) { s.values = v }

func (s *UpdateReplaceFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateReplaceFieldContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *UpdateReplaceFieldContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *UpdateReplaceFieldContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *UpdateReplaceFieldContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *UpdateReplaceFieldContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *UpdateReplaceFieldContext) LIST() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIST, 0)
}

func (s *UpdateReplaceFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterUpdateReplaceField(s)
	}
}

func (s *UpdateReplaceFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitUpdateReplaceField(s)
	}
}

func (s *UpdateReplaceFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitUpdateReplaceField(s)

	default:
		return t.VisitChildren(s)
	}
}

type UpdateRemoveFieldContext struct {
	UpdateFieldContext
	dType  antlr.Token
	field  IFieldIdentifierContext
	_param IParamContext
	values []IParamContext
}

func NewUpdateRemoveFieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateRemoveFieldContext {
	var p = new(UpdateRemoveFieldContext)

	InitEmptyUpdateFieldContext(&p.UpdateFieldContext)
	p.parser = parser
	p.CopyAll(ctx.(*UpdateFieldContext))

	return p
}

func (s *UpdateRemoveFieldContext) GetDType() antlr.Token { return s.dType }

func (s *UpdateRemoveFieldContext) SetDType(v antlr.Token) { s.dType = v }

func (s *UpdateRemoveFieldContext) GetField() IFieldIdentifierContext { return s.field }

func (s *UpdateRemoveFieldContext) Get_param() IParamContext { return s._param }

func (s *UpdateRemoveFieldContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *UpdateRemoveFieldContext) Set_param(v IParamContext) { s._param = v }

func (s *UpdateRemoveFieldContext) GetValues() []IParamContext { return s.values }

func (s *UpdateRemoveFieldContext) SetValues(v []IParamContext) { s.values = v }

func (s *UpdateRemoveFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateRemoveFieldContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserREMOVE, 0)
}

func (s *UpdateRemoveFieldContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *UpdateRemoveFieldContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *UpdateRemoveFieldContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *UpdateRemoveFieldContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *UpdateRemoveFieldContext) LIST() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIST, 0)
}

func (s *UpdateRemoveFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterUpdateRemoveField(s)
	}
}

func (s *UpdateRemoveFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitUpdateRemoveField(s)
	}
}

func (s *UpdateRemoveFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitUpdateRemoveField(s)

	default:
		return t.VisitChildren(s)
	}
}

type UpdateAddFieldContext struct {
	UpdateFieldContext
	dType  antlr.Token
	field  IFieldIdentifierContext
	_param IParamContext
	values []IParamContext
}

func NewUpdateAddFieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateAddFieldContext {
	var p = new(UpdateAddFieldContext)

	InitEmptyUpdateFieldContext(&p.UpdateFieldContext)
	p.parser = parser
	p.CopyAll(ctx.(*UpdateFieldContext))

	return p
}

func (s *UpdateAddFieldContext) GetDType() antlr.Token { return s.dType }

func (s *UpdateAddFieldContext) SetDType(v antlr.Token) { s.dType = v }

func (s *UpdateAddFieldContext) GetField() IFieldIdentifierContext { return s.field }

func (s *UpdateAddFieldContext) Get_param() IParamContext { return s._param }

func (s *UpdateAddFieldContext) SetField(v IFieldIdentifierContext) { s.field = v }

func (s *UpdateAddFieldContext) Set_param(v IParamContext) { s._param = v }

func (s *UpdateAddFieldContext) GetValues() []IParamContext { return s.values }

func (s *UpdateAddFieldContext) SetValues(v []IParamContext) { s.values = v }

func (s *UpdateAddFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAddFieldContext) ADD() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserADD, 0)
}

func (s *UpdateAddFieldContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *UpdateAddFieldContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *UpdateAddFieldContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *UpdateAddFieldContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *UpdateAddFieldContext) LIST() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIST, 0)
}

func (s *UpdateAddFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterUpdateAddField(s)
	}
}

func (s *UpdateAddFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitUpdateAddField(s)
	}
}

func (s *UpdateAddFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitUpdateAddField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) UpdateField() (localctx IUpdateFieldContext) {
	localctx = NewUpdateFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ElasticSQLParserRULE_updateField)
	var _la int

	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUpdateReplaceFieldContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1381)

				var _x = p.FieldIdentifier()

				localctx.(*UpdateReplaceFieldContext).field = _x
			}
			{
				p.SetState(1382)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1383)

				var _x = p.Param()

				localctx.(*UpdateReplaceFieldContext).value = _x
			}

		case 2:
			{
				p.SetState(1385)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*UpdateReplaceFieldContext).dType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ElasticSQLParserMAP || _la == ElasticSQLParserLIST) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*UpdateReplaceFieldContext).dType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1386)
				p.Match(ElasticSQLParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1387)

				var _x = p.FieldIdentifier()

				localctx.(*UpdateReplaceFieldContext).field = _x
			}
			{
				p.SetState(1388)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1389)

				var _x = p.Param()

				localctx.(*UpdateReplaceFieldContext)._param = _x
			}
			localctx.(*UpdateReplaceFieldContext).values = append(localctx.(*UpdateReplaceFieldContext).values, localctx.(*UpdateReplaceFieldContext)._param)
			p.SetState(1394)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ElasticSQLParserT__3 {
				{
					p.SetState(1390)
					p.Match(ElasticSQLParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1391)

					var _x = p.Param()

					localctx.(*UpdateReplaceFieldContext)._param = _x
				}
				localctx.(*UpdateReplaceFieldContext).values = append(localctx.(*UpdateReplaceFieldContext).values, localctx.(*UpdateReplaceFieldContext)._param)

				p.SetState(1396)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1397)
				p.Match(ElasticSQLParserT__5)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		localctx = NewUpdateAddFieldContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1401)
			p.Match(ElasticSQLParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1402)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UpdateAddFieldContext).dType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ElasticSQLParserMAP || _la == ElasticSQLParserLIST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UpdateAddFieldContext).dType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1403)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1404)

			var _x = p.FieldIdentifier()

			localctx.(*UpdateAddFieldContext).field = _x
		}
		{
			p.SetState(1405)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1406)

			var _x = p.Param()

			localctx.(*UpdateAddFieldContext)._param = _x
		}
		localctx.(*UpdateAddFieldContext).values = append(localctx.(*UpdateAddFieldContext).values, localctx.(*UpdateAddFieldContext)._param)
		p.SetState(1411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1407)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1408)

				var _x = p.Param()

				localctx.(*UpdateAddFieldContext)._param = _x
			}
			localctx.(*UpdateAddFieldContext).values = append(localctx.(*UpdateAddFieldContext).values, localctx.(*UpdateAddFieldContext)._param)

			p.SetState(1413)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1414)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewUpdateRemoveFieldContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1416)
			p.Match(ElasticSQLParserREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1417)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UpdateRemoveFieldContext).dType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ElasticSQLParserMAP || _la == ElasticSQLParserLIST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UpdateRemoveFieldContext).dType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1418)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1419)

			var _x = p.FieldIdentifier()

			localctx.(*UpdateRemoveFieldContext).field = _x
		}
		{
			p.SetState(1420)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1421)

			var _x = p.Param()

			localctx.(*UpdateRemoveFieldContext)._param = _x
		}
		localctx.(*UpdateRemoveFieldContext).values = append(localctx.(*UpdateRemoveFieldContext).values, localctx.(*UpdateRemoveFieldContext)._param)
		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1422)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1423)

				var _x = p.Param()

				localctx.(*UpdateRemoveFieldContext)._param = _x
			}
			localctx.(*UpdateRemoveFieldContext).values = append(localctx.(*UpdateRemoveFieldContext).values, localctx.(*UpdateRemoveFieldContext)._param)

			p.SetState(1428)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1429)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBatchUpdateStatementContext is an interface to support dynamic dispatch.
type IBatchUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_str returns the _str rule contexts.
	Get_str() IStrContext

	// GetScript returns the script rule contexts.
	GetScript() IScriptPhraseContext

	// Get_fieldIdentifier returns the _fieldIdentifier rule contexts.
	Get_fieldIdentifier() IFieldIdentifierContext

	// Get_param returns the _param rule contexts.
	Get_param() IParamContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// Set_str sets the _str rule contexts.
	Set_str(IStrContext)

	// SetScript sets the script rule contexts.
	SetScript(IScriptPhraseContext)

	// Set_fieldIdentifier sets the _fieldIdentifier rule contexts.
	Set_fieldIdentifier(IFieldIdentifierContext)

	// Set_param sets the _param rule contexts.
	Set_param(IParamContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// GetDocs returns the docs rule context list.
	GetDocs() []IStrContext

	// GetFields returns the fields rule context list.
	GetFields() []IFieldIdentifierContext

	// GetValues returns the values rule context list.
	GetValues() []IParamContext

	// SetDocs sets the docs rule context list.
	SetDocs([]IStrContext)

	// SetFields sets the fields rule context list.
	SetFields([]IFieldIdentifierContext)

	// SetValues sets the values rule context list.
	SetValues([]IParamContext)

	// Getter signatures
	BATCH_UPDATE() antlr.TerminalNode
	BATCH_UPSERT() antlr.TerminalNode
	AllStr() []IStrContext
	Str(i int) IStrContext
	MAP() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext
	SET() antlr.TerminalNode
	ScriptPhrase() IScriptPhraseContext
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	AllFieldIdentifier() []IFieldIdentifierContext
	FieldIdentifier(i int) IFieldIdentifierContext
	AllParam() []IParamContext
	Param(i int) IParamContext

	// IsBatchUpdateStatementContext differentiates from other interfaces.
	IsBatchUpdateStatementContext()
}

type BatchUpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_str             IStrContext
	docs             []IStrContext
	script           IScriptPhraseContext
	_fieldIdentifier IFieldIdentifierContext
	fields           []IFieldIdentifierContext
	_param           IParamContext
	values           []IParamContext
	statName         IStrictIdentifierContext
}

func NewEmptyBatchUpdateStatementContext() *BatchUpdateStatementContext {
	var p = new(BatchUpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_batchUpdateStatement
	return p
}

func InitEmptyBatchUpdateStatementContext(p *BatchUpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_batchUpdateStatement
}

func (*BatchUpdateStatementContext) IsBatchUpdateStatementContext() {}

func NewBatchUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BatchUpdateStatementContext {
	var p = new(BatchUpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_batchUpdateStatement

	return p
}

func (s *BatchUpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BatchUpdateStatementContext) Get_str() IStrContext { return s._str }

func (s *BatchUpdateStatementContext) GetScript() IScriptPhraseContext { return s.script }

func (s *BatchUpdateStatementContext) Get_fieldIdentifier() IFieldIdentifierContext {
	return s._fieldIdentifier
}

func (s *BatchUpdateStatementContext) Get_param() IParamContext { return s._param }

func (s *BatchUpdateStatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *BatchUpdateStatementContext) Set_str(v IStrContext) { s._str = v }

func (s *BatchUpdateStatementContext) SetScript(v IScriptPhraseContext) { s.script = v }

func (s *BatchUpdateStatementContext) Set_fieldIdentifier(v IFieldIdentifierContext) {
	s._fieldIdentifier = v
}

func (s *BatchUpdateStatementContext) Set_param(v IParamContext) { s._param = v }

func (s *BatchUpdateStatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *BatchUpdateStatementContext) GetDocs() []IStrContext { return s.docs }

func (s *BatchUpdateStatementContext) GetFields() []IFieldIdentifierContext { return s.fields }

func (s *BatchUpdateStatementContext) GetValues() []IParamContext { return s.values }

func (s *BatchUpdateStatementContext) SetDocs(v []IStrContext) { s.docs = v }

func (s *BatchUpdateStatementContext) SetFields(v []IFieldIdentifierContext) { s.fields = v }

func (s *BatchUpdateStatementContext) SetValues(v []IParamContext) { s.values = v }

func (s *BatchUpdateStatementContext) BATCH_UPDATE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBATCH_UPDATE, 0)
}

func (s *BatchUpdateStatementContext) BATCH_UPSERT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBATCH_UPSERT, 0)
}

func (s *BatchUpdateStatementContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *BatchUpdateStatementContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *BatchUpdateStatementContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *BatchUpdateStatementContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *BatchUpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSET, 0)
}

func (s *BatchUpdateStatementContext) ScriptPhrase() IScriptPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptPhraseContext)
}

func (s *BatchUpdateStatementContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserEQ)
}

func (s *BatchUpdateStatementContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, i)
}

func (s *BatchUpdateStatementContext) AllFieldIdentifier() []IFieldIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IFieldIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldIdentifierContext); ok {
			tst[i] = t.(IFieldIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BatchUpdateStatementContext) FieldIdentifier(i int) IFieldIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *BatchUpdateStatementContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *BatchUpdateStatementContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *BatchUpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BatchUpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BatchUpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterBatchUpdateStatement(s)
	}
}

func (s *BatchUpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitBatchUpdateStatement(s)
	}
}

func (s *BatchUpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitBatchUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) BatchUpdateStatement() (localctx IBatchUpdateStatementContext) {
	localctx = NewBatchUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ElasticSQLParserRULE_batchUpdateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1433)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ElasticSQLParserBATCH_UPDATE || _la == ElasticSQLParserBATCH_UPSERT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1434)

		var _x = p.Str()

		localctx.(*BatchUpdateStatementContext)._str = _x
	}
	localctx.(*BatchUpdateStatementContext).docs = append(localctx.(*BatchUpdateStatementContext).docs, localctx.(*BatchUpdateStatementContext)._str)
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1435)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1436)

			var _x = p.Str()

			localctx.(*BatchUpdateStatementContext)._str = _x
		}
		localctx.(*BatchUpdateStatementContext).docs = append(localctx.(*BatchUpdateStatementContext).docs, localctx.(*BatchUpdateStatementContext)._str)

		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3562272993694187488) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-513428087574497293) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&1116914692957083861) != 0) {
		{
			p.SetState(1442)

			var _x = p.ScriptPhrase()

			localctx.(*BatchUpdateStatementContext).script = _x
		}

	}
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserSET {
		{
			p.SetState(1445)
			p.Match(ElasticSQLParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(1446)

			var _x = p.FieldIdentifier()

			localctx.(*BatchUpdateStatementContext)._fieldIdentifier = _x
		}
		localctx.(*BatchUpdateStatementContext).fields = append(localctx.(*BatchUpdateStatementContext).fields, localctx.(*BatchUpdateStatementContext)._fieldIdentifier)
		{
			p.SetState(1447)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1448)

			var _x = p.Param()

			localctx.(*BatchUpdateStatementContext)._param = _x
		}
		localctx.(*BatchUpdateStatementContext).values = append(localctx.(*BatchUpdateStatementContext).values, localctx.(*BatchUpdateStatementContext)._param)
		p.SetState(1456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1449)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1450)

				var _x = p.FieldIdentifier()

				localctx.(*BatchUpdateStatementContext)._fieldIdentifier = _x
			}
			localctx.(*BatchUpdateStatementContext).fields = append(localctx.(*BatchUpdateStatementContext).fields, localctx.(*BatchUpdateStatementContext)._fieldIdentifier)
			{
				p.SetState(1451)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1452)

				var _x = p.Param()

				localctx.(*BatchUpdateStatementContext)._param = _x
			}
			localctx.(*BatchUpdateStatementContext).values = append(localctx.(*BatchUpdateStatementContext).values, localctx.(*BatchUpdateStatementContext)._param)

			p.SetState(1458)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

	p.SetState(1463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(1461)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1462)

			var _x = p.StrictIdentifier()

			localctx.(*BatchUpdateStatementContext).statName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_indexIdentifier returns the _indexIdentifier rule contexts.
	Get_indexIdentifier() IIndexIdentifierContext

	// GetFileName returns the fileName rule contexts.
	GetFileName() IStrContext

	// GetId returns the id rule contexts.
	GetId() IStrContext

	// GetIds returns the ids rule contexts.
	GetIds() IStrContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// Set_indexIdentifier sets the _indexIdentifier rule contexts.
	Set_indexIdentifier(IIndexIdentifierContext)

	// SetFileName sets the fileName rule contexts.
	SetFileName(IStrContext)

	// SetId sets the id rule contexts.
	SetId(IStrContext)

	// SetIds sets the ids rule contexts.
	SetIds(IStrContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexIdentifierContext

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexIdentifierContext)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllIndexIdentifier() []IIndexIdentifierContext
	IndexIdentifier(i int) IIndexIdentifierContext
	MAP() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	WhereExpression() IWhereExpressionContext
	BY() antlr.TerminalNode
	IDS_FILE() antlr.TerminalNode
	ID() antlr.TerminalNode
	EQ() antlr.TerminalNode
	IDS() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext
	Str() IStrContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_indexIdentifier IIndexIdentifierContext
	indexes          []IIndexIdentifierContext
	fileName         IStrContext
	id               IStrContext
	ids              IStrContext
	statName         IStrictIdentifierContext
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) Get_indexIdentifier() IIndexIdentifierContext {
	return s._indexIdentifier
}

func (s *DeleteStatementContext) GetFileName() IStrContext { return s.fileName }

func (s *DeleteStatementContext) GetId() IStrContext { return s.id }

func (s *DeleteStatementContext) GetIds() IStrContext { return s.ids }

func (s *DeleteStatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *DeleteStatementContext) Set_indexIdentifier(v IIndexIdentifierContext) {
	s._indexIdentifier = v
}

func (s *DeleteStatementContext) SetFileName(v IStrContext) { s.fileName = v }

func (s *DeleteStatementContext) SetId(v IStrContext) { s.id = v }

func (s *DeleteStatementContext) SetIds(v IStrContext) { s.ids = v }

func (s *DeleteStatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *DeleteStatementContext) GetIndexes() []IIndexIdentifierContext { return s.indexes }

func (s *DeleteStatementContext) SetIndexes(v []IIndexIdentifierContext) { s.indexes = v }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDELETE, 0)
}

func (s *DeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFROM, 0)
}

func (s *DeleteStatementContext) AllIndexIdentifier() []IIndexIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIndexIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexIdentifierContext); ok {
			tst[i] = t.(IIndexIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DeleteStatementContext) IndexIdentifier(i int) IIndexIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexIdentifierContext)
}

func (s *DeleteStatementContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *DeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWHERE, 0)
}

func (s *DeleteStatementContext) WhereExpression() IWhereExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereExpressionContext)
}

func (s *DeleteStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *DeleteStatementContext) IDS_FILE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIDS_FILE, 0)
}

func (s *DeleteStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserID, 0)
}

func (s *DeleteStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *DeleteStatementContext) IDS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIDS, 0)
}

func (s *DeleteStatementContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *DeleteStatementContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ElasticSQLParserRULE_deleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1465)
		p.Match(ElasticSQLParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1466)
		p.Match(ElasticSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1467)

		var _x = p.IndexIdentifier()

		localctx.(*DeleteStatementContext)._indexIdentifier = _x
	}
	localctx.(*DeleteStatementContext).indexes = append(localctx.(*DeleteStatementContext).indexes, localctx.(*DeleteStatementContext)._indexIdentifier)
	p.SetState(1472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1468)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1469)

			var _x = p.IndexIdentifier()

			localctx.(*DeleteStatementContext)._indexIdentifier = _x
		}
		localctx.(*DeleteStatementContext).indexes = append(localctx.(*DeleteStatementContext).indexes, localctx.(*DeleteStatementContext)._indexIdentifier)

		p.SetState(1474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1475)
			p.Match(ElasticSQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1476)
			p.WhereExpression()
		}

	case 2:
		{
			p.SetState(1477)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1478)
			p.Match(ElasticSQLParserIDS_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1479)

			var _x = p.Str()

			localctx.(*DeleteStatementContext).fileName = _x
		}

	case 3:
		{
			p.SetState(1480)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1481)
			p.Match(ElasticSQLParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1482)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1483)

			var _x = p.Str()

			localctx.(*DeleteStatementContext).id = _x
		}

	case 4:
		{
			p.SetState(1484)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1485)
			p.Match(ElasticSQLParserIDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1486)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1487)

			var _x = p.Str()

			localctx.(*DeleteStatementContext).ids = _x
		}
		{
			p.SetState(1488)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(1492)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1493)

			var _x = p.StrictIdentifier()

			localctx.(*DeleteStatementContext).statName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescStatementContext is an interface to support dynamic dispatch.
type IDescStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_indexIdentifier returns the _indexIdentifier rule contexts.
	Get_indexIdentifier() IIndexIdentifierContext

	// Set_indexIdentifier sets the _indexIdentifier rule contexts.
	Set_indexIdentifier(IIndexIdentifierContext)

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexIdentifierContext

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexIdentifierContext)

	// Getter signatures
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	AllIndexIdentifier() []IIndexIdentifierContext
	IndexIdentifier(i int) IIndexIdentifierContext
	TEMPLATE() antlr.TerminalNode

	// IsDescStatementContext differentiates from other interfaces.
	IsDescStatementContext()
}

type DescStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_indexIdentifier IIndexIdentifierContext
	indexes          []IIndexIdentifierContext
}

func NewEmptyDescStatementContext() *DescStatementContext {
	var p = new(DescStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_descStatement
	return p
}

func InitEmptyDescStatementContext(p *DescStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_descStatement
}

func (*DescStatementContext) IsDescStatementContext() {}

func NewDescStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescStatementContext {
	var p = new(DescStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_descStatement

	return p
}

func (s *DescStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescStatementContext) Get_indexIdentifier() IIndexIdentifierContext {
	return s._indexIdentifier
}

func (s *DescStatementContext) Set_indexIdentifier(v IIndexIdentifierContext) { s._indexIdentifier = v }

func (s *DescStatementContext) GetIndexes() []IIndexIdentifierContext { return s.indexes }

func (s *DescStatementContext) SetIndexes(v []IIndexIdentifierContext) { s.indexes = v }

func (s *DescStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDESC, 0)
}

func (s *DescStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDESCRIBE, 0)
}

func (s *DescStatementContext) AllIndexIdentifier() []IIndexIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIndexIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexIdentifierContext); ok {
			tst[i] = t.(IIndexIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DescStatementContext) IndexIdentifier(i int) IIndexIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexIdentifierContext)
}

func (s *DescStatementContext) TEMPLATE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTEMPLATE, 0)
}

func (s *DescStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDescStatement(s)
	}
}

func (s *DescStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDescStatement(s)
	}
}

func (s *DescStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDescStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) DescStatement() (localctx IDescStatementContext) {
	localctx = NewDescStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ElasticSQLParserRULE_descStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1496)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ElasticSQLParserDESC || _la == ElasticSQLParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserTEMPLATE {
		{
			p.SetState(1497)
			p.Match(ElasticSQLParserTEMPLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1500)

		var _x = p.IndexIdentifier()

		localctx.(*DescStatementContext)._indexIdentifier = _x
	}
	localctx.(*DescStatementContext).indexes = append(localctx.(*DescStatementContext).indexes, localctx.(*DescStatementContext)._indexIdentifier)
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1501)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1502)

			var _x = p.IndexIdentifier()

			localctx.(*DescStatementContext)._indexIdentifier = _x
		}
		localctx.(*DescStatementContext).indexes = append(localctx.(*DescStatementContext).indexes, localctx.(*DescStatementContext)._indexIdentifier)

		p.SetState(1507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasStatementContext is an interface to support dynamic dispatch.
type IAliasStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAliasStatementContext differentiates from other interfaces.
	IsAliasStatementContext()
}

type AliasStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasStatementContext() *AliasStatementContext {
	var p = new(AliasStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_aliasStatement
	return p
}

func InitEmptyAliasStatementContext(p *AliasStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_aliasStatement
}

func (*AliasStatementContext) IsAliasStatementContext() {}

func NewAliasStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasStatementContext {
	var p = new(AliasStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_aliasStatement

	return p
}

func (s *AliasStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasStatementContext) CopyAll(ctx *AliasStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AliasStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DeleteAliasContext struct {
	AliasStatementContext
	op               antlr.Token
	aliasName        IIndexIdentifierContext
	_indexIdentifier IIndexIdentifierContext
	indexes          []IIndexIdentifierContext
}

func NewDeleteAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteAliasContext {
	var p = new(DeleteAliasContext)

	InitEmptyAliasStatementContext(&p.AliasStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*AliasStatementContext))

	return p
}

func (s *DeleteAliasContext) GetOp() antlr.Token { return s.op }

func (s *DeleteAliasContext) SetOp(v antlr.Token) { s.op = v }

func (s *DeleteAliasContext) GetAliasName() IIndexIdentifierContext { return s.aliasName }

func (s *DeleteAliasContext) Get_indexIdentifier() IIndexIdentifierContext { return s._indexIdentifier }

func (s *DeleteAliasContext) SetAliasName(v IIndexIdentifierContext) { s.aliasName = v }

func (s *DeleteAliasContext) Set_indexIdentifier(v IIndexIdentifierContext) { s._indexIdentifier = v }

func (s *DeleteAliasContext) GetIndexes() []IIndexIdentifierContext { return s.indexes }

func (s *DeleteAliasContext) SetIndexes(v []IIndexIdentifierContext) { s.indexes = v }

func (s *DeleteAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteAliasContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserALIAS, 0)
}

func (s *DeleteAliasContext) FROM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFROM, 0)
}

func (s *DeleteAliasContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDELETE, 0)
}

func (s *DeleteAliasContext) AllIndexIdentifier() []IIndexIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIndexIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexIdentifierContext); ok {
			tst[i] = t.(IIndexIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DeleteAliasContext) IndexIdentifier(i int) IIndexIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexIdentifierContext)
}

func (s *DeleteAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDeleteAlias(s)
	}
}

func (s *DeleteAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDeleteAlias(s)
	}
}

func (s *DeleteAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDeleteAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddAliasContext struct {
	AliasStatementContext
	op               antlr.Token
	aliasName        IIndexIdentifierContext
	_indexIdentifier IIndexIdentifierContext
	indexes          []IIndexIdentifierContext
}

func NewAddAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddAliasContext {
	var p = new(AddAliasContext)

	InitEmptyAliasStatementContext(&p.AliasStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*AliasStatementContext))

	return p
}

func (s *AddAliasContext) GetOp() antlr.Token { return s.op }

func (s *AddAliasContext) SetOp(v antlr.Token) { s.op = v }

func (s *AddAliasContext) GetAliasName() IIndexIdentifierContext { return s.aliasName }

func (s *AddAliasContext) Get_indexIdentifier() IIndexIdentifierContext { return s._indexIdentifier }

func (s *AddAliasContext) SetAliasName(v IIndexIdentifierContext) { s.aliasName = v }

func (s *AddAliasContext) Set_indexIdentifier(v IIndexIdentifierContext) { s._indexIdentifier = v }

func (s *AddAliasContext) GetIndexes() []IIndexIdentifierContext { return s.indexes }

func (s *AddAliasContext) SetIndexes(v []IIndexIdentifierContext) { s.indexes = v }

func (s *AddAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddAliasContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserALIAS, 0)
}

func (s *AddAliasContext) TO() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTO, 0)
}

func (s *AddAliasContext) ADD() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserADD, 0)
}

func (s *AddAliasContext) AllIndexIdentifier() []IIndexIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIndexIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexIdentifierContext); ok {
			tst[i] = t.(IIndexIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AddAliasContext) IndexIdentifier(i int) IIndexIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexIdentifierContext)
}

func (s *AddAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterAddAlias(s)
	}
}

func (s *AddAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitAddAlias(s)
	}
}

func (s *AddAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitAddAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) AliasStatement() (localctx IAliasStatementContext) {
	localctx = NewAliasStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ElasticSQLParserRULE_aliasStatement)
	var _la int

	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserADD:
		localctx = NewAddAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1508)

			var _m = p.Match(ElasticSQLParserADD)

			localctx.(*AddAliasContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1509)
			p.Match(ElasticSQLParserALIAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1510)

			var _x = p.IndexIdentifier()

			localctx.(*AddAliasContext).aliasName = _x
		}
		{
			p.SetState(1511)
			p.Match(ElasticSQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1512)

			var _x = p.IndexIdentifier()

			localctx.(*AddAliasContext)._indexIdentifier = _x
		}
		localctx.(*AddAliasContext).indexes = append(localctx.(*AddAliasContext).indexes, localctx.(*AddAliasContext)._indexIdentifier)
		p.SetState(1517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1513)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1514)

				var _x = p.IndexIdentifier()

				localctx.(*AddAliasContext)._indexIdentifier = _x
			}
			localctx.(*AddAliasContext).indexes = append(localctx.(*AddAliasContext).indexes, localctx.(*AddAliasContext)._indexIdentifier)

			p.SetState(1519)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case ElasticSQLParserDELETE:
		localctx = NewDeleteAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1520)

			var _m = p.Match(ElasticSQLParserDELETE)

			localctx.(*DeleteAliasContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1521)
			p.Match(ElasticSQLParserALIAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1522)

			var _x = p.IndexIdentifier()

			localctx.(*DeleteAliasContext).aliasName = _x
		}
		{
			p.SetState(1523)
			p.Match(ElasticSQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1524)

			var _x = p.IndexIdentifier()

			localctx.(*DeleteAliasContext)._indexIdentifier = _x
		}
		localctx.(*DeleteAliasContext).indexes = append(localctx.(*DeleteAliasContext).indexes, localctx.(*DeleteAliasContext)._indexIdentifier)
		p.SetState(1529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1525)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1526)

				var _x = p.IndexIdentifier()

				localctx.(*DeleteAliasContext)._indexIdentifier = _x
			}
			localctx.(*DeleteAliasContext).indexes = append(localctx.(*DeleteAliasContext).indexes, localctx.(*DeleteAliasContext)._indexIdentifier)

			p.SetState(1531)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStatementContext is an interface to support dynamic dispatch.
type IAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_indexIdentifier returns the _indexIdentifier rule contexts.
	Get_indexIdentifier() IIndexIdentifierContext

	// Get_prop returns the _prop rule contexts.
	Get_prop() IPropContext

	// Set_indexIdentifier sets the _indexIdentifier rule contexts.
	Set_indexIdentifier(IIndexIdentifierContext)

	// Set_prop sets the _prop rule contexts.
	Set_prop(IPropContext)

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexIdentifierContext

	// GetProps returns the props rule context list.
	GetProps() []IPropContext

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexIdentifierContext)

	// SetProps sets the props rule context list.
	SetProps([]IPropContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllIndexIdentifier() []IIndexIdentifierContext
	IndexIdentifier(i int) IIndexIdentifierContext
	AllProp() []IPropContext
	Prop(i int) IPropContext

	// IsAlterStatementContext differentiates from other interfaces.
	IsAlterStatementContext()
}

type AlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_indexIdentifier IIndexIdentifierContext
	indexes          []IIndexIdentifierContext
	_prop            IPropContext
	props            []IPropContext
}

func NewEmptyAlterStatementContext() *AlterStatementContext {
	var p = new(AlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_alterStatement
	return p
}

func InitEmptyAlterStatementContext(p *AlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_alterStatement
}

func (*AlterStatementContext) IsAlterStatementContext() {}

func NewAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementContext {
	var p = new(AlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_alterStatement

	return p
}

func (s *AlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementContext) Get_indexIdentifier() IIndexIdentifierContext {
	return s._indexIdentifier
}

func (s *AlterStatementContext) Get_prop() IPropContext { return s._prop }

func (s *AlterStatementContext) Set_indexIdentifier(v IIndexIdentifierContext) {
	s._indexIdentifier = v
}

func (s *AlterStatementContext) Set_prop(v IPropContext) { s._prop = v }

func (s *AlterStatementContext) GetIndexes() []IIndexIdentifierContext { return s.indexes }

func (s *AlterStatementContext) GetProps() []IPropContext { return s.props }

func (s *AlterStatementContext) SetIndexes(v []IIndexIdentifierContext) { s.indexes = v }

func (s *AlterStatementContext) SetProps(v []IPropContext) { s.props = v }

func (s *AlterStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserALTER, 0)
}

func (s *AlterStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSET, 0)
}

func (s *AlterStatementContext) AllIndexIdentifier() []IIndexIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIndexIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexIdentifierContext); ok {
			tst[i] = t.(IIndexIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterStatementContext) IndexIdentifier(i int) IIndexIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexIdentifierContext)
}

func (s *AlterStatementContext) AllProp() []IPropContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropContext); ok {
			len++
		}
	}

	tst := make([]IPropContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropContext); ok {
			tst[i] = t.(IPropContext)
			i++
		}
	}

	return tst
}

func (s *AlterStatementContext) Prop(i int) IPropContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropContext)
}

func (s *AlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterAlterStatement(s)
	}
}

func (s *AlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitAlterStatement(s)
	}
}

func (s *AlterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitAlterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) AlterStatement() (localctx IAlterStatementContext) {
	localctx = NewAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ElasticSQLParserRULE_alterStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1534)
		p.Match(ElasticSQLParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1535)

		var _x = p.IndexIdentifier()

		localctx.(*AlterStatementContext)._indexIdentifier = _x
	}
	localctx.(*AlterStatementContext).indexes = append(localctx.(*AlterStatementContext).indexes, localctx.(*AlterStatementContext)._indexIdentifier)
	p.SetState(1540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1536)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1537)

			var _x = p.IndexIdentifier()

			localctx.(*AlterStatementContext)._indexIdentifier = _x
		}
		localctx.(*AlterStatementContext).indexes = append(localctx.(*AlterStatementContext).indexes, localctx.(*AlterStatementContext)._indexIdentifier)

		p.SetState(1542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1543)
		p.Match(ElasticSQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1544)

		var _x = p.Prop()

		localctx.(*AlterStatementContext)._prop = _x
	}
	localctx.(*AlterStatementContext).props = append(localctx.(*AlterStatementContext).props, localctx.(*AlterStatementContext)._prop)
	p.SetState(1549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1545)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1546)

			var _x = p.Prop()

			localctx.(*AlterStatementContext)._prop = _x
		}
		localctx.(*AlterStatementContext).props = append(localctx.(*AlterStatementContext).props, localctx.(*AlterStatementContext)._prop)

		p.SetState(1551)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHive2StatementContext is an interface to support dynamic dispatch.
type IHive2StatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_QUOTASTR returns the _QUOTASTR token.
	Get_QUOTASTR() antlr.Token

	// Set_QUOTASTR sets the _QUOTASTR token.
	Set_QUOTASTR(antlr.Token)

	// GetSqls returns the sqls token list.
	GetSqls() []antlr.Token

	// SetSqls sets the sqls token list.
	SetSqls([]antlr.Token)

	// GetFile returns the file rule contexts.
	GetFile() IStrContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// SetFile sets the file rule contexts.
	SetFile(IStrContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// Getter signatures
	HQL() antlr.TerminalNode
	AllQUOTASTR() []antlr.TerminalNode
	QUOTASTR(i int) antlr.TerminalNode
	USING() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ExportStatement() IExportStatementContext
	Str() IStrContext
	StrictIdentifier() IStrictIdentifierContext

	// IsHive2StatementContext differentiates from other interfaces.
	IsHive2StatementContext()
}

type Hive2StatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	file      IStrContext
	_QUOTASTR antlr.Token
	sqls      []antlr.Token
	statName  IStrictIdentifierContext
}

func NewEmptyHive2StatementContext() *Hive2StatementContext {
	var p = new(Hive2StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_hive2Statement
	return p
}

func InitEmptyHive2StatementContext(p *Hive2StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_hive2Statement
}

func (*Hive2StatementContext) IsHive2StatementContext() {}

func NewHive2StatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hive2StatementContext {
	var p = new(Hive2StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_hive2Statement

	return p
}

func (s *Hive2StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *Hive2StatementContext) Get_QUOTASTR() antlr.Token { return s._QUOTASTR }

func (s *Hive2StatementContext) Set_QUOTASTR(v antlr.Token) { s._QUOTASTR = v }

func (s *Hive2StatementContext) GetSqls() []antlr.Token { return s.sqls }

func (s *Hive2StatementContext) SetSqls(v []antlr.Token) { s.sqls = v }

func (s *Hive2StatementContext) GetFile() IStrContext { return s.file }

func (s *Hive2StatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *Hive2StatementContext) SetFile(v IStrContext) { s.file = v }

func (s *Hive2StatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *Hive2StatementContext) HQL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHQL, 0)
}

func (s *Hive2StatementContext) AllQUOTASTR() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserQUOTASTR)
}

func (s *Hive2StatementContext) QUOTASTR(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, i)
}

func (s *Hive2StatementContext) USING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUSING, 0)
}

func (s *Hive2StatementContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *Hive2StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *Hive2StatementContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *Hive2StatementContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *Hive2StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hive2StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hive2StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterHive2Statement(s)
	}
}

func (s *Hive2StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitHive2Statement(s)
	}
}

func (s *Hive2StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitHive2Statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Hive2Statement() (localctx IHive2StatementContext) {
	localctx = NewHive2StatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ElasticSQLParserRULE_hive2Statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserUSING {
		{
			p.SetState(1552)
			p.Match(ElasticSQLParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1553)

			var _x = p.Str()

			localctx.(*Hive2StatementContext).file = _x
		}

	}
	{
		p.SetState(1556)
		p.Match(ElasticSQLParserHQL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1557)

		var _m = p.Match(ElasticSQLParserQUOTASTR)

		localctx.(*Hive2StatementContext)._QUOTASTR = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*Hive2StatementContext).sqls = append(localctx.(*Hive2StatementContext).sqls, localctx.(*Hive2StatementContext)._QUOTASTR)
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__8 {
		{
			p.SetState(1558)
			p.Match(ElasticSQLParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1559)

			var _m = p.Match(ElasticSQLParserQUOTASTR)

			localctx.(*Hive2StatementContext)._QUOTASTR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*Hive2StatementContext).sqls = append(localctx.(*Hive2StatementContext).sqls, localctx.(*Hive2StatementContext)._QUOTASTR)

		p.SetState(1564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(1565)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1566)

			var _x = p.StrictIdentifier()

			localctx.(*Hive2StatementContext).statName = _x
		}

	}
	p.SetState(1570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserEXPORT {
		{
			p.SetState(1569)
			p.ExportStatement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJdbcStatementContext is an interface to support dynamic dispatch.
type IJdbcStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceType returns the resourceType token.
	GetResourceType() antlr.Token

	// GetUrl returns the url token.
	GetUrl() antlr.Token

	// GetUser returns the user token.
	GetUser() antlr.Token

	// GetPassword returns the password token.
	GetPassword() antlr.Token

	// SetResourceType sets the resourceType token.
	SetResourceType(antlr.Token)

	// SetUrl sets the url token.
	SetUrl(antlr.Token)

	// SetUser sets the user token.
	SetUser(antlr.Token)

	// SetPassword sets the password token.
	SetPassword(antlr.Token)

	// Get_basicSQL returns the _basicSQL rule contexts.
	Get_basicSQL() IBasicSQLContext

	// Set_basicSQL sets the _basicSQL rule contexts.
	Set_basicSQL(IBasicSQLContext)

	// GetSubSQLs returns the subSQLs rule context list.
	GetSubSQLs() []IBasicSQLContext

	// SetSubSQLs sets the subSQLs rule context list.
	SetSubSQLs([]IBasicSQLContext)

	// Getter signatures
	AllBasicSQL() []IBasicSQLContext
	BasicSQL(i int) IBasicSQLContext
	CK() antlr.TerminalNode
	PQL() antlr.TerminalNode
	MQL() antlr.TerminalNode
	URL() antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	AllQUOTASTR() []antlr.TerminalNode
	QUOTASTR(i int) antlr.TerminalNode
	USER() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode

	// IsJdbcStatementContext differentiates from other interfaces.
	IsJdbcStatementContext()
}

type JdbcStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceType antlr.Token
	url          antlr.Token
	user         antlr.Token
	password     antlr.Token
	_basicSQL    IBasicSQLContext
	subSQLs      []IBasicSQLContext
}

func NewEmptyJdbcStatementContext() *JdbcStatementContext {
	var p = new(JdbcStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_jdbcStatement
	return p
}

func InitEmptyJdbcStatementContext(p *JdbcStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_jdbcStatement
}

func (*JdbcStatementContext) IsJdbcStatementContext() {}

func NewJdbcStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JdbcStatementContext {
	var p = new(JdbcStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_jdbcStatement

	return p
}

func (s *JdbcStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JdbcStatementContext) GetResourceType() antlr.Token { return s.resourceType }

func (s *JdbcStatementContext) GetUrl() antlr.Token { return s.url }

func (s *JdbcStatementContext) GetUser() antlr.Token { return s.user }

func (s *JdbcStatementContext) GetPassword() antlr.Token { return s.password }

func (s *JdbcStatementContext) SetResourceType(v antlr.Token) { s.resourceType = v }

func (s *JdbcStatementContext) SetUrl(v antlr.Token) { s.url = v }

func (s *JdbcStatementContext) SetUser(v antlr.Token) { s.user = v }

func (s *JdbcStatementContext) SetPassword(v antlr.Token) { s.password = v }

func (s *JdbcStatementContext) Get_basicSQL() IBasicSQLContext { return s._basicSQL }

func (s *JdbcStatementContext) Set_basicSQL(v IBasicSQLContext) { s._basicSQL = v }

func (s *JdbcStatementContext) GetSubSQLs() []IBasicSQLContext { return s.subSQLs }

func (s *JdbcStatementContext) SetSubSQLs(v []IBasicSQLContext) { s.subSQLs = v }

func (s *JdbcStatementContext) AllBasicSQL() []IBasicSQLContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBasicSQLContext); ok {
			len++
		}
	}

	tst := make([]IBasicSQLContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBasicSQLContext); ok {
			tst[i] = t.(IBasicSQLContext)
			i++
		}
	}

	return tst
}

func (s *JdbcStatementContext) BasicSQL(i int) IBasicSQLContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasicSQLContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasicSQLContext)
}

func (s *JdbcStatementContext) CK() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCK, 0)
}

func (s *JdbcStatementContext) PQL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPQL, 0)
}

func (s *JdbcStatementContext) MQL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMQL, 0)
}

func (s *JdbcStatementContext) URL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserURL, 0)
}

func (s *JdbcStatementContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserEQ)
}

func (s *JdbcStatementContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, i)
}

func (s *JdbcStatementContext) AllQUOTASTR() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserQUOTASTR)
}

func (s *JdbcStatementContext) QUOTASTR(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, i)
}

func (s *JdbcStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUSER, 0)
}

func (s *JdbcStatementContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPASSWORD, 0)
}

func (s *JdbcStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JdbcStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JdbcStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterJdbcStatement(s)
	}
}

func (s *JdbcStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitJdbcStatement(s)
	}
}

func (s *JdbcStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitJdbcStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) JdbcStatement() (localctx IJdbcStatementContext) {
	localctx = NewJdbcStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ElasticSQLParserRULE_jdbcStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1572)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*JdbcStatementContext).resourceType = _lt

		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&481036337152) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*JdbcStatementContext).resourceType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserT__1 {
		{
			p.SetState(1573)
			p.Match(ElasticSQLParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1574)
			p.Match(ElasticSQLParserURL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1575)
			p.Match(ElasticSQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1576)

			var _m = p.Match(ElasticSQLParserQUOTASTR)

			localctx.(*JdbcStatementContext).url = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserUSER {
			{
				p.SetState(1577)
				p.Match(ElasticSQLParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1578)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1579)

				var _m = p.Match(ElasticSQLParserQUOTASTR)

				localctx.(*JdbcStatementContext).user = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1585)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserPASSWORD {
			{
				p.SetState(1582)
				p.Match(ElasticSQLParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1583)
				p.Match(ElasticSQLParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1584)

				var _m = p.Match(ElasticSQLParserQUOTASTR)

				localctx.(*JdbcStatementContext).password = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1587)
			p.Match(ElasticSQLParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1590)

		var _x = p.BasicSQL()

		localctx.(*JdbcStatementContext)._basicSQL = _x
	}
	localctx.(*JdbcStatementContext).subSQLs = append(localctx.(*JdbcStatementContext).subSQLs, localctx.(*JdbcStatementContext)._basicSQL)
	p.SetState(1595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__8 {
		{
			p.SetState(1591)
			p.Match(ElasticSQLParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1592)

			var _x = p.BasicSQL()

			localctx.(*JdbcStatementContext)._basicSQL = _x
		}
		localctx.(*JdbcStatementContext).subSQLs = append(localctx.(*JdbcStatementContext).subSQLs, localctx.(*JdbcStatementContext)._basicSQL)

		p.SetState(1597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBasicSQLContext is an interface to support dynamic dispatch.
type IBasicSQLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSql returns the sql token.
	GetSql() antlr.Token

	// SetSql sets the sql token.
	SetSql(antlr.Token)

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// Getter signatures
	QUOTASTR() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ExportStatement() IExportStatementContext
	StrictIdentifier() IStrictIdentifierContext

	// IsBasicSQLContext differentiates from other interfaces.
	IsBasicSQLContext()
}

type BasicSQLContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	sql      antlr.Token
	statName IStrictIdentifierContext
}

func NewEmptyBasicSQLContext() *BasicSQLContext {
	var p = new(BasicSQLContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_basicSQL
	return p
}

func InitEmptyBasicSQLContext(p *BasicSQLContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_basicSQL
}

func (*BasicSQLContext) IsBasicSQLContext() {}

func NewBasicSQLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasicSQLContext {
	var p = new(BasicSQLContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_basicSQL

	return p
}

func (s *BasicSQLContext) GetParser() antlr.Parser { return s.parser }

func (s *BasicSQLContext) GetSql() antlr.Token { return s.sql }

func (s *BasicSQLContext) SetSql(v antlr.Token) { s.sql = v }

func (s *BasicSQLContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *BasicSQLContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *BasicSQLContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *BasicSQLContext) MAP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, 0)
}

func (s *BasicSQLContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *BasicSQLContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *BasicSQLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicSQLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasicSQLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterBasicSQL(s)
	}
}

func (s *BasicSQLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitBasicSQL(s)
	}
}

func (s *BasicSQLContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitBasicSQL(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) BasicSQL() (localctx IBasicSQLContext) {
	localctx = NewBasicSQLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ElasticSQLParserRULE_basicSQL)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1598)

		var _m = p.Match(ElasticSQLParserQUOTASTR)

		localctx.(*BasicSQLContext).sql = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(1599)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1600)

			var _x = p.StrictIdentifier()

			localctx.(*BasicSQLContext).statName = _x
		}

	}
	p.SetState(1604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserEXPORT {
		{
			p.SetState(1603)
			p.ExportStatement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileLoadStatementContext is an interface to support dynamic dispatch.
type IFileLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDType returns the dType token.
	GetDType() antlr.Token

	// GetSep returns the sep token.
	GetSep() antlr.Token

	// GetOffset returns the offset token.
	GetOffset() antlr.Token

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetDType sets the dType token.
	SetDType(antlr.Token)

	// SetSep sets the sep token.
	SetSep(antlr.Token)

	// SetOffset sets the offset token.
	SetOffset(antlr.Token)

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Get_fieldDefine returns the _fieldDefine rule contexts.
	Get_fieldDefine() IFieldDefineContext

	// GetFilePath returns the filePath rule contexts.
	GetFilePath() IStrContext

	// GetStatName returns the statName rule contexts.
	GetStatName() IStrictIdentifierContext

	// Set_fieldDefine sets the _fieldDefine rule contexts.
	Set_fieldDefine(IFieldDefineContext)

	// SetFilePath sets the filePath rule contexts.
	SetFilePath(IStrContext)

	// SetStatName sets the statName rule contexts.
	SetStatName(IStrictIdentifierContext)

	// GetFields returns the fields rule context list.
	GetFields() []IFieldDefineContext

	// SetFields sets the fields rule context list.
	SetFields([]IFieldDefineContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Str() IStrContext
	DATA() antlr.TerminalNode
	JSON() antlr.TerminalNode
	ALL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	SEPARATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	AllMAP() []antlr.TerminalNode
	MAP(i int) antlr.TerminalNode
	QUOTASTR() antlr.TerminalNode
	AllLONG() []antlr.TerminalNode
	LONG(i int) antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext
	AllFieldDefine() []IFieldDefineContext
	FieldDefine(i int) IFieldDefineContext
	LIST() antlr.TerminalNode

	// IsFileLoadStatementContext differentiates from other interfaces.
	IsFileLoadStatementContext()
}

type FileLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_fieldDefine IFieldDefineContext
	fields       []IFieldDefineContext
	dType        antlr.Token
	filePath     IStrContext
	sep          antlr.Token
	offset       antlr.Token
	limit        antlr.Token
	statName     IStrictIdentifierContext
}

func NewEmptyFileLoadStatementContext() *FileLoadStatementContext {
	var p = new(FileLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fileLoadStatement
	return p
}

func InitEmptyFileLoadStatementContext(p *FileLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fileLoadStatement
}

func (*FileLoadStatementContext) IsFileLoadStatementContext() {}

func NewFileLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileLoadStatementContext {
	var p = new(FileLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_fileLoadStatement

	return p
}

func (s *FileLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FileLoadStatementContext) GetDType() antlr.Token { return s.dType }

func (s *FileLoadStatementContext) GetSep() antlr.Token { return s.sep }

func (s *FileLoadStatementContext) GetOffset() antlr.Token { return s.offset }

func (s *FileLoadStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *FileLoadStatementContext) SetDType(v antlr.Token) { s.dType = v }

func (s *FileLoadStatementContext) SetSep(v antlr.Token) { s.sep = v }

func (s *FileLoadStatementContext) SetOffset(v antlr.Token) { s.offset = v }

func (s *FileLoadStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *FileLoadStatementContext) Get_fieldDefine() IFieldDefineContext { return s._fieldDefine }

func (s *FileLoadStatementContext) GetFilePath() IStrContext { return s.filePath }

func (s *FileLoadStatementContext) GetStatName() IStrictIdentifierContext { return s.statName }

func (s *FileLoadStatementContext) Set_fieldDefine(v IFieldDefineContext) { s._fieldDefine = v }

func (s *FileLoadStatementContext) SetFilePath(v IStrContext) { s.filePath = v }

func (s *FileLoadStatementContext) SetStatName(v IStrictIdentifierContext) { s.statName = v }

func (s *FileLoadStatementContext) GetFields() []IFieldDefineContext { return s.fields }

func (s *FileLoadStatementContext) SetFields(v []IFieldDefineContext) { s.fields = v }

func (s *FileLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLOAD, 0)
}

func (s *FileLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFROM, 0)
}

func (s *FileLoadStatementContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *FileLoadStatementContext) DATA() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDATA, 0)
}

func (s *FileLoadStatementContext) JSON() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserJSON, 0)
}

func (s *FileLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserALL, 0)
}

func (s *FileLoadStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLOCAL, 0)
}

func (s *FileLoadStatementContext) SEPARATED() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSEPARATED, 0)
}

func (s *FileLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *FileLoadStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIMIT, 0)
}

func (s *FileLoadStatementContext) AllMAP() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserMAP)
}

func (s *FileLoadStatementContext) MAP(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAP, i)
}

func (s *FileLoadStatementContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *FileLoadStatementContext) AllLONG() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserLONG)
}

func (s *FileLoadStatementContext) LONG(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, i)
}

func (s *FileLoadStatementContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *FileLoadStatementContext) AllFieldDefine() []IFieldDefineContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDefineContext); ok {
			len++
		}
	}

	tst := make([]IFieldDefineContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDefineContext); ok {
			tst[i] = t.(IFieldDefineContext)
			i++
		}
	}

	return tst
}

func (s *FileLoadStatementContext) FieldDefine(i int) IFieldDefineContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDefineContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDefineContext)
}

func (s *FileLoadStatementContext) LIST() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIST, 0)
}

func (s *FileLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterFileLoadStatement(s)
	}
}

func (s *FileLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitFileLoadStatement(s)
	}
}

func (s *FileLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitFileLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) FileLoadStatement() (localctx IFileLoadStatementContext) {
	localctx = NewFileLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ElasticSQLParserRULE_fileLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1606)
		p.Match(ElasticSQLParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserALL {
		{
			p.SetState(1607)
			p.Match(ElasticSQLParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserDATA:
		{
			p.SetState(1610)
			p.Match(ElasticSQLParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1611)
			p.Match(ElasticSQLParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3562272993694187520) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-513428087574497293) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&288252361520453845) != 0) {
			{
				p.SetState(1612)

				var _x = p.FieldDefine()

				localctx.(*FileLoadStatementContext)._fieldDefine = _x
			}
			localctx.(*FileLoadStatementContext).fields = append(localctx.(*FileLoadStatementContext).fields, localctx.(*FileLoadStatementContext)._fieldDefine)

		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ElasticSQLParserT__3 {
			{
				p.SetState(1615)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1616)

				var _x = p.FieldDefine()

				localctx.(*FileLoadStatementContext)._fieldDefine = _x
			}
			localctx.(*FileLoadStatementContext).fields = append(localctx.(*FileLoadStatementContext).fields, localctx.(*FileLoadStatementContext)._fieldDefine)

			p.SetState(1621)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1622)
			p.Match(ElasticSQLParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserJSON:
		{
			p.SetState(1623)
			p.Match(ElasticSQLParserJSON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1625)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserMAP || _la == ElasticSQLParserLIST {
			{
				p.SetState(1624)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*FileLoadStatementContext).dType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ElasticSQLParserMAP || _la == ElasticSQLParserLIST) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*FileLoadStatementContext).dType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1629)
		p.Match(ElasticSQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserLOCAL {
		{
			p.SetState(1630)
			p.Match(ElasticSQLParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1633)

		var _x = p.Str()

		localctx.(*FileLoadStatementContext).filePath = _x
	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserSEPARATED {
		{
			p.SetState(1634)
			p.Match(ElasticSQLParserSEPARATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1635)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1636)

			var _m = p.Match(ElasticSQLParserQUOTASTR)

			localctx.(*FileLoadStatementContext).sep = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserLIMIT {
		{
			p.SetState(1639)
			p.Match(ElasticSQLParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1642)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1640)

				var _m = p.Match(ElasticSQLParserLONG)

				localctx.(*FileLoadStatementContext).offset = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1641)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1644)

			var _m = p.Match(ElasticSQLParserLONG)

			localctx.(*FileLoadStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserMAP {
		{
			p.SetState(1647)
			p.Match(ElasticSQLParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1648)

			var _x = p.StrictIdentifier()

			localctx.(*FileLoadStatementContext).statName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDefineContext is an interface to support dynamic dispatch.
type IFieldDefineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFieldName returns the fieldName rule contexts.
	GetFieldName() IFieldIdentifierContext

	// GetFieldType returns the fieldType rule contexts.
	GetFieldType() IDataTypeContext

	// SetFieldName sets the fieldName rule contexts.
	SetFieldName(IFieldIdentifierContext)

	// SetFieldType sets the fieldType rule contexts.
	SetFieldType(IDataTypeContext)

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext
	DataType() IDataTypeContext

	// IsFieldDefineContext differentiates from other interfaces.
	IsFieldDefineContext()
}

type FieldDefineContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	fieldName IFieldIdentifierContext
	fieldType IDataTypeContext
}

func NewEmptyFieldDefineContext() *FieldDefineContext {
	var p = new(FieldDefineContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fieldDefine
	return p
}

func InitEmptyFieldDefineContext(p *FieldDefineContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fieldDefine
}

func (*FieldDefineContext) IsFieldDefineContext() {}

func NewFieldDefineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDefineContext {
	var p = new(FieldDefineContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_fieldDefine

	return p
}

func (s *FieldDefineContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDefineContext) GetFieldName() IFieldIdentifierContext { return s.fieldName }

func (s *FieldDefineContext) GetFieldType() IDataTypeContext { return s.fieldType }

func (s *FieldDefineContext) SetFieldName(v IFieldIdentifierContext) { s.fieldName = v }

func (s *FieldDefineContext) SetFieldType(v IDataTypeContext) { s.fieldType = v }

func (s *FieldDefineContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *FieldDefineContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FieldDefineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDefineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDefineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterFieldDefine(s)
	}
}

func (s *FieldDefineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitFieldDefine(s)
	}
}

func (s *FieldDefineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitFieldDefine(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) FieldDefine() (localctx IFieldDefineContext) {
	localctx = NewFieldDefineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ElasticSQLParserRULE_fieldDefine)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1651)

		var _x = p.FieldIdentifier()

		localctx.(*FieldDefineContext).fieldName = _x
	}
	p.SetState(1653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-152)) & ^0x3f) == 0 && ((int64(1)<<(_la-152))&1023) != 0 {
		{
			p.SetState(1652)

			var _x = p.DataType()

			localctx.(*FieldDefineContext).fieldType = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeStatementContext is an interface to support dynamic dispatch.
type IAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetContent returns the content token.
	GetContent() antlr.Token

	// SetContent sets the content token.
	SetContent(antlr.Token)

	// GetAnalyzer returns the analyzer rule contexts.
	GetAnalyzer() IStrContext

	// GetIndexAnalyzer returns the indexAnalyzer rule contexts.
	GetIndexAnalyzer() IStrContext

	// SetAnalyzer sets the analyzer rule contexts.
	SetAnalyzer(IStrContext)

	// SetIndexAnalyzer sets the indexAnalyzer rule contexts.
	SetIndexAnalyzer(IStrContext)

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	QUOTASTR() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllStr() []IStrContext
	Str(i int) IStrContext

	// IsAnalyzeStatementContext differentiates from other interfaces.
	IsAnalyzeStatementContext()
}

type AnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	content       antlr.Token
	analyzer      IStrContext
	indexAnalyzer IStrContext
}

func NewEmptyAnalyzeStatementContext() *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_analyzeStatement
	return p
}

func InitEmptyAnalyzeStatementContext(p *AnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_analyzeStatement
}

func (*AnalyzeStatementContext) IsAnalyzeStatementContext() {}

func NewAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_analyzeStatement

	return p
}

func (s *AnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeStatementContext) GetContent() antlr.Token { return s.content }

func (s *AnalyzeStatementContext) SetContent(v antlr.Token) { s.content = v }

func (s *AnalyzeStatementContext) GetAnalyzer() IStrContext { return s.analyzer }

func (s *AnalyzeStatementContext) GetIndexAnalyzer() IStrContext { return s.indexAnalyzer }

func (s *AnalyzeStatementContext) SetAnalyzer(v IStrContext) { s.analyzer = v }

func (s *AnalyzeStatementContext) SetIndexAnalyzer(v IStrContext) { s.indexAnalyzer = v }

func (s *AnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserANALYZE, 0)
}

func (s *AnalyzeStatementContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *AnalyzeStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBY, 0)
}

func (s *AnalyzeStatementContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeStatementContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *AnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) AnalyzeStatement() (localctx IAnalyzeStatementContext) {
	localctx = NewAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ElasticSQLParserRULE_analyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1655)
		p.Match(ElasticSQLParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1656)

		var _m = p.Match(ElasticSQLParserQUOTASTR)

		localctx.(*AnalyzeStatementContext).content = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserBY {
		{
			p.SetState(1657)
			p.Match(ElasticSQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1658)

			var _x = p.Str()

			localctx.(*AnalyzeStatementContext).analyzer = _x
		}
		p.SetState(1661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ElasticSQLParserT__3 {
			{
				p.SetState(1659)
				p.Match(ElasticSQLParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1660)

				var _x = p.Str()

				localctx.(*AnalyzeStatementContext).indexAnalyzer = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHanLPStatementContext is an interface to support dynamic dispatch.
type IHanLPStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFuncName returns the funcName rule contexts.
	GetFuncName() INlpFuncContext

	// GetObj returns the obj rule contexts.
	GetObj() IStrContext

	// Get_str returns the _str rule contexts.
	Get_str() IStrContext

	// SetFuncName sets the funcName rule contexts.
	SetFuncName(INlpFuncContext)

	// SetObj sets the obj rule contexts.
	SetObj(IStrContext)

	// Set_str sets the _str rule contexts.
	Set_str(IStrContext)

	// GetEnables returns the enables rule context list.
	GetEnables() []IStrContext

	// SetEnables sets the enables rule context list.
	SetEnables([]IStrContext)

	// Getter signatures
	NLP() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	NlpFunc() INlpFuncContext
	AllStr() []IStrContext
	Str(i int) IStrContext

	// IsHanLPStatementContext differentiates from other interfaces.
	IsHanLPStatementContext()
}

type HanLPStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	funcName INlpFuncContext
	obj      IStrContext
	_str     IStrContext
	enables  []IStrContext
}

func NewEmptyHanLPStatementContext() *HanLPStatementContext {
	var p = new(HanLPStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_hanLPStatement
	return p
}

func InitEmptyHanLPStatementContext(p *HanLPStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_hanLPStatement
}

func (*HanLPStatementContext) IsHanLPStatementContext() {}

func NewHanLPStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HanLPStatementContext {
	var p = new(HanLPStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_hanLPStatement

	return p
}

func (s *HanLPStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HanLPStatementContext) GetFuncName() INlpFuncContext { return s.funcName }

func (s *HanLPStatementContext) GetObj() IStrContext { return s.obj }

func (s *HanLPStatementContext) Get_str() IStrContext { return s._str }

func (s *HanLPStatementContext) SetFuncName(v INlpFuncContext) { s.funcName = v }

func (s *HanLPStatementContext) SetObj(v IStrContext) { s.obj = v }

func (s *HanLPStatementContext) Set_str(v IStrContext) { s._str = v }

func (s *HanLPStatementContext) GetEnables() []IStrContext { return s.enables }

func (s *HanLPStatementContext) SetEnables(v []IStrContext) { s.enables = v }

func (s *HanLPStatementContext) NLP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNLP, 0)
}

func (s *HanLPStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserENABLE, 0)
}

func (s *HanLPStatementContext) NlpFunc() INlpFuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlpFuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlpFuncContext)
}

func (s *HanLPStatementContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *HanLPStatementContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *HanLPStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HanLPStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HanLPStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterHanLPStatement(s)
	}
}

func (s *HanLPStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitHanLPStatement(s)
	}
}

func (s *HanLPStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitHanLPStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) HanLPStatement() (localctx IHanLPStatementContext) {
	localctx = NewHanLPStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ElasticSQLParserRULE_hanLPStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1665)
		p.Match(ElasticSQLParserNLP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1666)

		var _x = p.NlpFunc()

		localctx.(*HanLPStatementContext).funcName = _x
	}
	{
		p.SetState(1667)

		var _x = p.Str()

		localctx.(*HanLPStatementContext).obj = _x
	}
	{
		p.SetState(1668)
		p.Match(ElasticSQLParserENABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1669)
		p.Match(ElasticSQLParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1670)

		var _x = p.Str()

		localctx.(*HanLPStatementContext)._str = _x
	}
	localctx.(*HanLPStatementContext).enables = append(localctx.(*HanLPStatementContext).enables, localctx.(*HanLPStatementContext)._str)
	p.SetState(1675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserT__3 {
		{
			p.SetState(1671)
			p.Match(ElasticSQLParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1672)

			var _x = p.Str()

			localctx.(*HanLPStatementContext)._str = _x
		}
		localctx.(*HanLPStatementContext).enables = append(localctx.(*HanLPStatementContext).enables, localctx.(*HanLPStatementContext)._str)

		p.SetState(1677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1678)
		p.Match(ElasticSQLParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INlpFuncContext is an interface to support dynamic dispatch.
type INlpFuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEGMENT() antlr.TerminalNode
	NAME() antlr.TerminalNode
	ORG() antlr.TerminalNode
	LOC() antlr.TerminalNode

	// IsNlpFuncContext differentiates from other interfaces.
	IsNlpFuncContext()
}

type NlpFuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNlpFuncContext() *NlpFuncContext {
	var p = new(NlpFuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_nlpFunc
	return p
}

func InitEmptyNlpFuncContext(p *NlpFuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_nlpFunc
}

func (*NlpFuncContext) IsNlpFuncContext() {}

func NewNlpFuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NlpFuncContext {
	var p = new(NlpFuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_nlpFunc

	return p
}

func (s *NlpFuncContext) GetParser() antlr.Parser { return s.parser }

func (s *NlpFuncContext) SEGMENT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSEGMENT, 0)
}

func (s *NlpFuncContext) NAME() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNAME, 0)
}

func (s *NlpFuncContext) ORG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserORG, 0)
}

func (s *NlpFuncContext) LOC() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLOC, 0)
}

func (s *NlpFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NlpFuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NlpFuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterNlpFunc(s)
	}
}

func (s *NlpFuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitNlpFunc(s)
	}
}

func (s *NlpFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitNlpFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) NlpFunc() (localctx INlpFuncContext) {
	localctx = NewNlpFuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ElasticSQLParserRULE_nlpFunc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1680)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-170)) & ^0x3f) == 0 && ((int64(1)<<(_la-170))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN_T() antlr.TerminalNode
	STRING() antlr.TerminalNode
	LONG_T() antlr.TerminalNode
	DOUBLE_T() antlr.TerminalNode
	FLOAT_T() antlr.TerminalNode
	INTEGER_T() antlr.TerminalNode
	DATE_T() antlr.TerminalNode
	TIME_T() antlr.TerminalNode
	DATETIME_T() antlr.TerminalNode
	TIMESTAMP_T() antlr.TerminalNode

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) BOOLEAN_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserBOOLEAN_T, 0)
}

func (s *DataTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSTRING, 0)
}

func (s *DataTypeContext) LONG_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG_T, 0)
}

func (s *DataTypeContext) DOUBLE_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOUBLE_T, 0)
}

func (s *DataTypeContext) FLOAT_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFLOAT_T, 0)
}

func (s *DataTypeContext) INTEGER_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINTEGER_T, 0)
}

func (s *DataTypeContext) DATE_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDATE_T, 0)
}

func (s *DataTypeContext) TIME_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTIME_T, 0)
}

func (s *DataTypeContext) DATETIME_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDATETIME_T, 0)
}

func (s *DataTypeContext) TIMESTAMP_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTIMESTAMP_T, 0)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterDataType(s)
	}
}

func (s *DataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitDataType(s)
	}
}

func (s *DataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ElasticSQLParserRULE_dataType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1682)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-152)) & ^0x3f) == 0 && ((int64(1)<<(_la-152))&1023) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GE() antlr.TerminalNode
	NE() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLT, 0)
}

func (s *ComparisonOperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserGT, 0)
}

func (s *ComparisonOperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserGE, 0)
}

func (s *ComparisonOperatorContext) NE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNE, 0)
}

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEQ, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ElasticSQLParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1684)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-181)) & ^0x3f) == 0 && ((int64(1)<<(_la-181))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathIdentifierContext is an interface to support dynamic dispatch.
type IPathIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExportField() []IExportFieldContext
	ExportField(i int) IExportFieldContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllGT() []antlr.TerminalNode
	GT(i int) antlr.TerminalNode

	// IsPathIdentifierContext differentiates from other interfaces.
	IsPathIdentifierContext()
}

type PathIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathIdentifierContext() *PathIdentifierContext {
	var p = new(PathIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_pathIdentifier
	return p
}

func InitEmptyPathIdentifierContext(p *PathIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_pathIdentifier
}

func (*PathIdentifierContext) IsPathIdentifierContext() {}

func NewPathIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathIdentifierContext {
	var p = new(PathIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_pathIdentifier

	return p
}

func (s *PathIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PathIdentifierContext) AllExportField() []IExportFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExportFieldContext); ok {
			len++
		}
	}

	tst := make([]IExportFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExportFieldContext); ok {
			tst[i] = t.(IExportFieldContext)
			i++
		}
	}

	return tst
}

func (s *PathIdentifierContext) ExportField(i int) IExportFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportFieldContext)
}

func (s *PathIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserDOT)
}

func (s *PathIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOT, i)
}

func (s *PathIdentifierContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserGT)
}

func (s *PathIdentifierContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserGT, i)
}

func (s *PathIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterPathIdentifier(s)
	}
}

func (s *PathIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitPathIdentifier(s)
	}
}

func (s *PathIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitPathIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) PathIdentifier() (localctx IPathIdentifierContext) {
	localctx = NewPathIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ElasticSQLParserRULE_pathIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1686)
		p.ExportField()
	}
	p.SetState(1691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ElasticSQLParserDOT || _la == ElasticSQLParserGT {
		{
			p.SetState(1687)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ElasticSQLParserDOT || _la == ElasticSQLParserGT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1688)
			p.ExportField()
		}

		p.SetState(1693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldIdentifierContext is an interface to support dynamic dispatch.
type IFieldIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStrictIdentifier() []IStrictIdentifierContext
	StrictIdentifier(i int) IStrictIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	MUL() antlr.TerminalNode

	// IsFieldIdentifierContext differentiates from other interfaces.
	IsFieldIdentifierContext()
}

type FieldIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldIdentifierContext() *FieldIdentifierContext {
	var p = new(FieldIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fieldIdentifier
	return p
}

func InitEmptyFieldIdentifierContext(p *FieldIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_fieldIdentifier
}

func (*FieldIdentifierContext) IsFieldIdentifierContext() {}

func NewFieldIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldIdentifierContext {
	var p = new(FieldIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_fieldIdentifier

	return p
}

func (s *FieldIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldIdentifierContext) AllStrictIdentifier() []IStrictIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IStrictIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrictIdentifierContext); ok {
			tst[i] = t.(IStrictIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *FieldIdentifierContext) StrictIdentifier(i int) IStrictIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *FieldIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ElasticSQLParserDOT)
}

func (s *FieldIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOT, i)
}

func (s *FieldIdentifierContext) MUL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMUL, 0)
}

func (s *FieldIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterFieldIdentifier(s)
	}
}

func (s *FieldIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitFieldIdentifier(s)
	}
}

func (s *FieldIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitFieldIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) FieldIdentifier() (localctx IFieldIdentifierContext) {
	localctx = NewFieldIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ElasticSQLParserRULE_fieldIdentifier)
	var _la int

	var _alt int

	p.SetState(1703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserINNER_HIT, ElasticSQLParserRESCORE, ElasticSQLParserWINDOWS, ElasticSQLParserCOLLAPSE, ElasticSQLParserSCORE, ElasticSQLParserSQL, ElasticSQLParserSTRUCT, ElasticSQLParserCK, ElasticSQLParserURL, ElasticSQLParserPASSWORD, ElasticSQLParserUSER, ElasticSQLParserGROUP, ElasticSQLParserTEMPLATE, ElasticSQLParserALL, ElasticSQLParserNOT, ElasticSQLParserINTO, ElasticSQLParserTO, ElasticSQLParserEXCLUDE, ElasticSQLParserINCLUDE, ElasticSQLParserID, ElasticSQLParserSLICE, ElasticSQLParserJSON, ElasticSQLParserCSV, ElasticSQLParserEXCEL, ElasticSQLParserSEP, ElasticSQLParserSCRIPT, ElasticSQLParserLANG, ElasticSQLParserRETURN, ElasticSQLParserPK, ElasticSQLParserUUID, ElasticSQLParserMEM, ElasticSQLParserRIGHT, ElasticSQLParserLEFT, ElasticSQLParserALIAS, ElasticSQLParserRLIKE, ElasticSQLParserLIKE, ElasticSQLParserIN, ElasticSQLParserOUT, ElasticSQLParserEXIST, ElasticSQLParserMISS, ElasticSQLParserQUERY_STRING, ElasticSQLParserMATCH, ElasticSQLParserMULTI_MATCH, ElasticSQLParserMATCH_PHRASE_PREFIX, ElasticSQLParserMATCH_PHRASE, ElasticSQLParserKNN, ElasticSQLParserHAS_CHILD, ElasticSQLParserHAS_PARENT, ElasticSQLParserCOUNT, ElasticSQLParserMAX, ElasticSQLParserMIN, ElasticSQLParserAVG, ElasticSQLParserSUM, ElasticSQLParserDISTINCT, ElasticSQLParserVALUE_COUNT, ElasticSQLParserPERCENTILE_RANKS, ElasticSQLParserPERCENTILES, ElasticSQLParserPERCENT, ElasticSQLParserDISTINCT_PERCENT, ElasticSQLParserTOP_HITS, ElasticSQLParserMATH, ElasticSQLParserRANGE, ElasticSQLParserINTERVAL, ElasticSQLParserFORMAT, ElasticSQLParserKEYED, ElasticSQLParserSIZE, ElasticSQLParserMISSING, ElasticSQLParserNULL, ElasticSQLParserEND, ElasticSQLParserSAMPLE, ElasticSQLParserIDS, ElasticSQLParserIDS_FILE, ElasticSQLParserPUT, ElasticSQLParserADD, ElasticSQLParserNUMBER, ElasticSQLParserSTRING, ElasticSQLParserDATETIME_T, ElasticSQLParserTIMESTAMP_T, ElasticSQLParserDATE_T, ElasticSQLParserTIME_T, ElasticSQLParserLOCAL, ElasticSQLParserDATA, ElasticSQLParserLIST, ElasticSQLParserSEPARATED, ElasticSQLParserANALYZE, ElasticSQLParserNLP, ElasticSQLParserENABLE, ElasticSQLParserSEGMENT, ElasticSQLParserNAME, ElasticSQLParserORG, ElasticSQLParserLOC, ElasticSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1694)
			p.StrictIdentifier()
		}
		p.SetState(1699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1695)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ElasticSQLParserT__11 || _la == ElasticSQLParserDOT) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1696)
					p.StrictIdentifier()
				}

			}
			p.SetState(1701)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case ElasticSQLParserMUL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1702)
			p.Match(ElasticSQLParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexIdentifierContext is an interface to support dynamic dispatch.
type IIndexIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndex returns the index rule contexts.
	GetIndex() IIndexNameContext

	// GetIndexType returns the indexType rule contexts.
	GetIndexType() IStrictIdentifierContext

	// SetIndex sets the index rule contexts.
	SetIndex(IIndexNameContext)

	// SetIndexType sets the indexType rule contexts.
	SetIndexType(IStrictIdentifierContext)

	// Getter signatures
	IndexName() IIndexNameContext
	DOT() antlr.TerminalNode
	StrictIdentifier() IStrictIdentifierContext

	// IsIndexIdentifierContext differentiates from other interfaces.
	IsIndexIdentifierContext()
}

type IndexIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	index     IIndexNameContext
	indexType IStrictIdentifierContext
}

func NewEmptyIndexIdentifierContext() *IndexIdentifierContext {
	var p = new(IndexIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_indexIdentifier
	return p
}

func InitEmptyIndexIdentifierContext(p *IndexIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_indexIdentifier
}

func (*IndexIdentifierContext) IsIndexIdentifierContext() {}

func NewIndexIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexIdentifierContext {
	var p = new(IndexIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_indexIdentifier

	return p
}

func (s *IndexIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexIdentifierContext) GetIndex() IIndexNameContext { return s.index }

func (s *IndexIdentifierContext) GetIndexType() IStrictIdentifierContext { return s.indexType }

func (s *IndexIdentifierContext) SetIndex(v IIndexNameContext) { s.index = v }

func (s *IndexIdentifierContext) SetIndexType(v IStrictIdentifierContext) { s.indexType = v }

func (s *IndexIdentifierContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *IndexIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOT, 0)
}

func (s *IndexIdentifierContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *IndexIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterIndexIdentifier(s)
	}
}

func (s *IndexIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitIndexIdentifier(s)
	}
}

func (s *IndexIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitIndexIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) IndexIdentifier() (localctx IIndexIdentifierContext) {
	localctx = NewIndexIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ElasticSQLParserRULE_indexIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1705)

		var _x = p.IndexName()

		localctx.(*IndexIdentifierContext).index = _x
	}
	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ElasticSQLParserDOT {
		{
			p.SetState(1706)
			p.Match(ElasticSQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1707)

			var _x = p.StrictIdentifier()

			localctx.(*IndexIdentifierContext).indexType = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	MUL() antlr.TerminalNode
	QUOTASTR() antlr.TerminalNode

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_indexName
	return p
}

func InitEmptyIndexNameContext(p *IndexNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_indexName
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIDENTIFIER, 0)
}

func (s *IndexNameContext) MUL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMUL, 0)
}

func (s *IndexNameContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterIndexName(s)
	}
}

func (s *IndexNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitIndexName(s)
	}
}

func (s *IndexNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitIndexName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) IndexName() (localctx IIndexNameContext) {
	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ElasticSQLParserRULE_indexName)
	p.SetState(1715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1710)
			p.Match(ElasticSQLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1712)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1711)
				p.Match(ElasticSQLParserMUL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case ElasticSQLParserQUOTASTR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1714)
			p.Match(ElasticSQLParserQUOTASTR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrictIdentifierContext is an interface to support dynamic dispatch.
type IStrictIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	NonReserved() INonReservedContext

	// IsStrictIdentifierContext differentiates from other interfaces.
	IsStrictIdentifierContext()
}

type StrictIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrictIdentifierContext() *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_strictIdentifier
	return p
}

func InitEmptyStrictIdentifierContext(p *StrictIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_strictIdentifier
}

func (*StrictIdentifierContext) IsStrictIdentifierContext() {}

func NewStrictIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_strictIdentifier

	return p
}

func (s *StrictIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StrictIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIDENTIFIER, 0)
}

func (s *StrictIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *StrictIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrictIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrictIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterStrictIdentifier(s)
	}
}

func (s *StrictIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitStrictIdentifier(s)
	}
}

func (s *StrictIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitStrictIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) StrictIdentifier() (localctx IStrictIdentifierContext) {
	localctx = NewStrictIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ElasticSQLParserRULE_strictIdentifier)
	p.SetState(1719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ElasticSQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1717)
			p.Match(ElasticSQLParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ElasticSQLParserINNER_HIT, ElasticSQLParserRESCORE, ElasticSQLParserWINDOWS, ElasticSQLParserCOLLAPSE, ElasticSQLParserSCORE, ElasticSQLParserSQL, ElasticSQLParserSTRUCT, ElasticSQLParserCK, ElasticSQLParserURL, ElasticSQLParserPASSWORD, ElasticSQLParserUSER, ElasticSQLParserGROUP, ElasticSQLParserTEMPLATE, ElasticSQLParserALL, ElasticSQLParserNOT, ElasticSQLParserINTO, ElasticSQLParserTO, ElasticSQLParserEXCLUDE, ElasticSQLParserINCLUDE, ElasticSQLParserID, ElasticSQLParserSLICE, ElasticSQLParserJSON, ElasticSQLParserCSV, ElasticSQLParserEXCEL, ElasticSQLParserSEP, ElasticSQLParserSCRIPT, ElasticSQLParserLANG, ElasticSQLParserRETURN, ElasticSQLParserPK, ElasticSQLParserUUID, ElasticSQLParserMEM, ElasticSQLParserRIGHT, ElasticSQLParserLEFT, ElasticSQLParserALIAS, ElasticSQLParserRLIKE, ElasticSQLParserLIKE, ElasticSQLParserIN, ElasticSQLParserOUT, ElasticSQLParserEXIST, ElasticSQLParserMISS, ElasticSQLParserQUERY_STRING, ElasticSQLParserMATCH, ElasticSQLParserMULTI_MATCH, ElasticSQLParserMATCH_PHRASE_PREFIX, ElasticSQLParserMATCH_PHRASE, ElasticSQLParserKNN, ElasticSQLParserHAS_CHILD, ElasticSQLParserHAS_PARENT, ElasticSQLParserCOUNT, ElasticSQLParserMAX, ElasticSQLParserMIN, ElasticSQLParserAVG, ElasticSQLParserSUM, ElasticSQLParserDISTINCT, ElasticSQLParserVALUE_COUNT, ElasticSQLParserPERCENTILE_RANKS, ElasticSQLParserPERCENTILES, ElasticSQLParserPERCENT, ElasticSQLParserDISTINCT_PERCENT, ElasticSQLParserTOP_HITS, ElasticSQLParserMATH, ElasticSQLParserRANGE, ElasticSQLParserINTERVAL, ElasticSQLParserFORMAT, ElasticSQLParserKEYED, ElasticSQLParserSIZE, ElasticSQLParserMISSING, ElasticSQLParserNULL, ElasticSQLParserEND, ElasticSQLParserSAMPLE, ElasticSQLParserIDS, ElasticSQLParserIDS_FILE, ElasticSQLParserPUT, ElasticSQLParserADD, ElasticSQLParserNUMBER, ElasticSQLParserSTRING, ElasticSQLParserDATETIME_T, ElasticSQLParserTIMESTAMP_T, ElasticSQLParserDATE_T, ElasticSQLParserTIME_T, ElasticSQLParserLOCAL, ElasticSQLParserDATA, ElasticSQLParserLIST, ElasticSQLParserSEPARATED, ElasticSQLParserANALYZE, ElasticSQLParserNLP, ElasticSQLParserENABLE, ElasticSQLParserSEGMENT, ElasticSQLParserNAME, ElasticSQLParserORG, ElasticSQLParserLOC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1718)
			p.NonReserved()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrContext is an interface to support dynamic dispatch.
type IStrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUOTASTR() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	EXT_IDENTIFIER() antlr.TerminalNode

	// IsStrContext differentiates from other interfaces.
	IsStrContext()
}

type StrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrContext() *StrContext {
	var p = new(StrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_str
	return p
}

func InitEmptyStrContext(p *StrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_str
}

func (*StrContext) IsStrContext() {}

func NewStrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrContext {
	var p = new(StrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_str

	return p
}

func (s *StrContext) GetParser() antlr.Parser { return s.parser }

func (s *StrContext) QUOTASTR() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUOTASTR, 0)
}

func (s *StrContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIDENTIFIER, 0)
}

func (s *StrContext) EXT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXT_IDENTIFIER, 0)
}

func (s *StrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterStr(s)
	}
}

func (s *StrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitStr(s)
	}
}

func (s *StrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitStr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Str() (localctx IStrContext) {
	localctx = NewStrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ElasticSQLParserRULE_str)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1721)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-189)) & ^0x3f) == 0 && ((int64(1)<<(_la-189))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNum returns the num token.
	GetNum() antlr.Token

	// SetNum sets the num token.
	SetNum(antlr.Token)

	// Getter signatures
	LONG() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	num    antlr.Token
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) GetNum() antlr.Token { return s.num }

func (s *NumberContext) SetNum(v antlr.Token) { s.num = v }

func (s *NumberContext) LONG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLONG, 0)
}

func (s *NumberContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDOUBLE, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (s *NumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ElasticSQLParserRULE_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1723)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*NumberContext).num = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == ElasticSQLParserLONG || _la == ElasticSQLParserDOUBLE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*NumberContext).num = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ElasticSQLParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1725)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ElasticSQLParserFALSE || _la == ElasticSQLParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode
	STRING() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	SCORE() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	NOT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TO() antlr.TerminalNode
	ID() antlr.TerminalNode
	SLICE() antlr.TerminalNode
	JSON() antlr.TerminalNode
	CSV() antlr.TerminalNode
	SEP() antlr.TerminalNode
	SCRIPT() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	INNER_HIT() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	IN() antlr.TerminalNode
	OUT() antlr.TerminalNode
	EXIST() antlr.TerminalNode
	MISS() antlr.TerminalNode
	QUERY_STRING() antlr.TerminalNode
	HAS_CHILD() antlr.TerminalNode
	HAS_PARENT() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MULTI_MATCH() antlr.TerminalNode
	MATH() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	KNN() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	AVG() antlr.TerminalNode
	SUM() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	VALUE_COUNT() antlr.TerminalNode
	PERCENTILE_RANKS() antlr.TerminalNode
	PERCENTILES() antlr.TerminalNode
	TOP_HITS() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	DISTINCT_PERCENT() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	KEYED() antlr.TerminalNode
	MISSING() antlr.TerminalNode
	NULL() antlr.TerminalNode
	END() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	LANG() antlr.TerminalNode
	RESCORE() antlr.TerminalNode
	WINDOWS() antlr.TerminalNode
	COLLAPSE() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	INCLUDE() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	IDS() antlr.TerminalNode
	IDS_FILE() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	DATA() antlr.TerminalNode
	SEPARATED() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	ADD() antlr.TerminalNode
	PUT() antlr.TerminalNode
	TEMPLATE() antlr.TerminalNode
	LIST() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	PK() antlr.TerminalNode
	UUID() antlr.TerminalNode
	SQL() antlr.TerminalNode
	CK() antlr.TerminalNode
	URL() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	USER() antlr.TerminalNode
	DATE_T() antlr.TerminalNode
	TIME_T() antlr.TerminalNode
	DATETIME_T() antlr.TerminalNode
	TIMESTAMP_T() antlr.TerminalNode
	EXCEL() antlr.TerminalNode
	MEM() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ORG() antlr.TerminalNode
	NLP() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	SEGMENT() antlr.TerminalNode
	NAME() antlr.TerminalNode
	LOC() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ElasticSQLParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ElasticSQLParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNUMBER, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSTRING, 0)
}

func (s *NonReservedContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserGROUP, 0)
}

func (s *NonReservedContext) SCORE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSCORE, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSTRUCT, 0)
}

func (s *NonReservedContext) NOT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNOT, 0)
}

func (s *NonReservedContext) INTO() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINTO, 0)
}

func (s *NonReservedContext) TO() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTO, 0)
}

func (s *NonReservedContext) ID() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserID, 0)
}

func (s *NonReservedContext) SLICE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSLICE, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserJSON, 0)
}

func (s *NonReservedContext) CSV() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCSV, 0)
}

func (s *NonReservedContext) SEP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSEP, 0)
}

func (s *NonReservedContext) SCRIPT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSCRIPT, 0)
}

func (s *NonReservedContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRETURN, 0)
}

func (s *NonReservedContext) INNER_HIT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINNER_HIT, 0)
}

func (s *NonReservedContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRLIKE, 0)
}

func (s *NonReservedContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIKE, 0)
}

func (s *NonReservedContext) IN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIN, 0)
}

func (s *NonReservedContext) OUT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserOUT, 0)
}

func (s *NonReservedContext) EXIST() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXIST, 0)
}

func (s *NonReservedContext) MISS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMISS, 0)
}

func (s *NonReservedContext) QUERY_STRING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserQUERY_STRING, 0)
}

func (s *NonReservedContext) HAS_CHILD() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHAS_CHILD, 0)
}

func (s *NonReservedContext) HAS_PARENT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserHAS_PARENT, 0)
}

func (s *NonReservedContext) MATCH() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMATCH, 0)
}

func (s *NonReservedContext) MULTI_MATCH() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMULTI_MATCH, 0)
}

func (s *NonReservedContext) MATH() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMATH, 0)
}

func (s *NonReservedContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMATCH_PHRASE_PREFIX, 0)
}

func (s *NonReservedContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMATCH_PHRASE, 0)
}

func (s *NonReservedContext) KNN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserKNN, 0)
}

func (s *NonReservedContext) SIZE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSIZE, 0)
}

func (s *NonReservedContext) COUNT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCOUNT, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMAX, 0)
}

func (s *NonReservedContext) MIN() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMIN, 0)
}

func (s *NonReservedContext) AVG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserAVG, 0)
}

func (s *NonReservedContext) SUM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSUM, 0)
}

func (s *NonReservedContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDISTINCT, 0)
}

func (s *NonReservedContext) VALUE_COUNT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserVALUE_COUNT, 0)
}

func (s *NonReservedContext) PERCENTILE_RANKS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPERCENTILE_RANKS, 0)
}

func (s *NonReservedContext) PERCENTILES() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPERCENTILES, 0)
}

func (s *NonReservedContext) TOP_HITS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTOP_HITS, 0)
}

func (s *NonReservedContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPERCENT, 0)
}

func (s *NonReservedContext) DISTINCT_PERCENT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDISTINCT_PERCENT, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINTERVAL, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserFORMAT, 0)
}

func (s *NonReservedContext) KEYED() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserKEYED, 0)
}

func (s *NonReservedContext) MISSING() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMISSING, 0)
}

func (s *NonReservedContext) NULL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNULL, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEND, 0)
}

func (s *NonReservedContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRANGE, 0)
}

func (s *NonReservedContext) LANG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLANG, 0)
}

func (s *NonReservedContext) RESCORE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRESCORE, 0)
}

func (s *NonReservedContext) WINDOWS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserWINDOWS, 0)
}

func (s *NonReservedContext) COLLAPSE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCOLLAPSE, 0)
}

func (s *NonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXCLUDE, 0)
}

func (s *NonReservedContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserINCLUDE, 0)
}

func (s *NonReservedContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSAMPLE, 0)
}

func (s *NonReservedContext) IDS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIDS, 0)
}

func (s *NonReservedContext) IDS_FILE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserIDS_FILE, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLOCAL, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDATA, 0)
}

func (s *NonReservedContext) SEPARATED() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSEPARATED, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserANALYZE, 0)
}

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserADD, 0)
}

func (s *NonReservedContext) PUT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPUT, 0)
}

func (s *NonReservedContext) TEMPLATE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTEMPLATE, 0)
}

func (s *NonReservedContext) LIST() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLIST, 0)
}

func (s *NonReservedContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserALIAS, 0)
}

func (s *NonReservedContext) PK() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPK, 0)
}

func (s *NonReservedContext) UUID() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUUID, 0)
}

func (s *NonReservedContext) SQL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSQL, 0)
}

func (s *NonReservedContext) CK() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserCK, 0)
}

func (s *NonReservedContext) URL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserURL, 0)
}

func (s *NonReservedContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserPASSWORD, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserUSER, 0)
}

func (s *NonReservedContext) DATE_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDATE_T, 0)
}

func (s *NonReservedContext) TIME_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTIME_T, 0)
}

func (s *NonReservedContext) DATETIME_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserDATETIME_T, 0)
}

func (s *NonReservedContext) TIMESTAMP_T() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserTIMESTAMP_T, 0)
}

func (s *NonReservedContext) EXCEL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserEXCEL, 0)
}

func (s *NonReservedContext) MEM() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserMEM, 0)
}

func (s *NonReservedContext) LEFT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLEFT, 0)
}

func (s *NonReservedContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserRIGHT, 0)
}

func (s *NonReservedContext) ALL() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserALL, 0)
}

func (s *NonReservedContext) ORG() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserORG, 0)
}

func (s *NonReservedContext) NLP() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNLP, 0)
}

func (s *NonReservedContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserENABLE, 0)
}

func (s *NonReservedContext) SEGMENT() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserSEGMENT, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserNAME, 0)
}

func (s *NonReservedContext) LOC() antlr.TerminalNode {
	return s.GetToken(ElasticSQLParserLOC, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ElasticSQLListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ElasticSQLVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ElasticSQLParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ElasticSQLParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1727)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3562272993694187520) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-513428087574497293) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&4393182697685) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *ElasticSQLParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 13:
		var t *LogicalExprContext = nil
		if localctx != nil {
			t = localctx.(*LogicalExprContext)
		}
		return p.LogicalExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ElasticSQLParser) LogicalExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
